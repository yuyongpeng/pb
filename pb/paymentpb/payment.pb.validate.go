// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pb/paymentpb/payment.proto

package paymentpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on MerchantDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MerchantDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MerchantDetailMultiError,
// or nil if none found.
func (m *MerchantDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MerchantId

	// no validation rules for UserId

	// no validation rules for PayChannel

	// no validation rules for MerchantNo

	// no validation rules for PayMerchantNo

	// no validation rules for MerchantName

	// no validation rules for MerchantType

	// no validation rules for PayApplyNo

	// no validation rules for SettleData

	// no validation rules for FeeRate

	// no validation rules for ApplyAt

	// no validation rules for CertifyAt

	// no validation rules for CertifyMsg

	// no validation rules for ApplyStatus

	// no validation rules for AuditStatus

	// no validation rules for ModifiedAt

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return MerchantDetailMultiError(errors)
	}

	return nil
}

// MerchantDetailMultiError is an error wrapping multiple validation errors
// returned by MerchantDetail.ValidateAll() if the designated constraints
// aren't met.
type MerchantDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantDetailMultiError) AllErrors() []error { return m }

// MerchantDetailValidationError is the validation error returned by
// MerchantDetail.Validate if the designated constraints aren't met.
type MerchantDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantDetailValidationError) ErrorName() string { return "MerchantDetailValidationError" }

// Error satisfies the builtin error interface
func (e MerchantDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantDetailValidationError{}

// Validate checks the field values on MerchantDetailIn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MerchantDetailIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantDetailIn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantDetailInMultiError, or nil if none found.
func (m *MerchantDetailIn) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantDetailIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MerchantId

	// no validation rules for MerchantNo

	if len(errors) > 0 {
		return MerchantDetailInMultiError(errors)
	}

	return nil
}

// MerchantDetailInMultiError is an error wrapping multiple validation errors
// returned by MerchantDetailIn.ValidateAll() if the designated constraints
// aren't met.
type MerchantDetailInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantDetailInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantDetailInMultiError) AllErrors() []error { return m }

// MerchantDetailInValidationError is the validation error returned by
// MerchantDetailIn.Validate if the designated constraints aren't met.
type MerchantDetailInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantDetailInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantDetailInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantDetailInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantDetailInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantDetailInValidationError) ErrorName() string { return "MerchantDetailInValidationError" }

// Error satisfies the builtin error interface
func (e MerchantDetailInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantDetailIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantDetailInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantDetailInValidationError{}

// Validate checks the field values on MerchantDetailOut with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MerchantDetailOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantDetailOut with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantDetailOutMultiError, or nil if none found.
func (m *MerchantDetailOut) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantDetailOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantDetailOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantDetailOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantDetailOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MerchantDetailOutMultiError(errors)
	}

	return nil
}

// MerchantDetailOutMultiError is an error wrapping multiple validation errors
// returned by MerchantDetailOut.ValidateAll() if the designated constraints
// aren't met.
type MerchantDetailOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantDetailOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantDetailOutMultiError) AllErrors() []error { return m }

// MerchantDetailOutValidationError is the validation error returned by
// MerchantDetailOut.Validate if the designated constraints aren't met.
type MerchantDetailOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantDetailOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantDetailOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantDetailOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantDetailOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantDetailOutValidationError) ErrorName() string {
	return "MerchantDetailOutValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantDetailOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantDetailOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantDetailOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantDetailOutValidationError{}

// Validate checks the field values on MerchantListIn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MerchantListIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantListIn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MerchantListInMultiError,
// or nil if none found.
func (m *MerchantListIn) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantListIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return MerchantListInMultiError(errors)
	}

	return nil
}

// MerchantListInMultiError is an error wrapping multiple validation errors
// returned by MerchantListIn.ValidateAll() if the designated constraints
// aren't met.
type MerchantListInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantListInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantListInMultiError) AllErrors() []error { return m }

// MerchantListInValidationError is the validation error returned by
// MerchantListIn.Validate if the designated constraints aren't met.
type MerchantListInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantListInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantListInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantListInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantListInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantListInValidationError) ErrorName() string { return "MerchantListInValidationError" }

// Error satisfies the builtin error interface
func (e MerchantListInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantListIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantListInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantListInValidationError{}

// Validate checks the field values on MerchantListOut with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MerchantListOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantListOut with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantListOutMultiError, or nil if none found.
func (m *MerchantListOut) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantListOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantListOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantListOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantListOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MerchantListOutMultiError(errors)
	}

	return nil
}

// MerchantListOutMultiError is an error wrapping multiple validation errors
// returned by MerchantListOut.ValidateAll() if the designated constraints
// aren't met.
type MerchantListOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantListOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantListOutMultiError) AllErrors() []error { return m }

// MerchantListOutValidationError is the validation error returned by
// MerchantListOut.Validate if the designated constraints aren't met.
type MerchantListOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantListOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantListOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantListOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantListOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantListOutValidationError) ErrorName() string { return "MerchantListOutValidationError" }

// Error satisfies the builtin error interface
func (e MerchantListOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantListOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantListOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantListOutValidationError{}

// Validate checks the field values on MerchantApplyIn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantApplyIn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantApplyInMultiError, or nil if none found.
func (m *MerchantApplyIn) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptChannel

	// no validation rules for PayChannel

	// no validation rules for UserId

	// no validation rules for MerchantNo

	// no validation rules for NotifyUrl

	if all {
		switch v := interface{}(m.GetAlipayApplyData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantApplyInValidationError{
					field:  "AlipayApplyData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantApplyInValidationError{
					field:  "AlipayApplyData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlipayApplyData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantApplyInValidationError{
				field:  "AlipayApplyData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWxpayRegData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantApplyInValidationError{
					field:  "WxpayRegData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantApplyInValidationError{
					field:  "WxpayRegData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWxpayRegData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantApplyInValidationError{
				field:  "WxpayRegData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SkipUserChecking

	if len(errors) > 0 {
		return MerchantApplyInMultiError(errors)
	}

	return nil
}

// MerchantApplyInMultiError is an error wrapping multiple validation errors
// returned by MerchantApplyIn.ValidateAll() if the designated constraints
// aren't met.
type MerchantApplyInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyInMultiError) AllErrors() []error { return m }

// MerchantApplyInValidationError is the validation error returned by
// MerchantApplyIn.Validate if the designated constraints aren't met.
type MerchantApplyInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantApplyInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantApplyInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantApplyInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantApplyInValidationError) ErrorName() string { return "MerchantApplyInValidationError" }

// Error satisfies the builtin error interface
func (e MerchantApplyInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyInValidationError{}

// Validate checks the field values on MerchantApplyOut with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantApplyOut with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantApplyOutMultiError, or nil if none found.
func (m *MerchantApplyOut) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantApplyOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantApplyOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantApplyOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MerchantApplyOutMultiError(errors)
	}

	return nil
}

// MerchantApplyOutMultiError is an error wrapping multiple validation errors
// returned by MerchantApplyOut.ValidateAll() if the designated constraints
// aren't met.
type MerchantApplyOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyOutMultiError) AllErrors() []error { return m }

// MerchantApplyOutValidationError is the validation error returned by
// MerchantApplyOut.Validate if the designated constraints aren't met.
type MerchantApplyOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantApplyOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantApplyOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantApplyOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantApplyOutValidationError) ErrorName() string { return "MerchantApplyOutValidationError" }

// Error satisfies the builtin error interface
func (e MerchantApplyOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyOutValidationError{}

// Validate checks the field values on MerchantApplyQueryIn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyQueryIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantApplyQueryIn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantApplyQueryInMultiError, or nil if none found.
func (m *MerchantApplyQueryIn) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyQueryIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptChannel

	if _, ok := _MerchantApplyQueryIn_PayChannel_InLookup[m.GetPayChannel()]; !ok {
		err := MerchantApplyQueryInValidationError{
			field:  "PayChannel",
			reason: "value must be in list [alipay_zft alipay_merchant]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RegApplyNo

	// no validation rules for MerchantNo

	if len(errors) > 0 {
		return MerchantApplyQueryInMultiError(errors)
	}

	return nil
}

// MerchantApplyQueryInMultiError is an error wrapping multiple validation
// errors returned by MerchantApplyQueryIn.ValidateAll() if the designated
// constraints aren't met.
type MerchantApplyQueryInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyQueryInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyQueryInMultiError) AllErrors() []error { return m }

// MerchantApplyQueryInValidationError is the validation error returned by
// MerchantApplyQueryIn.Validate if the designated constraints aren't met.
type MerchantApplyQueryInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyQueryInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantApplyQueryInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantApplyQueryInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantApplyQueryInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantApplyQueryInValidationError) ErrorName() string {
	return "MerchantApplyQueryInValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantApplyQueryInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyQueryIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyQueryInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyQueryInValidationError{}

var _MerchantApplyQueryIn_PayChannel_InLookup = map[string]struct{}{
	"alipay_zft":      {},
	"alipay_merchant": {},
}

// Validate checks the field values on MerchantApplyQueryOut with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyQueryOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantApplyQueryOut with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantApplyQueryOutMultiError, or nil if none found.
func (m *MerchantApplyQueryOut) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyQueryOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantApplyQueryOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantApplyQueryOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantApplyQueryOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MerchantApplyQueryOutMultiError(errors)
	}

	return nil
}

// MerchantApplyQueryOutMultiError is an error wrapping multiple validation
// errors returned by MerchantApplyQueryOut.ValidateAll() if the designated
// constraints aren't met.
type MerchantApplyQueryOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyQueryOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyQueryOutMultiError) AllErrors() []error { return m }

// MerchantApplyQueryOutValidationError is the validation error returned by
// MerchantApplyQueryOut.Validate if the designated constraints aren't met.
type MerchantApplyQueryOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyQueryOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantApplyQueryOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantApplyQueryOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantApplyQueryOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantApplyQueryOutValidationError) ErrorName() string {
	return "MerchantApplyQueryOutValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantApplyQueryOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyQueryOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyQueryOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyQueryOutValidationError{}

// Validate checks the field values on NotifyIn with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NotifyIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotifyIn with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotifyInMultiError, or nil
// if none found.
func (m *NotifyIn) ValidateAll() error {
	return m.validate(true)
}

func (m *NotifyIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PayChannel

	// no validation rules for NotifyType

	if all {
		switch v := interface{}(m.GetAlipayMerchantApplyNotifyMsg()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyInValidationError{
					field:  "AlipayMerchantApplyNotifyMsg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyInValidationError{
					field:  "AlipayMerchantApplyNotifyMsg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlipayMerchantApplyNotifyMsg()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyInValidationError{
				field:  "AlipayMerchantApplyNotifyMsg",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAlipayPayNotifyMsg()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyInValidationError{
					field:  "AlipayPayNotifyMsg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyInValidationError{
					field:  "AlipayPayNotifyMsg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlipayPayNotifyMsg()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyInValidationError{
				field:  "AlipayPayNotifyMsg",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWxpayMerchantApplyNotifyMsg()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyInValidationError{
					field:  "WxpayMerchantApplyNotifyMsg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyInValidationError{
					field:  "WxpayMerchantApplyNotifyMsg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWxpayMerchantApplyNotifyMsg()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyInValidationError{
				field:  "WxpayMerchantApplyNotifyMsg",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWxpayPayNotifyMsg()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifyInValidationError{
					field:  "WxpayPayNotifyMsg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifyInValidationError{
					field:  "WxpayPayNotifyMsg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWxpayPayNotifyMsg()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifyInValidationError{
				field:  "WxpayPayNotifyMsg",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NotifyInMultiError(errors)
	}

	return nil
}

// NotifyInMultiError is an error wrapping multiple validation errors returned
// by NotifyIn.ValidateAll() if the designated constraints aren't met.
type NotifyInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifyInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifyInMultiError) AllErrors() []error { return m }

// NotifyInValidationError is the validation error returned by
// NotifyIn.Validate if the designated constraints aren't met.
type NotifyInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifyInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifyInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifyInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifyInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifyInValidationError) ErrorName() string { return "NotifyInValidationError" }

// Error satisfies the builtin error interface
func (e NotifyInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifyIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifyInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifyInValidationError{}

// Validate checks the field values on PayIn with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PayIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PayIn with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PayInMultiError, or nil if none found.
func (m *PayIn) ValidateAll() error {
	return m.validate(true)
}

func (m *PayIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptChannel

	// no validation rules for PayChannel

	// no validation rules for PayScene

	// no validation rules for MerchantNo

	// no validation rules for OutTradeNo

	// no validation rules for TotalAmount

	// no validation rules for Subject

	// no validation rules for Body

	// no validation rules for NotifyUrl

	// no validation rules for ProfitSharing

	// no validation rules for QuitUrl

	// no validation rules for ReturnUrl

	// no validation rules for Extra

	// no validation rules for TimeExpire

	if len(errors) > 0 {
		return PayInMultiError(errors)
	}

	return nil
}

// PayInMultiError is an error wrapping multiple validation errors returned by
// PayIn.ValidateAll() if the designated constraints aren't met.
type PayInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayInMultiError) AllErrors() []error { return m }

// PayInValidationError is the validation error returned by PayIn.Validate if
// the designated constraints aren't met.
type PayInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayInValidationError) ErrorName() string { return "PayInValidationError" }

// Error satisfies the builtin error interface
func (e PayInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayInValidationError{}

// Validate checks the field values on WxpayParamsJSAPI with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WxpayParamsJSAPI) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WxpayParamsJSAPI with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WxpayParamsJSAPIMultiError, or nil if none found.
func (m *WxpayParamsJSAPI) ValidateAll() error {
	return m.validate(true)
}

func (m *WxpayParamsJSAPI) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Timestamp

	// no validation rules for NonceStr

	// no validation rules for Package

	// no validation rules for SignType

	// no validation rules for PaySign

	if len(errors) > 0 {
		return WxpayParamsJSAPIMultiError(errors)
	}

	return nil
}

// WxpayParamsJSAPIMultiError is an error wrapping multiple validation errors
// returned by WxpayParamsJSAPI.ValidateAll() if the designated constraints
// aren't met.
type WxpayParamsJSAPIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WxpayParamsJSAPIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WxpayParamsJSAPIMultiError) AllErrors() []error { return m }

// WxpayParamsJSAPIValidationError is the validation error returned by
// WxpayParamsJSAPI.Validate if the designated constraints aren't met.
type WxpayParamsJSAPIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WxpayParamsJSAPIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WxpayParamsJSAPIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WxpayParamsJSAPIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WxpayParamsJSAPIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WxpayParamsJSAPIValidationError) ErrorName() string { return "WxpayParamsJSAPIValidationError" }

// Error satisfies the builtin error interface
func (e WxpayParamsJSAPIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWxpayParamsJSAPI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WxpayParamsJSAPIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WxpayParamsJSAPIValidationError{}

// Validate checks the field values on WxpayParamsAPP with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WxpayParamsAPP) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WxpayParamsAPP with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WxpayParamsAPPMultiError,
// or nil if none found.
func (m *WxpayParamsAPP) ValidateAll() error {
	return m.validate(true)
}

func (m *WxpayParamsAPP) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PrepayId

	// no validation rules for PartnerId

	// no validation rules for Timestamp

	// no validation rules for NonceStr

	// no validation rules for Package

	// no validation rules for Sign

	if len(errors) > 0 {
		return WxpayParamsAPPMultiError(errors)
	}

	return nil
}

// WxpayParamsAPPMultiError is an error wrapping multiple validation errors
// returned by WxpayParamsAPP.ValidateAll() if the designated constraints
// aren't met.
type WxpayParamsAPPMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WxpayParamsAPPMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WxpayParamsAPPMultiError) AllErrors() []error { return m }

// WxpayParamsAPPValidationError is the validation error returned by
// WxpayParamsAPP.Validate if the designated constraints aren't met.
type WxpayParamsAPPValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WxpayParamsAPPValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WxpayParamsAPPValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WxpayParamsAPPValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WxpayParamsAPPValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WxpayParamsAPPValidationError) ErrorName() string { return "WxpayParamsAPPValidationError" }

// Error satisfies the builtin error interface
func (e WxpayParamsAPPValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWxpayParamsAPP.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WxpayParamsAPPValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WxpayParamsAPPValidationError{}

// Validate checks the field values on PayOut with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PayOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PayOut with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PayOutMultiError, or nil if none found.
func (m *PayOut) ValidateAll() error {
	return m.validate(true)
}

func (m *PayOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PayOutMultiError(errors)
	}

	return nil
}

// PayOutMultiError is an error wrapping multiple validation errors returned by
// PayOut.ValidateAll() if the designated constraints aren't met.
type PayOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayOutMultiError) AllErrors() []error { return m }

// PayOutValidationError is the validation error returned by PayOut.Validate if
// the designated constraints aren't met.
type PayOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayOutValidationError) ErrorName() string { return "PayOutValidationError" }

// Error satisfies the builtin error interface
func (e PayOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayOutValidationError{}

// Validate checks the field values on PayQueryIn with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PayQueryIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PayQueryIn with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PayQueryInMultiError, or
// nil if none found.
func (m *PayQueryIn) ValidateAll() error {
	return m.validate(true)
}

func (m *PayQueryIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptChannel

	// no validation rules for PayChannel

	// no validation rules for MerchantNo

	// no validation rules for OutTradeNo

	// no validation rules for TradeNo

	if len(errors) > 0 {
		return PayQueryInMultiError(errors)
	}

	return nil
}

// PayQueryInMultiError is an error wrapping multiple validation errors
// returned by PayQueryIn.ValidateAll() if the designated constraints aren't met.
type PayQueryInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayQueryInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayQueryInMultiError) AllErrors() []error { return m }

// PayQueryInValidationError is the validation error returned by
// PayQueryIn.Validate if the designated constraints aren't met.
type PayQueryInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayQueryInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayQueryInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayQueryInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayQueryInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayQueryInValidationError) ErrorName() string { return "PayQueryInValidationError" }

// Error satisfies the builtin error interface
func (e PayQueryInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayQueryIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayQueryInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayQueryInValidationError{}

// Validate checks the field values on PayQueryOut with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PayQueryOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PayQueryOut with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PayQueryOutMultiError, or
// nil if none found.
func (m *PayQueryOut) ValidateAll() error {
	return m.validate(true)
}

func (m *PayQueryOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayQueryOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayQueryOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayQueryOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PayQueryOutMultiError(errors)
	}

	return nil
}

// PayQueryOutMultiError is an error wrapping multiple validation errors
// returned by PayQueryOut.ValidateAll() if the designated constraints aren't met.
type PayQueryOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayQueryOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayQueryOutMultiError) AllErrors() []error { return m }

// PayQueryOutValidationError is the validation error returned by
// PayQueryOut.Validate if the designated constraints aren't met.
type PayQueryOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayQueryOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayQueryOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayQueryOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayQueryOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayQueryOutValidationError) ErrorName() string { return "PayQueryOutValidationError" }

// Error satisfies the builtin error interface
func (e PayQueryOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayQueryOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayQueryOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayQueryOutValidationError{}

// Validate checks the field values on RefundIn with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefundIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundIn with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefundInMultiError, or nil
// if none found.
func (m *RefundIn) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptChannel

	// no validation rules for PayChannel

	// no validation rules for MerchantNo

	// no validation rules for OutTradeNo

	// no validation rules for RefundAmount

	// no validation rules for RefundReason

	// no validation rules for NotifyUrl

	if len(errors) > 0 {
		return RefundInMultiError(errors)
	}

	return nil
}

// RefundInMultiError is an error wrapping multiple validation errors returned
// by RefundIn.ValidateAll() if the designated constraints aren't met.
type RefundInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundInMultiError) AllErrors() []error { return m }

// RefundInValidationError is the validation error returned by
// RefundIn.Validate if the designated constraints aren't met.
type RefundInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundInValidationError) ErrorName() string { return "RefundInValidationError" }

// Error satisfies the builtin error interface
func (e RefundInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundInValidationError{}

// Validate checks the field values on RefundOut with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefundOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundOut with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefundOutMultiError, or nil
// if none found.
func (m *RefundOut) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefundOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefundOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefundOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RefundOutMultiError(errors)
	}

	return nil
}

// RefundOutMultiError is an error wrapping multiple validation errors returned
// by RefundOut.ValidateAll() if the designated constraints aren't met.
type RefundOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundOutMultiError) AllErrors() []error { return m }

// RefundOutValidationError is the validation error returned by
// RefundOut.Validate if the designated constraints aren't met.
type RefundOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundOutValidationError) ErrorName() string { return "RefundOutValidationError" }

// Error satisfies the builtin error interface
func (e RefundOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundOutValidationError{}

// Validate checks the field values on RefundQueryIn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefundQueryIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundQueryIn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefundQueryInMultiError, or
// nil if none found.
func (m *RefundQueryIn) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundQueryIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptChannel

	// no validation rules for PayChannel

	// no validation rules for RequestNo

	if len(errors) > 0 {
		return RefundQueryInMultiError(errors)
	}

	return nil
}

// RefundQueryInMultiError is an error wrapping multiple validation errors
// returned by RefundQueryIn.ValidateAll() if the designated constraints
// aren't met.
type RefundQueryInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundQueryInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundQueryInMultiError) AllErrors() []error { return m }

// RefundQueryInValidationError is the validation error returned by
// RefundQueryIn.Validate if the designated constraints aren't met.
type RefundQueryInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundQueryInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundQueryInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundQueryInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundQueryInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundQueryInValidationError) ErrorName() string { return "RefundQueryInValidationError" }

// Error satisfies the builtin error interface
func (e RefundQueryInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundQueryIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundQueryInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundQueryInValidationError{}

// Validate checks the field values on RefundQueryOut with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefundQueryOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundQueryOut with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefundQueryOutMultiError,
// or nil if none found.
func (m *RefundQueryOut) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundQueryOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefundQueryOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefundQueryOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefundQueryOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RefundQueryOutMultiError(errors)
	}

	return nil
}

// RefundQueryOutMultiError is an error wrapping multiple validation errors
// returned by RefundQueryOut.ValidateAll() if the designated constraints
// aren't met.
type RefundQueryOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundQueryOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundQueryOutMultiError) AllErrors() []error { return m }

// RefundQueryOutValidationError is the validation error returned by
// RefundQueryOut.Validate if the designated constraints aren't met.
type RefundQueryOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundQueryOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundQueryOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundQueryOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundQueryOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundQueryOutValidationError) ErrorName() string { return "RefundQueryOutValidationError" }

// Error satisfies the builtin error interface
func (e RefundQueryOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundQueryOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundQueryOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundQueryOutValidationError{}

// Validate checks the field values on AmtSettleIn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AmtSettleIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmtSettleIn with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AmtSettleInMultiError, or
// nil if none found.
func (m *AmtSettleIn) ValidateAll() error {
	return m.validate(true)
}

func (m *AmtSettleIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptChannel

	// no validation rules for PayChannel

	// no validation rules for OutTradeNo

	// no validation rules for Amount

	if all {
		switch v := interface{}(m.GetExtraParams()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AmtSettleInValidationError{
					field:  "ExtraParams",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AmtSettleInValidationError{
					field:  "ExtraParams",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtraParams()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AmtSettleInValidationError{
				field:  "ExtraParams",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AmtSettleInMultiError(errors)
	}

	return nil
}

// AmtSettleInMultiError is an error wrapping multiple validation errors
// returned by AmtSettleIn.ValidateAll() if the designated constraints aren't met.
type AmtSettleInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmtSettleInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmtSettleInMultiError) AllErrors() []error { return m }

// AmtSettleInValidationError is the validation error returned by
// AmtSettleIn.Validate if the designated constraints aren't met.
type AmtSettleInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmtSettleInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmtSettleInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmtSettleInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmtSettleInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmtSettleInValidationError) ErrorName() string { return "AmtSettleInValidationError" }

// Error satisfies the builtin error interface
func (e AmtSettleInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmtSettleIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmtSettleInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmtSettleInValidationError{}

// Validate checks the field values on AmtSettleOut with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AmtSettleOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmtSettleOut with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AmtSettleOutMultiError, or
// nil if none found.
func (m *AmtSettleOut) ValidateAll() error {
	return m.validate(true)
}

func (m *AmtSettleOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AmtSettleOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AmtSettleOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AmtSettleOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AmtSettleOutMultiError(errors)
	}

	return nil
}

// AmtSettleOutMultiError is an error wrapping multiple validation errors
// returned by AmtSettleOut.ValidateAll() if the designated constraints aren't met.
type AmtSettleOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmtSettleOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmtSettleOutMultiError) AllErrors() []error { return m }

// AmtSettleOutValidationError is the validation error returned by
// AmtSettleOut.Validate if the designated constraints aren't met.
type AmtSettleOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmtSettleOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmtSettleOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmtSettleOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmtSettleOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmtSettleOutValidationError) ErrorName() string { return "AmtSettleOutValidationError" }

// Error satisfies the builtin error interface
func (e AmtSettleOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmtSettleOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmtSettleOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmtSettleOutValidationError{}

// Validate checks the field values on TransferInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransferInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferInfoMultiError, or
// nil if none found.
func (m *TransferInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MerchantNo

	// no validation rules for Account

	// no validation rules for Name

	// no validation rules for Desc

	switch v := m.Value.(type) {
	case *TransferInfo_Rate:
		if v == nil {
			err := TransferInfoValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Rate
	case *TransferInfo_Amount:
		if v == nil {
			err := TransferInfoValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Amount
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TransferInfoMultiError(errors)
	}

	return nil
}

// TransferInfoMultiError is an error wrapping multiple validation errors
// returned by TransferInfo.ValidateAll() if the designated constraints aren't met.
type TransferInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferInfoMultiError) AllErrors() []error { return m }

// TransferInfoValidationError is the validation error returned by
// TransferInfo.Validate if the designated constraints aren't met.
type TransferInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferInfoValidationError) ErrorName() string { return "TransferInfoValidationError" }

// Error satisfies the builtin error interface
func (e TransferInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferInfoValidationError{}

// Validate checks the field values on OrderSettleIn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderSettleIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderSettleIn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderSettleInMultiError, or
// nil if none found.
func (m *OrderSettleIn) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderSettleIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptChannel

	// no validation rules for PayChannel

	// no validation rules for OutTradeNo

	if all {
		switch v := interface{}(m.GetSettlementParams()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderSettleInValidationError{
					field:  "SettlementParams",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderSettleInValidationError{
					field:  "SettlementParams",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettlementParams()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderSettleInValidationError{
				field:  "SettlementParams",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrderSettleInMultiError(errors)
	}

	return nil
}

// OrderSettleInMultiError is an error wrapping multiple validation errors
// returned by OrderSettleIn.ValidateAll() if the designated constraints
// aren't met.
type OrderSettleInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderSettleInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderSettleInMultiError) AllErrors() []error { return m }

// OrderSettleInValidationError is the validation error returned by
// OrderSettleIn.Validate if the designated constraints aren't met.
type OrderSettleInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderSettleInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderSettleInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderSettleInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderSettleInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderSettleInValidationError) ErrorName() string { return "OrderSettleInValidationError" }

// Error satisfies the builtin error interface
func (e OrderSettleInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderSettleIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderSettleInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderSettleInValidationError{}

// Validate checks the field values on OrderSettleOut with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderSettleOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderSettleOut with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderSettleOutMultiError,
// or nil if none found.
func (m *OrderSettleOut) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderSettleOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderSettleOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderSettleOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderSettleOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrderSettleOutMultiError(errors)
	}

	return nil
}

// OrderSettleOutMultiError is an error wrapping multiple validation errors
// returned by OrderSettleOut.ValidateAll() if the designated constraints
// aren't met.
type OrderSettleOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderSettleOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderSettleOutMultiError) AllErrors() []error { return m }

// OrderSettleOutValidationError is the validation error returned by
// OrderSettleOut.Validate if the designated constraints aren't met.
type OrderSettleOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderSettleOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderSettleOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderSettleOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderSettleOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderSettleOutValidationError) ErrorName() string { return "OrderSettleOutValidationError" }

// Error satisfies the builtin error interface
func (e OrderSettleOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderSettleOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderSettleOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderSettleOutValidationError{}

// Validate checks the field values on OrderSettleQueryIn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderSettleQueryIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderSettleQueryIn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderSettleQueryInMultiError, or nil if none found.
func (m *OrderSettleQueryIn) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderSettleQueryIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptChannel

	if utf8.RuneCountInString(m.GetOutRequestNo()) < 1 {
		err := OrderSettleQueryInValidationError{
			field:  "OutRequestNo",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OrderSettleQueryInMultiError(errors)
	}

	return nil
}

// OrderSettleQueryInMultiError is an error wrapping multiple validation errors
// returned by OrderSettleQueryIn.ValidateAll() if the designated constraints
// aren't met.
type OrderSettleQueryInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderSettleQueryInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderSettleQueryInMultiError) AllErrors() []error { return m }

// OrderSettleQueryInValidationError is the validation error returned by
// OrderSettleQueryIn.Validate if the designated constraints aren't met.
type OrderSettleQueryInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderSettleQueryInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderSettleQueryInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderSettleQueryInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderSettleQueryInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderSettleQueryInValidationError) ErrorName() string {
	return "OrderSettleQueryInValidationError"
}

// Error satisfies the builtin error interface
func (e OrderSettleQueryInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderSettleQueryIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderSettleQueryInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderSettleQueryInValidationError{}

// Validate checks the field values on OrderSettleQueryOut with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderSettleQueryOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderSettleQueryOut with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderSettleQueryOutMultiError, or nil if none found.
func (m *OrderSettleQueryOut) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderSettleQueryOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderSettleQueryOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderSettleQueryOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderSettleQueryOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrderSettleQueryOutMultiError(errors)
	}

	return nil
}

// OrderSettleQueryOutMultiError is an error wrapping multiple validation
// errors returned by OrderSettleQueryOut.ValidateAll() if the designated
// constraints aren't met.
type OrderSettleQueryOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderSettleQueryOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderSettleQueryOutMultiError) AllErrors() []error { return m }

// OrderSettleQueryOutValidationError is the validation error returned by
// OrderSettleQueryOut.Validate if the designated constraints aren't met.
type OrderSettleQueryOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderSettleQueryOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderSettleQueryOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderSettleQueryOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderSettleQueryOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderSettleQueryOutValidationError) ErrorName() string {
	return "OrderSettleQueryOutValidationError"
}

// Error satisfies the builtin error interface
func (e OrderSettleQueryOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderSettleQueryOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderSettleQueryOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderSettleQueryOutValidationError{}

// Validate checks the field values on BillQueryIn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillQueryIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillQueryIn with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillQueryInMultiError, or
// nil if none found.
func (m *BillQueryIn) ValidateAll() error {
	return m.validate(true)
}

func (m *BillQueryIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptChannel

	// no validation rules for PayChannel

	// no validation rules for Date

	if len(errors) > 0 {
		return BillQueryInMultiError(errors)
	}

	return nil
}

// BillQueryInMultiError is an error wrapping multiple validation errors
// returned by BillQueryIn.ValidateAll() if the designated constraints aren't met.
type BillQueryInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillQueryInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillQueryInMultiError) AllErrors() []error { return m }

// BillQueryInValidationError is the validation error returned by
// BillQueryIn.Validate if the designated constraints aren't met.
type BillQueryInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillQueryInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillQueryInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillQueryInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillQueryInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillQueryInValidationError) ErrorName() string { return "BillQueryInValidationError" }

// Error satisfies the builtin error interface
func (e BillQueryInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillQueryIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillQueryInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillQueryInValidationError{}

// Validate checks the field values on BillQueryOut with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillQueryOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillQueryOut with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillQueryOutMultiError, or
// nil if none found.
func (m *BillQueryOut) ValidateAll() error {
	return m.validate(true)
}

func (m *BillQueryOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillQueryOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillQueryOutValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillQueryOutValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BillQueryOutMultiError(errors)
	}

	return nil
}

// BillQueryOutMultiError is an error wrapping multiple validation errors
// returned by BillQueryOut.ValidateAll() if the designated constraints aren't met.
type BillQueryOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillQueryOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillQueryOutMultiError) AllErrors() []error { return m }

// BillQueryOutValidationError is the validation error returned by
// BillQueryOut.Validate if the designated constraints aren't met.
type BillQueryOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillQueryOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillQueryOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillQueryOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillQueryOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillQueryOutValidationError) ErrorName() string { return "BillQueryOutValidationError" }

// Error satisfies the builtin error interface
func (e BillQueryOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillQueryOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillQueryOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillQueryOutValidationError{}

// Validate checks the field values on MerchantListOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MerchantListOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantListOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantListOut_DataMultiError, or nil if none found.
func (m *MerchantListOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantListOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	// no validation rules for PageTotal

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MerchantListOut_DataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MerchantListOut_DataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MerchantListOut_DataValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MerchantListOut_DataMultiError(errors)
	}

	return nil
}

// MerchantListOut_DataMultiError is an error wrapping multiple validation
// errors returned by MerchantListOut_Data.ValidateAll() if the designated
// constraints aren't met.
type MerchantListOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantListOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantListOut_DataMultiError) AllErrors() []error { return m }

// MerchantListOut_DataValidationError is the validation error returned by
// MerchantListOut_Data.Validate if the designated constraints aren't met.
type MerchantListOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantListOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantListOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantListOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantListOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantListOut_DataValidationError) ErrorName() string {
	return "MerchantListOut_DataValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantListOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantListOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantListOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantListOut_DataValidationError{}

// Validate checks the field values on
// MerchantApplyIn_MerchantApplyDataForAlipayZFT with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MerchantApplyIn_MerchantApplyDataForAlipayZFT with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// MerchantApplyIn_MerchantApplyDataForAlipayZFTMultiError, or nil if none found.
func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for AliasName

	// no validation rules for MerchantType

	// no validation rules for Mcc

	// no validation rules for ExternalId

	if all {
		switch v := interface{}(m.GetDefaultSettleRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
					field:  "DefaultSettleRule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
					field:  "DefaultSettleRule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultSettleRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
				field:  "DefaultSettleRule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AlipayLogonId

	// no validation rules for BindingAlipayLogonId

	if all {
		switch v := interface{}(m.GetContactInfos()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
					field:  "ContactInfos",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
					field:  "ContactInfos",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContactInfos()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
				field:  "ContactInfos",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSites() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
						field:  fmt.Sprintf("Sites[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
						field:  fmt.Sprintf("Sites[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
					field:  fmt.Sprintf("Sites[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetBusinessAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
					field:  "BusinessAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
					field:  "BusinessAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBusinessAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{
				field:  "BusinessAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MerchantApplyIn_MerchantApplyDataForAlipayZFTMultiError(errors)
	}

	return nil
}

// MerchantApplyIn_MerchantApplyDataForAlipayZFTMultiError is an error wrapping
// multiple validation errors returned by
// MerchantApplyIn_MerchantApplyDataForAlipayZFT.ValidateAll() if the
// designated constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForAlipayZFTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyIn_MerchantApplyDataForAlipayZFTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyIn_MerchantApplyDataForAlipayZFTMultiError) AllErrors() []error { return m }

// MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError is the
// validation error returned by
// MerchantApplyIn_MerchantApplyDataForAlipayZFT.Validate if the designated
// constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError) ErrorName() string {
	return "MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyIn_MerchantApplyDataForAlipayZFT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyIn_MerchantApplyDataForAlipayZFTValidationError{}

// Validate checks the field values on
// MerchantApplyIn_MerchantApplyDataForWxpaySFT with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyIn_MerchantApplyDataForWxpaySFT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MerchantApplyIn_MerchantApplyDataForWxpaySFT with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// MerchantApplyIn_MerchantApplyDataForWxpaySFTMultiError, or nil if none found.
func (m *MerchantApplyIn_MerchantApplyDataForWxpaySFT) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyIn_MerchantApplyDataForWxpaySFT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return MerchantApplyIn_MerchantApplyDataForWxpaySFTMultiError(errors)
	}

	return nil
}

// MerchantApplyIn_MerchantApplyDataForWxpaySFTMultiError is an error wrapping
// multiple validation errors returned by
// MerchantApplyIn_MerchantApplyDataForWxpaySFT.ValidateAll() if the
// designated constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForWxpaySFTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyIn_MerchantApplyDataForWxpaySFTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyIn_MerchantApplyDataForWxpaySFTMultiError) AllErrors() []error { return m }

// MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError is the
// validation error returned by
// MerchantApplyIn_MerchantApplyDataForWxpaySFT.Validate if the designated
// constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError) ErrorName() string {
	return "MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyIn_MerchantApplyDataForWxpaySFT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyIn_MerchantApplyDataForWxpaySFTValidationError{}

// Validate checks the field values on
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleMultiError,
// or nil if none found.
func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRule) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DefaultSettleType

	// no validation rules for DefaultSettleTarget

	if len(errors) > 0 {
		return MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleMultiError(errors)
	}

	return nil
}

// MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleMultiError is
// an error wrapping multiple validation errors returned by
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRule.ValidateAll()
// if the designated constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleMultiError) AllErrors() []error {
	return m
}

// MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError
// is the validation error returned by
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRule.Validate if
// the designated constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError) ErrorName() string {
	return "MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyIn_MerchantApplyDataForAlipayZFT_DefaultSettleRuleValidationError{}

// Validate checks the field values on
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoMultiError, or nil
// if none found.
func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Phone

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for IdCardNo

	if len(errors) > 0 {
		return MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoMultiError(errors)
	}

	return nil
}

// MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoMultiError is an
// error wrapping multiple validation errors returned by
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfo.ValidateAll() if
// the designated constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoMultiError) AllErrors() []error {
	return m
}

// MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError is
// the validation error returned by
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfo.Validate if the
// designated constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError) ErrorName() string {
	return "MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyIn_MerchantApplyDataForAlipayZFT_ContactInfoValidationError{}

// Validate checks the field values on
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoMultiError, or nil if
// none found.
func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SiteType

	// no validation rules for SiteUrl

	// no validation rules for SiteName

	// no validation rules for Account

	// no validation rules for Password

	if len(errors) > 0 {
		return MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoMultiError(errors)
	}

	return nil
}

// MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoMultiError is an error
// wrapping multiple validation errors returned by
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfo.ValidateAll() if the
// designated constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoMultiError) AllErrors() []error {
	return m
}

// MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError is the
// validation error returned by
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfo.Validate if the
// designated constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError) ErrorName() string {
	return "MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyIn_MerchantApplyDataForAlipayZFT_SiteInfoValidationError{}

// Validate checks the field values on
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoMultiError, or nil
// if none found.
func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProvinceCode

	// no validation rules for CityCode

	// no validation rules for DistrictCode

	// no validation rules for Address

	if len(errors) > 0 {
		return MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoMultiError(errors)
	}

	return nil
}

// MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoMultiError is an
// error wrapping multiple validation errors returned by
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfo.ValidateAll() if
// the designated constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoMultiError) AllErrors() []error {
	return m
}

// MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError is
// the validation error returned by
// MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfo.Validate if the
// designated constraints aren't met.
type MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError) ErrorName() string {
	return "MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyIn_MerchantApplyDataForAlipayZFT_AddressInfoValidationError{}

// Validate checks the field values on MerchantApplyOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantApplyOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantApplyOut_DataMultiError, or nil if none found.
func (m *MerchantApplyOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RegApplyNo

	// no validation rules for MerchantNo

	// no validation rules for Result

	// no validation rules for Error

	if all {
		switch v := interface{}(m.GetPayResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantApplyOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantApplyOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantApplyOut_DataValidationError{
				field:  "PayResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MerchantApplyOut_DataMultiError(errors)
	}

	return nil
}

// MerchantApplyOut_DataMultiError is an error wrapping multiple validation
// errors returned by MerchantApplyOut_Data.ValidateAll() if the designated
// constraints aren't met.
type MerchantApplyOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyOut_DataMultiError) AllErrors() []error { return m }

// MerchantApplyOut_DataValidationError is the validation error returned by
// MerchantApplyOut_Data.Validate if the designated constraints aren't met.
type MerchantApplyOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantApplyOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantApplyOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantApplyOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantApplyOut_DataValidationError) ErrorName() string {
	return "MerchantApplyOut_DataValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantApplyOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyOut_DataValidationError{}

// Validate checks the field values on MerchantApplyQueryOut_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MerchantApplyQueryOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantApplyQueryOut_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantApplyQueryOut_DataMultiError, or nil if none found.
func (m *MerchantApplyQueryOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantApplyQueryOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RegApplyNo

	// no validation rules for MerchantNo

	// no validation rules for ApplyStatus

	if all {
		switch v := interface{}(m.GetPayResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MerchantApplyQueryOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MerchantApplyQueryOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MerchantApplyQueryOut_DataValidationError{
				field:  "PayResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MerchantApplyQueryOut_DataMultiError(errors)
	}

	return nil
}

// MerchantApplyQueryOut_DataMultiError is an error wrapping multiple
// validation errors returned by MerchantApplyQueryOut_Data.ValidateAll() if
// the designated constraints aren't met.
type MerchantApplyQueryOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantApplyQueryOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantApplyQueryOut_DataMultiError) AllErrors() []error { return m }

// MerchantApplyQueryOut_DataValidationError is the validation error returned
// by MerchantApplyQueryOut_Data.Validate if the designated constraints aren't met.
type MerchantApplyQueryOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantApplyQueryOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantApplyQueryOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantApplyQueryOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantApplyQueryOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantApplyQueryOut_DataValidationError) ErrorName() string {
	return "MerchantApplyQueryOut_DataValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantApplyQueryOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantApplyQueryOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantApplyQueryOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantApplyQueryOut_DataValidationError{}

// Validate checks the field values on NotifyIn_AlipayMerchantApplyNotifyMsg
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *NotifyIn_AlipayMerchantApplyNotifyMsg) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotifyIn_AlipayMerchantApplyNotifyMsg
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// NotifyIn_AlipayMerchantApplyNotifyMsgMultiError, or nil if none found.
func (m *NotifyIn_AlipayMerchantApplyNotifyMsg) ValidateAll() error {
	return m.validate(true)
}

func (m *NotifyIn_AlipayMerchantApplyNotifyMsg) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Charset

	// no validation rules for SignType

	// no validation rules for Sign

	// no validation rules for Version

	// no validation rules for BizContent

	// no validation rules for NotifyId

	// no validation rules for UtcTimestamp

	// no validation rules for MsgMethod

	// no validation rules for MsgType

	// no validation rules for MsgUid

	// no validation rules for MsgAppId

	// no validation rules for EncryptType

	// no validation rules for NotifyType

	// no validation rules for NotifyTime

	// no validation rules for AuthAppId

	if len(errors) > 0 {
		return NotifyIn_AlipayMerchantApplyNotifyMsgMultiError(errors)
	}

	return nil
}

// NotifyIn_AlipayMerchantApplyNotifyMsgMultiError is an error wrapping
// multiple validation errors returned by
// NotifyIn_AlipayMerchantApplyNotifyMsg.ValidateAll() if the designated
// constraints aren't met.
type NotifyIn_AlipayMerchantApplyNotifyMsgMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifyIn_AlipayMerchantApplyNotifyMsgMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifyIn_AlipayMerchantApplyNotifyMsgMultiError) AllErrors() []error { return m }

// NotifyIn_AlipayMerchantApplyNotifyMsgValidationError is the validation error
// returned by NotifyIn_AlipayMerchantApplyNotifyMsg.Validate if the
// designated constraints aren't met.
type NotifyIn_AlipayMerchantApplyNotifyMsgValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifyIn_AlipayMerchantApplyNotifyMsgValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifyIn_AlipayMerchantApplyNotifyMsgValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifyIn_AlipayMerchantApplyNotifyMsgValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifyIn_AlipayMerchantApplyNotifyMsgValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifyIn_AlipayMerchantApplyNotifyMsgValidationError) ErrorName() string {
	return "NotifyIn_AlipayMerchantApplyNotifyMsgValidationError"
}

// Error satisfies the builtin error interface
func (e NotifyIn_AlipayMerchantApplyNotifyMsgValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifyIn_AlipayMerchantApplyNotifyMsg.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifyIn_AlipayMerchantApplyNotifyMsgValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifyIn_AlipayMerchantApplyNotifyMsgValidationError{}

// Validate checks the field values on NotifyIn_AlipayPayNotifyMsg with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NotifyIn_AlipayPayNotifyMsg) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotifyIn_AlipayPayNotifyMsg with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NotifyIn_AlipayPayNotifyMsgMultiError, or nil if none found.
func (m *NotifyIn_AlipayPayNotifyMsg) ValidateAll() error {
	return m.validate(true)
}

func (m *NotifyIn_AlipayPayNotifyMsg) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Charset

	// no validation rules for SignType

	// no validation rules for Sign

	// no validation rules for Version

	// no validation rules for NotifyTime

	// no validation rules for NotifyType

	// no validation rules for NotifyId

	// no validation rules for TradeNo

	// no validation rules for OutTradeNo

	// no validation rules for OutBizNo

	// no validation rules for BuyerId

	// no validation rules for BuyerLogonId

	// no validation rules for SellerId

	// no validation rules for SellerEmail

	// no validation rules for TradeStatus

	// no validation rules for TotalAmount

	// no validation rules for ReceiptAmount

	// no validation rules for InvoiceAmount

	// no validation rules for BuyerPayAmount

	// no validation rules for PointAmount

	// no validation rules for RefundFee

	// no validation rules for Subject

	// no validation rules for Body

	// no validation rules for GmtCreate

	// no validation rules for GmtPayment

	// no validation rules for GmtRefund

	// no validation rules for GmtClose

	// no validation rules for FundBillList

	// no validation rules for PassbackParams

	// no validation rules for VoucherDetailList

	// no validation rules for AuthAppId

	if len(errors) > 0 {
		return NotifyIn_AlipayPayNotifyMsgMultiError(errors)
	}

	return nil
}

// NotifyIn_AlipayPayNotifyMsgMultiError is an error wrapping multiple
// validation errors returned by NotifyIn_AlipayPayNotifyMsg.ValidateAll() if
// the designated constraints aren't met.
type NotifyIn_AlipayPayNotifyMsgMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifyIn_AlipayPayNotifyMsgMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifyIn_AlipayPayNotifyMsgMultiError) AllErrors() []error { return m }

// NotifyIn_AlipayPayNotifyMsgValidationError is the validation error returned
// by NotifyIn_AlipayPayNotifyMsg.Validate if the designated constraints
// aren't met.
type NotifyIn_AlipayPayNotifyMsgValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifyIn_AlipayPayNotifyMsgValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifyIn_AlipayPayNotifyMsgValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifyIn_AlipayPayNotifyMsgValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifyIn_AlipayPayNotifyMsgValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifyIn_AlipayPayNotifyMsgValidationError) ErrorName() string {
	return "NotifyIn_AlipayPayNotifyMsgValidationError"
}

// Error satisfies the builtin error interface
func (e NotifyIn_AlipayPayNotifyMsgValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifyIn_AlipayPayNotifyMsg.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifyIn_AlipayPayNotifyMsgValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifyIn_AlipayPayNotifyMsgValidationError{}

// Validate checks the field values on NotifyIn_WxpayMerchantApplyNotifyMsg
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *NotifyIn_WxpayMerchantApplyNotifyMsg) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotifyIn_WxpayMerchantApplyNotifyMsg
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// NotifyIn_WxpayMerchantApplyNotifyMsgMultiError, or nil if none found.
func (m *NotifyIn_WxpayMerchantApplyNotifyMsg) ValidateAll() error {
	return m.validate(true)
}

func (m *NotifyIn_WxpayMerchantApplyNotifyMsg) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return NotifyIn_WxpayMerchantApplyNotifyMsgMultiError(errors)
	}

	return nil
}

// NotifyIn_WxpayMerchantApplyNotifyMsgMultiError is an error wrapping multiple
// validation errors returned by
// NotifyIn_WxpayMerchantApplyNotifyMsg.ValidateAll() if the designated
// constraints aren't met.
type NotifyIn_WxpayMerchantApplyNotifyMsgMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifyIn_WxpayMerchantApplyNotifyMsgMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifyIn_WxpayMerchantApplyNotifyMsgMultiError) AllErrors() []error { return m }

// NotifyIn_WxpayMerchantApplyNotifyMsgValidationError is the validation error
// returned by NotifyIn_WxpayMerchantApplyNotifyMsg.Validate if the designated
// constraints aren't met.
type NotifyIn_WxpayMerchantApplyNotifyMsgValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifyIn_WxpayMerchantApplyNotifyMsgValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifyIn_WxpayMerchantApplyNotifyMsgValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifyIn_WxpayMerchantApplyNotifyMsgValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifyIn_WxpayMerchantApplyNotifyMsgValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifyIn_WxpayMerchantApplyNotifyMsgValidationError) ErrorName() string {
	return "NotifyIn_WxpayMerchantApplyNotifyMsgValidationError"
}

// Error satisfies the builtin error interface
func (e NotifyIn_WxpayMerchantApplyNotifyMsgValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifyIn_WxpayMerchantApplyNotifyMsg.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifyIn_WxpayMerchantApplyNotifyMsgValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifyIn_WxpayMerchantApplyNotifyMsgValidationError{}

// Validate checks the field values on NotifyIn_WxpayPayNotifyMsg with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NotifyIn_WxpayPayNotifyMsg) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotifyIn_WxpayPayNotifyMsg with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NotifyIn_WxpayPayNotifyMsgMultiError, or nil if none found.
func (m *NotifyIn_WxpayPayNotifyMsg) ValidateAll() error {
	return m.validate(true)
}

func (m *NotifyIn_WxpayPayNotifyMsg) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return NotifyIn_WxpayPayNotifyMsgMultiError(errors)
	}

	return nil
}

// NotifyIn_WxpayPayNotifyMsgMultiError is an error wrapping multiple
// validation errors returned by NotifyIn_WxpayPayNotifyMsg.ValidateAll() if
// the designated constraints aren't met.
type NotifyIn_WxpayPayNotifyMsgMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifyIn_WxpayPayNotifyMsgMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifyIn_WxpayPayNotifyMsgMultiError) AllErrors() []error { return m }

// NotifyIn_WxpayPayNotifyMsgValidationError is the validation error returned
// by NotifyIn_WxpayPayNotifyMsg.Validate if the designated constraints aren't met.
type NotifyIn_WxpayPayNotifyMsgValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifyIn_WxpayPayNotifyMsgValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifyIn_WxpayPayNotifyMsgValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifyIn_WxpayPayNotifyMsgValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifyIn_WxpayPayNotifyMsgValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifyIn_WxpayPayNotifyMsgValidationError) ErrorName() string {
	return "NotifyIn_WxpayPayNotifyMsgValidationError"
}

// Error satisfies the builtin error interface
func (e NotifyIn_WxpayPayNotifyMsgValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifyIn_WxpayPayNotifyMsg.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifyIn_WxpayPayNotifyMsgValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifyIn_WxpayPayNotifyMsgValidationError{}

// Validate checks the field values on PayOut_Data with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PayOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PayOut_Data with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PayOut_DataMultiError, or
// nil if none found.
func (m *PayOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *PayOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MerchantNo

	// no validation rules for PayChannel

	// no validation rules for PayScene

	// no validation rules for OutTradeNo

	// no validation rules for TradeNo

	if all {
		switch v := interface{}(m.GetPayResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayOut_DataValidationError{
				field:  "PayResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Payload.(type) {
	case *PayOut_Data_H5Url:
		if v == nil {
			err := PayOut_DataValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for H5Url
	case *PayOut_Data_Sdk:
		if v == nil {
			err := PayOut_DataValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Sdk
	case *PayOut_Data_PcUrl:
		if v == nil {
			err := PayOut_DataValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for PcUrl
	case *PayOut_Data_WxpayParamsJsapi:
		if v == nil {
			err := PayOut_DataValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWxpayParamsJsapi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayOut_DataValidationError{
						field:  "WxpayParamsJsapi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayOut_DataValidationError{
						field:  "WxpayParamsJsapi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWxpayParamsJsapi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayOut_DataValidationError{
					field:  "WxpayParamsJsapi",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PayOut_Data_WxpayParamsApp:
		if v == nil {
			err := PayOut_DataValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWxpayParamsApp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayOut_DataValidationError{
						field:  "WxpayParamsApp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayOut_DataValidationError{
						field:  "WxpayParamsApp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWxpayParamsApp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayOut_DataValidationError{
					field:  "WxpayParamsApp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PayOut_Data_WxpayCodeUrl:
		if v == nil {
			err := PayOut_DataValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for WxpayCodeUrl
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PayOut_DataMultiError(errors)
	}

	return nil
}

// PayOut_DataMultiError is an error wrapping multiple validation errors
// returned by PayOut_Data.ValidateAll() if the designated constraints aren't met.
type PayOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayOut_DataMultiError) AllErrors() []error { return m }

// PayOut_DataValidationError is the validation error returned by
// PayOut_Data.Validate if the designated constraints aren't met.
type PayOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayOut_DataValidationError) ErrorName() string { return "PayOut_DataValidationError" }

// Error satisfies the builtin error interface
func (e PayOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayOut_DataValidationError{}

// Validate checks the field values on PayQueryOut_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PayQueryOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PayQueryOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PayQueryOut_DataMultiError, or nil if none found.
func (m *PayQueryOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *PayQueryOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeNo

	// no validation rules for OutTradeNo

	// no validation rules for PayChannel

	// no validation rules for PayScene

	// no validation rules for TotalAmount

	// no validation rules for Subject

	// no validation rules for Body

	// no validation rules for Extra

	// no validation rules for PayStatus

	if all {
		switch v := interface{}(m.GetPayResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayQueryOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayQueryOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayQueryOut_DataValidationError{
				field:  "PayResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PayQueryOut_DataMultiError(errors)
	}

	return nil
}

// PayQueryOut_DataMultiError is an error wrapping multiple validation errors
// returned by PayQueryOut_Data.ValidateAll() if the designated constraints
// aren't met.
type PayQueryOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayQueryOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayQueryOut_DataMultiError) AllErrors() []error { return m }

// PayQueryOut_DataValidationError is the validation error returned by
// PayQueryOut_Data.Validate if the designated constraints aren't met.
type PayQueryOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayQueryOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayQueryOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayQueryOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayQueryOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayQueryOut_DataValidationError) ErrorName() string { return "PayQueryOut_DataValidationError" }

// Error satisfies the builtin error interface
func (e PayQueryOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayQueryOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayQueryOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayQueryOut_DataValidationError{}

// Validate checks the field values on RefundOut_Data with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefundOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundOut_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefundOut_DataMultiError,
// or nil if none found.
func (m *RefundOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	// no validation rules for RequestNo

	if all {
		switch v := interface{}(m.GetPayResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefundOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefundOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefundOut_DataValidationError{
				field:  "PayResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RefundOut_DataMultiError(errors)
	}

	return nil
}

// RefundOut_DataMultiError is an error wrapping multiple validation errors
// returned by RefundOut_Data.ValidateAll() if the designated constraints
// aren't met.
type RefundOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundOut_DataMultiError) AllErrors() []error { return m }

// RefundOut_DataValidationError is the validation error returned by
// RefundOut_Data.Validate if the designated constraints aren't met.
type RefundOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundOut_DataValidationError) ErrorName() string { return "RefundOut_DataValidationError" }

// Error satisfies the builtin error interface
func (e RefundOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundOut_DataValidationError{}

// Validate checks the field values on RefundQueryOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefundQueryOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundQueryOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefundQueryOut_DataMultiError, or nil if none found.
func (m *RefundQueryOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundQueryOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeNo

	// no validation rules for OutTradeNo

	// no validation rules for RefundAmount

	// no validation rules for RefundReason

	// no validation rules for RefundStatus

	if all {
		switch v := interface{}(m.GetPayResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefundQueryOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefundQueryOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefundQueryOut_DataValidationError{
				field:  "PayResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RefundQueryOut_DataMultiError(errors)
	}

	return nil
}

// RefundQueryOut_DataMultiError is an error wrapping multiple validation
// errors returned by RefundQueryOut_Data.ValidateAll() if the designated
// constraints aren't met.
type RefundQueryOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundQueryOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundQueryOut_DataMultiError) AllErrors() []error { return m }

// RefundQueryOut_DataValidationError is the validation error returned by
// RefundQueryOut_Data.Validate if the designated constraints aren't met.
type RefundQueryOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundQueryOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundQueryOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundQueryOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundQueryOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundQueryOut_DataValidationError) ErrorName() string {
	return "RefundQueryOut_DataValidationError"
}

// Error satisfies the builtin error interface
func (e RefundQueryOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundQueryOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundQueryOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundQueryOut_DataValidationError{}

// Validate checks the field values on AmtSettleIn_ExtraParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AmtSettleIn_ExtraParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmtSettleIn_ExtraParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AmtSettleIn_ExtraParamsMultiError, or nil if none found.
func (m *AmtSettleIn_ExtraParams) ValidateAll() error {
	return m.validate(true)
}

func (m *AmtSettleIn_ExtraParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AmtFreeze

	if len(errors) > 0 {
		return AmtSettleIn_ExtraParamsMultiError(errors)
	}

	return nil
}

// AmtSettleIn_ExtraParamsMultiError is an error wrapping multiple validation
// errors returned by AmtSettleIn_ExtraParams.ValidateAll() if the designated
// constraints aren't met.
type AmtSettleIn_ExtraParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmtSettleIn_ExtraParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmtSettleIn_ExtraParamsMultiError) AllErrors() []error { return m }

// AmtSettleIn_ExtraParamsValidationError is the validation error returned by
// AmtSettleIn_ExtraParams.Validate if the designated constraints aren't met.
type AmtSettleIn_ExtraParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmtSettleIn_ExtraParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmtSettleIn_ExtraParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmtSettleIn_ExtraParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmtSettleIn_ExtraParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmtSettleIn_ExtraParamsValidationError) ErrorName() string {
	return "AmtSettleIn_ExtraParamsValidationError"
}

// Error satisfies the builtin error interface
func (e AmtSettleIn_ExtraParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmtSettleIn_ExtraParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmtSettleIn_ExtraParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmtSettleIn_ExtraParamsValidationError{}

// Validate checks the field values on AmtSettleOut_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AmtSettleOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmtSettleOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AmtSettleOut_DataMultiError, or nil if none found.
func (m *AmtSettleOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *AmtSettleOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PayChannel

	// no validation rules for TradeNo

	// no validation rules for OutTradeNo

	// no validation rules for RequestNo

	// no validation rules for SettleAmount

	// no validation rules for Result

	// no validation rules for Signal

	if all {
		switch v := interface{}(m.GetPayResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AmtSettleOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AmtSettleOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AmtSettleOut_DataValidationError{
				field:  "PayResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AmtSettleOut_DataMultiError(errors)
	}

	return nil
}

// AmtSettleOut_DataMultiError is an error wrapping multiple validation errors
// returned by AmtSettleOut_Data.ValidateAll() if the designated constraints
// aren't met.
type AmtSettleOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmtSettleOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmtSettleOut_DataMultiError) AllErrors() []error { return m }

// AmtSettleOut_DataValidationError is the validation error returned by
// AmtSettleOut_Data.Validate if the designated constraints aren't met.
type AmtSettleOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmtSettleOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmtSettleOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmtSettleOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmtSettleOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmtSettleOut_DataValidationError) ErrorName() string {
	return "AmtSettleOut_DataValidationError"
}

// Error satisfies the builtin error interface
func (e AmtSettleOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmtSettleOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmtSettleOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmtSettleOut_DataValidationError{}

// Validate checks the field values on OrderSettleIn_SettlementParams with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderSettleIn_SettlementParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderSettleIn_SettlementParams with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// OrderSettleIn_SettlementParamsMultiError, or nil if none found.
func (m *OrderSettleIn_SettlementParams) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderSettleIn_SettlementParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderSettleIn_SettlementParamsValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderSettleIn_SettlementParamsValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderSettleIn_SettlementParamsValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OrderSettleIn_SettlementParamsMultiError(errors)
	}

	return nil
}

// OrderSettleIn_SettlementParamsMultiError is an error wrapping multiple
// validation errors returned by OrderSettleIn_SettlementParams.ValidateAll()
// if the designated constraints aren't met.
type OrderSettleIn_SettlementParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderSettleIn_SettlementParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderSettleIn_SettlementParamsMultiError) AllErrors() []error { return m }

// OrderSettleIn_SettlementParamsValidationError is the validation error
// returned by OrderSettleIn_SettlementParams.Validate if the designated
// constraints aren't met.
type OrderSettleIn_SettlementParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderSettleIn_SettlementParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderSettleIn_SettlementParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderSettleIn_SettlementParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderSettleIn_SettlementParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderSettleIn_SettlementParamsValidationError) ErrorName() string {
	return "OrderSettleIn_SettlementParamsValidationError"
}

// Error satisfies the builtin error interface
func (e OrderSettleIn_SettlementParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderSettleIn_SettlementParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderSettleIn_SettlementParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderSettleIn_SettlementParamsValidationError{}

// Validate checks the field values on OrderSettleOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderSettleOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderSettleOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderSettleOut_DataMultiError, or nil if none found.
func (m *OrderSettleOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderSettleOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PayChannel

	// no validation rules for MerchantNo

	// no validation rules for TradeNo

	// no validation rules for OutTradeNo

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetPayRespForAmt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderSettleOut_DataValidationError{
					field:  "PayRespForAmt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderSettleOut_DataValidationError{
					field:  "PayRespForAmt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayRespForAmt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderSettleOut_DataValidationError{
				field:  "PayRespForAmt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayRespForBind()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderSettleOut_DataValidationError{
					field:  "PayRespForBind",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderSettleOut_DataValidationError{
					field:  "PayRespForBind",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayRespForBind()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderSettleOut_DataValidationError{
				field:  "PayRespForBind",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayRespForSettle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderSettleOut_DataValidationError{
					field:  "PayRespForSettle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderSettleOut_DataValidationError{
					field:  "PayRespForSettle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayRespForSettle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderSettleOut_DataValidationError{
				field:  "PayRespForSettle",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayRespForUnbind()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderSettleOut_DataValidationError{
					field:  "PayRespForUnbind",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderSettleOut_DataValidationError{
					field:  "PayRespForUnbind",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayRespForUnbind()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderSettleOut_DataValidationError{
				field:  "PayRespForUnbind",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrderSettleOut_DataMultiError(errors)
	}

	return nil
}

// OrderSettleOut_DataMultiError is an error wrapping multiple validation
// errors returned by OrderSettleOut_Data.ValidateAll() if the designated
// constraints aren't met.
type OrderSettleOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderSettleOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderSettleOut_DataMultiError) AllErrors() []error { return m }

// OrderSettleOut_DataValidationError is the validation error returned by
// OrderSettleOut_Data.Validate if the designated constraints aren't met.
type OrderSettleOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderSettleOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderSettleOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderSettleOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderSettleOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderSettleOut_DataValidationError) ErrorName() string {
	return "OrderSettleOut_DataValidationError"
}

// Error satisfies the builtin error interface
func (e OrderSettleOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderSettleOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderSettleOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderSettleOut_DataValidationError{}

// Validate checks the field values on OrderSettleQueryOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderSettleQueryOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderSettleQueryOut_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderSettleQueryOut_DataMultiError, or nil if none found.
func (m *OrderSettleQueryOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderSettleQueryOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeNo

	// no validation rules for OutTradeNo

	// no validation rules for PayChannel

	// no validation rules for SettleStatus

	if all {
		switch v := interface{}(m.GetPayResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderSettleQueryOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderSettleQueryOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderSettleQueryOut_DataValidationError{
				field:  "PayResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrderSettleQueryOut_DataMultiError(errors)
	}

	return nil
}

// OrderSettleQueryOut_DataMultiError is an error wrapping multiple validation
// errors returned by OrderSettleQueryOut_Data.ValidateAll() if the designated
// constraints aren't met.
type OrderSettleQueryOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderSettleQueryOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderSettleQueryOut_DataMultiError) AllErrors() []error { return m }

// OrderSettleQueryOut_DataValidationError is the validation error returned by
// OrderSettleQueryOut_Data.Validate if the designated constraints aren't met.
type OrderSettleQueryOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderSettleQueryOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderSettleQueryOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderSettleQueryOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderSettleQueryOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderSettleQueryOut_DataValidationError) ErrorName() string {
	return "OrderSettleQueryOut_DataValidationError"
}

// Error satisfies the builtin error interface
func (e OrderSettleQueryOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderSettleQueryOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderSettleQueryOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderSettleQueryOut_DataValidationError{}

// Validate checks the field values on BillQueryOut_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BillQueryOut_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillQueryOut_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillQueryOut_DataMultiError, or nil if none found.
func (m *BillQueryOut_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *BillQueryOut_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if all {
		switch v := interface{}(m.GetPayResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillQueryOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillQueryOut_DataValidationError{
					field:  "PayResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillQueryOut_DataValidationError{
				field:  "PayResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BillQueryOut_DataMultiError(errors)
	}

	return nil
}

// BillQueryOut_DataMultiError is an error wrapping multiple validation errors
// returned by BillQueryOut_Data.ValidateAll() if the designated constraints
// aren't met.
type BillQueryOut_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillQueryOut_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillQueryOut_DataMultiError) AllErrors() []error { return m }

// BillQueryOut_DataValidationError is the validation error returned by
// BillQueryOut_Data.Validate if the designated constraints aren't met.
type BillQueryOut_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillQueryOut_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillQueryOut_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillQueryOut_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillQueryOut_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillQueryOut_DataValidationError) ErrorName() string {
	return "BillQueryOut_DataValidationError"
}

// Error satisfies the builtin error interface
func (e BillQueryOut_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillQueryOut_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillQueryOut_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillQueryOut_DataValidationError{}
