// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pb/dassetpb/dasset.proto

package dassetpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on EmptyReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmptyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmptyReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmptyReqMultiError, or nil
// if none found.
func (m *EmptyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EmptyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetR()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmptyReqValidationError{
					field:  "R",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmptyReqValidationError{
					field:  "R",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetR()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmptyReqValidationError{
				field:  "R",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EmptyReqMultiError(errors)
	}

	return nil
}

// EmptyReqMultiError is an error wrapping multiple validation errors returned
// by EmptyReq.ValidateAll() if the designated constraints aren't met.
type EmptyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyReqMultiError) AllErrors() []error { return m }

// EmptyReqValidationError is the validation error returned by
// EmptyReq.Validate if the designated constraints aren't met.
type EmptyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyReqValidationError) ErrorName() string { return "EmptyReqValidationError" }

// Error satisfies the builtin error interface
func (e EmptyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmptyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyReqValidationError{}

// Validate checks the field values on ClaimProofReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClaimProofReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimProofReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClaimProofReqMultiError, or
// nil if none found.
func (m *ClaimProofReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimProofReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClaim()) < 1 {
		err := ClaimProofReqValidationError{
			field:  "Claim",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CredentialType

	if len(errors) > 0 {
		return ClaimProofReqMultiError(errors)
	}

	return nil
}

// ClaimProofReqMultiError is an error wrapping multiple validation errors
// returned by ClaimProofReq.ValidateAll() if the designated constraints
// aren't met.
type ClaimProofReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimProofReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimProofReqMultiError) AllErrors() []error { return m }

// ClaimProofReqValidationError is the validation error returned by
// ClaimProofReq.Validate if the designated constraints aren't met.
type ClaimProofReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimProofReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimProofReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimProofReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimProofReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimProofReqValidationError) ErrorName() string { return "ClaimProofReqValidationError" }

// Error satisfies the builtin error interface
func (e ClaimProofReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimProofReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimProofReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimProofReqValidationError{}

// Validate checks the field values on ClaimProofResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClaimProofResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimProofResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClaimProofRespMultiError,
// or nil if none found.
func (m *ClaimProofResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimProofResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClaimProofRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClaimProofRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClaimProofRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClaimProofRespMultiError(errors)
	}

	return nil
}

// ClaimProofRespMultiError is an error wrapping multiple validation errors
// returned by ClaimProofResp.ValidateAll() if the designated constraints
// aren't met.
type ClaimProofRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimProofRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimProofRespMultiError) AllErrors() []error { return m }

// ClaimProofRespValidationError is the validation error returned by
// ClaimProofResp.Validate if the designated constraints aren't met.
type ClaimProofRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimProofRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimProofRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimProofRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimProofRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimProofRespValidationError) ErrorName() string { return "ClaimProofRespValidationError" }

// Error satisfies the builtin error interface
func (e ClaimProofRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimProofResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimProofRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimProofRespValidationError{}

// Validate checks the field values on CopyrightClaimCheckReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimCheckReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimCheckReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimCheckReqMultiError, or nil if none found.
func (m *CopyrightClaimCheckReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimCheckReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightClaimId

	if _, ok := _CopyrightClaimCheckReq_AuditStatus_InLookup[m.GetAuditStatus()]; !ok {
		err := CopyrightClaimCheckReqValidationError{
			field:  "AuditStatus",
			reason: "value must be in list [1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RejectReason

	if len(errors) > 0 {
		return CopyrightClaimCheckReqMultiError(errors)
	}

	return nil
}

// CopyrightClaimCheckReqMultiError is an error wrapping multiple validation
// errors returned by CopyrightClaimCheckReq.ValidateAll() if the designated
// constraints aren't met.
type CopyrightClaimCheckReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimCheckReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimCheckReqMultiError) AllErrors() []error { return m }

// CopyrightClaimCheckReqValidationError is the validation error returned by
// CopyrightClaimCheckReq.Validate if the designated constraints aren't met.
type CopyrightClaimCheckReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimCheckReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimCheckReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimCheckReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimCheckReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimCheckReqValidationError) ErrorName() string {
	return "CopyrightClaimCheckReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimCheckReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimCheckReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimCheckReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimCheckReqValidationError{}

var _CopyrightClaimCheckReq_AuditStatus_InLookup = map[uint32]struct{}{
	1: {},
	2: {},
}

// Validate checks the field values on DidCredentialReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DidCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DidCredentialReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DidCredentialReqMultiError, or nil if none found.
func (m *DidCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DidCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DidCredentialReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DidCredentialReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DidCredentialReqValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DidCredentialReqMultiError(errors)
	}

	return nil
}

// DidCredentialReqMultiError is an error wrapping multiple validation errors
// returned by DidCredentialReq.ValidateAll() if the designated constraints
// aren't met.
type DidCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DidCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DidCredentialReqMultiError) AllErrors() []error { return m }

// DidCredentialReqValidationError is the validation error returned by
// DidCredentialReq.Validate if the designated constraints aren't met.
type DidCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DidCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DidCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DidCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DidCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DidCredentialReqValidationError) ErrorName() string { return "DidCredentialReqValidationError" }

// Error satisfies the builtin error interface
func (e DidCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDidCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DidCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DidCredentialReqValidationError{}

// Validate checks the field values on DidCredentialClaim with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DidCredentialClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DidCredentialClaim with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DidCredentialClaimMultiError, or nil if none found.
func (m *DidCredentialClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *DidCredentialClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDidType()) < 2 {
		err := DidCredentialClaimValidationError{
			field:  "DidType",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 2 {
		err := DidCredentialClaimValidationError{
			field:  "Name",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Profile

	// no validation rules for Address

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := DidCredentialClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return DidCredentialClaimMultiError(errors)
	}

	return nil
}

// DidCredentialClaimMultiError is an error wrapping multiple validation errors
// returned by DidCredentialClaim.ValidateAll() if the designated constraints
// aren't met.
type DidCredentialClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DidCredentialClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DidCredentialClaimMultiError) AllErrors() []error { return m }

// DidCredentialClaimValidationError is the validation error returned by
// DidCredentialClaim.Validate if the designated constraints aren't met.
type DidCredentialClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DidCredentialClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DidCredentialClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DidCredentialClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DidCredentialClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DidCredentialClaimValidationError) ErrorName() string {
	return "DidCredentialClaimValidationError"
}

// Error satisfies the builtin error interface
func (e DidCredentialClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDidCredentialClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DidCredentialClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DidCredentialClaimValidationError{}

// Validate checks the field values on DidCredentialResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DidCredentialResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DidCredentialResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DidCredentialRespMultiError, or nil if none found.
func (m *DidCredentialResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DidCredentialResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DidCredentialRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DidCredentialRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DidCredentialRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DidCredentialRespMultiError(errors)
	}

	return nil
}

// DidCredentialRespMultiError is an error wrapping multiple validation errors
// returned by DidCredentialResp.ValidateAll() if the designated constraints
// aren't met.
type DidCredentialRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DidCredentialRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DidCredentialRespMultiError) AllErrors() []error { return m }

// DidCredentialRespValidationError is the validation error returned by
// DidCredentialResp.Validate if the designated constraints aren't met.
type DidCredentialRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DidCredentialRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DidCredentialRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DidCredentialRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DidCredentialRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DidCredentialRespValidationError) ErrorName() string {
	return "DidCredentialRespValidationError"
}

// Error satisfies the builtin error interface
func (e DidCredentialRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDidCredentialResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DidCredentialRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DidCredentialRespValidationError{}

// Validate checks the field values on CredentialInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CredentialInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CredentialInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CredentialInfoReqMultiError, or nil if none found.
func (m *CredentialInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CredentialInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CredentialId

	if len(errors) > 0 {
		return CredentialInfoReqMultiError(errors)
	}

	return nil
}

// CredentialInfoReqMultiError is an error wrapping multiple validation errors
// returned by CredentialInfoReq.ValidateAll() if the designated constraints
// aren't met.
type CredentialInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CredentialInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CredentialInfoReqMultiError) AllErrors() []error { return m }

// CredentialInfoReqValidationError is the validation error returned by
// CredentialInfoReq.Validate if the designated constraints aren't met.
type CredentialInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CredentialInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CredentialInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CredentialInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CredentialInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CredentialInfoReqValidationError) ErrorName() string {
	return "CredentialInfoReqValidationError"
}

// Error satisfies the builtin error interface
func (e CredentialInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCredentialInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CredentialInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CredentialInfoReqValidationError{}

// Validate checks the field values on CredentialInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CredentialInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CredentialInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CredentialInfoRespMultiError, or nil if none found.
func (m *CredentialInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CredentialInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CredentialInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CredentialInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CredentialInfoRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CredentialInfoRespMultiError(errors)
	}

	return nil
}

// CredentialInfoRespMultiError is an error wrapping multiple validation errors
// returned by CredentialInfoResp.ValidateAll() if the designated constraints
// aren't met.
type CredentialInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CredentialInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CredentialInfoRespMultiError) AllErrors() []error { return m }

// CredentialInfoRespValidationError is the validation error returned by
// CredentialInfoResp.Validate if the designated constraints aren't met.
type CredentialInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CredentialInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CredentialInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CredentialInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CredentialInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CredentialInfoRespValidationError) ErrorName() string {
	return "CredentialInfoRespValidationError"
}

// Error satisfies the builtin error interface
func (e CredentialInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCredentialInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CredentialInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CredentialInfoRespValidationError{}

// Validate checks the field values on CredentialListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CredentialListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CredentialListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CredentialListReqMultiError, or nil if none found.
func (m *CredentialListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CredentialListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CredentialIds

	// no validation rules for CredentialType

	// no validation rules for Credential

	// no validation rules for HolderAddress

	// no validation rules for DidCredential

	// no validation rules for CopyrightCredential

	// no validation rules for AuthorizationCredential

	// no validation rules for CollectionCredential

	// no validation rules for Hash

	// no validation rules for ChainTxid

	// no validation rules for ChainBlockNumber

	// no validation rules for ChainTimeStart

	// no validation rules for ChainTimeEnd

	// no validation rules for ChainStatus

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return CredentialListReqMultiError(errors)
	}

	return nil
}

// CredentialListReqMultiError is an error wrapping multiple validation errors
// returned by CredentialListReq.ValidateAll() if the designated constraints
// aren't met.
type CredentialListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CredentialListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CredentialListReqMultiError) AllErrors() []error { return m }

// CredentialListReqValidationError is the validation error returned by
// CredentialListReq.Validate if the designated constraints aren't met.
type CredentialListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CredentialListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CredentialListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CredentialListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CredentialListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CredentialListReqValidationError) ErrorName() string {
	return "CredentialListReqValidationError"
}

// Error satisfies the builtin error interface
func (e CredentialListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCredentialListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CredentialListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CredentialListReqValidationError{}

// Validate checks the field values on CredentialListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CredentialListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CredentialListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CredentialListRespMultiError, or nil if none found.
func (m *CredentialListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CredentialListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CredentialListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CredentialListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CredentialListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CredentialListRespMultiError(errors)
	}

	return nil
}

// CredentialListRespMultiError is an error wrapping multiple validation errors
// returned by CredentialListResp.ValidateAll() if the designated constraints
// aren't met.
type CredentialListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CredentialListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CredentialListRespMultiError) AllErrors() []error { return m }

// CredentialListRespValidationError is the validation error returned by
// CredentialListResp.Validate if the designated constraints aren't met.
type CredentialListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CredentialListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CredentialListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CredentialListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CredentialListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CredentialListRespValidationError) ErrorName() string {
	return "CredentialListRespValidationError"
}

// Error satisfies the builtin error interface
func (e CredentialListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCredentialListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CredentialListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CredentialListRespValidationError{}

// Validate checks the field values on CredentialInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CredentialInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CredentialInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CredentialInfoMultiError,
// or nil if none found.
func (m *CredentialInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CredentialInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CredentialId

	// no validation rules for Credential

	// no validation rules for CredentialType

	// no validation rules for CreatorUid

	// no validation rules for CreatorUidName

	// no validation rules for HolderAddress

	// no validation rules for DidCredential

	// no validation rules for CopyrightCredential

	// no validation rules for AuthorizationCredential

	// no validation rules for CollectionCredential

	// no validation rules for Hash

	// no validation rules for ChainTxid

	// no validation rules for ChainBlockNumber

	// no validation rules for ChainStatus

	// no validation rules for ChainFailedReason

	// no validation rules for ChainTime

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return CredentialInfoMultiError(errors)
	}

	return nil
}

// CredentialInfoMultiError is an error wrapping multiple validation errors
// returned by CredentialInfo.ValidateAll() if the designated constraints
// aren't met.
type CredentialInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CredentialInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CredentialInfoMultiError) AllErrors() []error { return m }

// CredentialInfoValidationError is the validation error returned by
// CredentialInfo.Validate if the designated constraints aren't met.
type CredentialInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CredentialInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CredentialInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CredentialInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CredentialInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CredentialInfoValidationError) ErrorName() string { return "CredentialInfoValidationError" }

// Error satisfies the builtin error interface
func (e CredentialInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCredentialInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CredentialInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CredentialInfoValidationError{}

// Validate checks the field values on BaseResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BaseResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BaseResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BaseRespMultiError, or nil
// if none found.
func (m *BaseResp) ValidateAll() error {
	return m.validate(true)
}

func (m *BaseResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if len(errors) > 0 {
		return BaseRespMultiError(errors)
	}

	return nil
}

// BaseRespMultiError is an error wrapping multiple validation errors returned
// by BaseResp.ValidateAll() if the designated constraints aren't met.
type BaseRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BaseRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BaseRespMultiError) AllErrors() []error { return m }

// BaseRespValidationError is the validation error returned by
// BaseResp.Validate if the designated constraints aren't met.
type BaseRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BaseRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BaseRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BaseRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BaseRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BaseRespValidationError) ErrorName() string { return "BaseRespValidationError" }

// Error satisfies the builtin error interface
func (e BaseRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBaseResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BaseRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BaseRespValidationError{}

// Validate checks the field values on ClaimProofResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClaimProofResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimProofResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClaimProofResp_DataMultiError, or nil if none found.
func (m *ClaimProofResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimProofResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Proof

	if len(errors) > 0 {
		return ClaimProofResp_DataMultiError(errors)
	}

	return nil
}

// ClaimProofResp_DataMultiError is an error wrapping multiple validation
// errors returned by ClaimProofResp_Data.ValidateAll() if the designated
// constraints aren't met.
type ClaimProofResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimProofResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimProofResp_DataMultiError) AllErrors() []error { return m }

// ClaimProofResp_DataValidationError is the validation error returned by
// ClaimProofResp_Data.Validate if the designated constraints aren't met.
type ClaimProofResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimProofResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimProofResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimProofResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimProofResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimProofResp_DataValidationError) ErrorName() string {
	return "ClaimProofResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e ClaimProofResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimProofResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimProofResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimProofResp_DataValidationError{}

// Validate checks the field values on DidCredentialResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DidCredentialResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DidCredentialResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DidCredentialResp_DataMultiError, or nil if none found.
func (m *DidCredentialResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *DidCredentialResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CredentialId

	// no validation rules for Credential

	if len(errors) > 0 {
		return DidCredentialResp_DataMultiError(errors)
	}

	return nil
}

// DidCredentialResp_DataMultiError is an error wrapping multiple validation
// errors returned by DidCredentialResp_Data.ValidateAll() if the designated
// constraints aren't met.
type DidCredentialResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DidCredentialResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DidCredentialResp_DataMultiError) AllErrors() []error { return m }

// DidCredentialResp_DataValidationError is the validation error returned by
// DidCredentialResp_Data.Validate if the designated constraints aren't met.
type DidCredentialResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DidCredentialResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DidCredentialResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DidCredentialResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DidCredentialResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DidCredentialResp_DataValidationError) ErrorName() string {
	return "DidCredentialResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e DidCredentialResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDidCredentialResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DidCredentialResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DidCredentialResp_DataValidationError{}

// Validate checks the field values on CredentialListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CredentialListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CredentialListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CredentialListResp_DataMultiError, or nil if none found.
func (m *CredentialListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CredentialListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CredentialListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CredentialListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CredentialListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CredentialListResp_DataMultiError(errors)
	}

	return nil
}

// CredentialListResp_DataMultiError is an error wrapping multiple validation
// errors returned by CredentialListResp_Data.ValidateAll() if the designated
// constraints aren't met.
type CredentialListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CredentialListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CredentialListResp_DataMultiError) AllErrors() []error { return m }

// CredentialListResp_DataValidationError is the validation error returned by
// CredentialListResp_Data.Validate if the designated constraints aren't met.
type CredentialListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CredentialListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CredentialListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CredentialListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CredentialListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CredentialListResp_DataValidationError) ErrorName() string {
	return "CredentialListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CredentialListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCredentialListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CredentialListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CredentialListResp_DataValidationError{}
