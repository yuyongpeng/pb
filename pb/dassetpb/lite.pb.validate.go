// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pb/dassetpb/lite.proto

package dassetpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CombinationInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CombinationInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CombinationInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CombinationInfoMultiError, or nil if none found.
func (m *CombinationInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CombinationInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Price

	// no validation rules for TokenUrl

	// no validation rules for AuthorizationId

	// no validation rules for ToUid

	// no validation rules for CheckIn

	if len(errors) > 0 {
		return CombinationInfoMultiError(errors)
	}

	return nil
}

// CombinationInfoMultiError is an error wrapping multiple validation errors
// returned by CombinationInfo.ValidateAll() if the designated constraints
// aren't met.
type CombinationInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CombinationInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CombinationInfoMultiError) AllErrors() []error { return m }

// CombinationInfoValidationError is the validation error returned by
// CombinationInfo.Validate if the designated constraints aren't met.
type CombinationInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CombinationInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CombinationInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CombinationInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CombinationInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CombinationInfoValidationError) ErrorName() string { return "CombinationInfoValidationError" }

// Error satisfies the builtin error interface
func (e CombinationInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCombinationInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CombinationInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CombinationInfoValidationError{}

// Validate checks the field values on CombinationReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CombinationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CombinationReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CombinationReqMultiError,
// or nil if none found.
func (m *CombinationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CombinationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CombinationReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CombinationReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CombinationReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if uri, err := url.Parse(m.GetNotifyUrl()); err != nil {
		err = CombinationReqValidationError{
			field:  "NotifyUrl",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := CombinationReqValidationError{
			field:  "NotifyUrl",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return CombinationReqMultiError(errors)
	}

	return nil
}

// CombinationReqMultiError is an error wrapping multiple validation errors
// returned by CombinationReq.ValidateAll() if the designated constraints
// aren't met.
type CombinationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CombinationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CombinationReqMultiError) AllErrors() []error { return m }

// CombinationReqValidationError is the validation error returned by
// CombinationReq.Validate if the designated constraints aren't met.
type CombinationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CombinationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CombinationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CombinationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CombinationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CombinationReqValidationError) ErrorName() string { return "CombinationReqValidationError" }

// Error satisfies the builtin error interface
func (e CombinationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCombinationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CombinationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CombinationReqValidationError{}

// Validate checks the field values on CombinationReqNew with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CombinationReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CombinationReqNew with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CombinationReqNewMultiError, or nil if none found.
func (m *CombinationReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *CombinationReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CombinationReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CombinationReqNewValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CombinationReqNewValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CombinationReqNewValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if uri, err := url.Parse(m.GetNotifyUrl()); err != nil {
		err = CombinationReqNewValidationError{
			field:  "NotifyUrl",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := CombinationReqNewValidationError{
			field:  "NotifyUrl",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return CombinationReqNewMultiError(errors)
	}

	return nil
}

// CombinationReqNewMultiError is an error wrapping multiple validation errors
// returned by CombinationReqNew.ValidateAll() if the designated constraints
// aren't met.
type CombinationReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CombinationReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CombinationReqNewMultiError) AllErrors() []error { return m }

// CombinationReqNewValidationError is the validation error returned by
// CombinationReqNew.Validate if the designated constraints aren't met.
type CombinationReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CombinationReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CombinationReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CombinationReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CombinationReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CombinationReqNewValidationError) ErrorName() string {
	return "CombinationReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e CombinationReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCombinationReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CombinationReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CombinationReqNewValidationError{}

// Validate checks the field values on CombinationResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CombinationResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CombinationResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CombinationRespMultiError, or nil if none found.
func (m *CombinationResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CombinationResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CombinationRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CombinationRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CombinationRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CombinationRespMultiError(errors)
	}

	return nil
}

// CombinationRespMultiError is an error wrapping multiple validation errors
// returned by CombinationResp.ValidateAll() if the designated constraints
// aren't met.
type CombinationRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CombinationRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CombinationRespMultiError) AllErrors() []error { return m }

// CombinationRespValidationError is the validation error returned by
// CombinationResp.Validate if the designated constraints aren't met.
type CombinationRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CombinationRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CombinationRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CombinationRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CombinationRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CombinationRespValidationError) ErrorName() string { return "CombinationRespValidationError" }

// Error satisfies the builtin error interface
func (e CombinationRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCombinationResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CombinationRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CombinationRespValidationError{}

// Validate checks the field values on LockReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LockReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LockReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LockReqMultiError, or nil if none found.
func (m *LockReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LockReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return LockReqMultiError(errors)
	}

	return nil
}

// LockReqMultiError is an error wrapping multiple validation errors returned
// by LockReq.ValidateAll() if the designated constraints aren't met.
type LockReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LockReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LockReqMultiError) AllErrors() []error { return m }

// LockReqValidationError is the validation error returned by LockReq.Validate
// if the designated constraints aren't met.
type LockReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LockReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LockReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LockReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LockReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LockReqValidationError) ErrorName() string { return "LockReqValidationError" }

// Error satisfies the builtin error interface
func (e LockReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLockReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LockReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LockReqValidationError{}

// Validate checks the field values on LockReqNew with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LockReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LockReqNew with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LockReqNewMultiError, or
// nil if none found.
func (m *LockReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *LockReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := LockReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CollectionId

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return LockReqNewMultiError(errors)
	}

	return nil
}

// LockReqNewMultiError is an error wrapping multiple validation errors
// returned by LockReqNew.ValidateAll() if the designated constraints aren't met.
type LockReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LockReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LockReqNewMultiError) AllErrors() []error { return m }

// LockReqNewValidationError is the validation error returned by
// LockReqNew.Validate if the designated constraints aren't met.
type LockReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LockReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LockReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LockReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LockReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LockReqNewValidationError) ErrorName() string { return "LockReqNewValidationError" }

// Error satisfies the builtin error interface
func (e LockReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLockReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LockReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LockReqNewValidationError{}

// Validate checks the field values on LockResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LockResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LockResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LockRespMultiError, or nil
// if none found.
func (m *LockResp) ValidateAll() error {
	return m.validate(true)
}

func (m *LockResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LockRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LockRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LockRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LockRespMultiError(errors)
	}

	return nil
}

// LockRespMultiError is an error wrapping multiple validation errors returned
// by LockResp.ValidateAll() if the designated constraints aren't met.
type LockRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LockRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LockRespMultiError) AllErrors() []error { return m }

// LockRespValidationError is the validation error returned by
// LockResp.Validate if the designated constraints aren't met.
type LockRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LockRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LockRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LockRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LockRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LockRespValidationError) ErrorName() string { return "LockRespValidationError" }

// Error satisfies the builtin error interface
func (e LockRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLockResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LockRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LockRespValidationError{}

// Validate checks the field values on UnlockReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UnlockReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnlockReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UnlockReqMultiError, or nil
// if none found.
func (m *UnlockReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UnlockReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return UnlockReqMultiError(errors)
	}

	return nil
}

// UnlockReqMultiError is an error wrapping multiple validation errors returned
// by UnlockReq.ValidateAll() if the designated constraints aren't met.
type UnlockReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnlockReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnlockReqMultiError) AllErrors() []error { return m }

// UnlockReqValidationError is the validation error returned by
// UnlockReq.Validate if the designated constraints aren't met.
type UnlockReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnlockReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnlockReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnlockReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnlockReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnlockReqValidationError) ErrorName() string { return "UnlockReqValidationError" }

// Error satisfies the builtin error interface
func (e UnlockReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnlockReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnlockReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnlockReqValidationError{}

// Validate checks the field values on UnlockReqNew with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UnlockReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnlockReqNew with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UnlockReqNewMultiError, or
// nil if none found.
func (m *UnlockReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *UnlockReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := UnlockReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CollectionId

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return UnlockReqNewMultiError(errors)
	}

	return nil
}

// UnlockReqNewMultiError is an error wrapping multiple validation errors
// returned by UnlockReqNew.ValidateAll() if the designated constraints aren't met.
type UnlockReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnlockReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnlockReqNewMultiError) AllErrors() []error { return m }

// UnlockReqNewValidationError is the validation error returned by
// UnlockReqNew.Validate if the designated constraints aren't met.
type UnlockReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnlockReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnlockReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnlockReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnlockReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnlockReqNewValidationError) ErrorName() string { return "UnlockReqNewValidationError" }

// Error satisfies the builtin error interface
func (e UnlockReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnlockReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnlockReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnlockReqNewValidationError{}

// Validate checks the field values on UnlockResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UnlockResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnlockResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UnlockRespMultiError, or
// nil if none found.
func (m *UnlockResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UnlockResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnlockRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnlockRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnlockRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnlockRespMultiError(errors)
	}

	return nil
}

// UnlockRespMultiError is an error wrapping multiple validation errors
// returned by UnlockResp.ValidateAll() if the designated constraints aren't met.
type UnlockRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnlockRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnlockRespMultiError) AllErrors() []error { return m }

// UnlockRespValidationError is the validation error returned by
// UnlockResp.Validate if the designated constraints aren't met.
type UnlockRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnlockRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnlockRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnlockRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnlockRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnlockRespValidationError) ErrorName() string { return "UnlockRespValidationError" }

// Error satisfies the builtin error interface
func (e UnlockRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnlockResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnlockRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnlockRespValidationError{}

// Validate checks the field values on CombinationResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CombinationResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CombinationResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CombinationResp_DataMultiError, or nil if none found.
func (m *CombinationResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CombinationResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	// no validation rules for TransactionId

	// no validation rules for TokenId

	if len(errors) > 0 {
		return CombinationResp_DataMultiError(errors)
	}

	return nil
}

// CombinationResp_DataMultiError is an error wrapping multiple validation
// errors returned by CombinationResp_Data.ValidateAll() if the designated
// constraints aren't met.
type CombinationResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CombinationResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CombinationResp_DataMultiError) AllErrors() []error { return m }

// CombinationResp_DataValidationError is the validation error returned by
// CombinationResp_Data.Validate if the designated constraints aren't met.
type CombinationResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CombinationResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CombinationResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CombinationResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CombinationResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CombinationResp_DataValidationError) ErrorName() string {
	return "CombinationResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CombinationResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCombinationResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CombinationResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CombinationResp_DataValidationError{}

// Validate checks the field values on LockResp_Data with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LockResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LockResp_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LockResp_DataMultiError, or
// nil if none found.
func (m *LockResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *LockResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	if len(errors) > 0 {
		return LockResp_DataMultiError(errors)
	}

	return nil
}

// LockResp_DataMultiError is an error wrapping multiple validation errors
// returned by LockResp_Data.ValidateAll() if the designated constraints
// aren't met.
type LockResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LockResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LockResp_DataMultiError) AllErrors() []error { return m }

// LockResp_DataValidationError is the validation error returned by
// LockResp_Data.Validate if the designated constraints aren't met.
type LockResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LockResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LockResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LockResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LockResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LockResp_DataValidationError) ErrorName() string { return "LockResp_DataValidationError" }

// Error satisfies the builtin error interface
func (e LockResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLockResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LockResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LockResp_DataValidationError{}

// Validate checks the field values on UnlockResp_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UnlockResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnlockResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnlockResp_DataMultiError, or nil if none found.
func (m *UnlockResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UnlockResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	if len(errors) > 0 {
		return UnlockResp_DataMultiError(errors)
	}

	return nil
}

// UnlockResp_DataMultiError is an error wrapping multiple validation errors
// returned by UnlockResp_Data.ValidateAll() if the designated constraints
// aren't met.
type UnlockResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnlockResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnlockResp_DataMultiError) AllErrors() []error { return m }

// UnlockResp_DataValidationError is the validation error returned by
// UnlockResp_Data.Validate if the designated constraints aren't met.
type UnlockResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnlockResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnlockResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnlockResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnlockResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnlockResp_DataValidationError) ErrorName() string { return "UnlockResp_DataValidationError" }

// Error satisfies the builtin error interface
func (e UnlockResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnlockResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnlockResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnlockResp_DataValidationError{}
