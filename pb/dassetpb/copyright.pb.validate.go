// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pb/dassetpb/copyright.proto

package dassetpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CopyrightRegisterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightRegisterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightRegisterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightRegisterReqMultiError, or nil if none found.
func (m *CopyrightRegisterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightRegisterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightType

	if utf8.RuneCountInString(m.GetCopyrightTitle()) < 1 {
		err := CopyrightRegisterReqValidationError{
			field:  "CopyrightTitle",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) < 1 {
		err := CopyrightRegisterReqValidationError{
			field:  "Creator",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAttachUrl()) < 1 {
		err := CopyrightRegisterReqValidationError{
			field:  "AttachUrl",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreativeTime

	// no validation rules for IsOriginal

	// no validation rules for Remarks

	if len(errors) > 0 {
		return CopyrightRegisterReqMultiError(errors)
	}

	return nil
}

// CopyrightRegisterReqMultiError is an error wrapping multiple validation
// errors returned by CopyrightRegisterReq.ValidateAll() if the designated
// constraints aren't met.
type CopyrightRegisterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightRegisterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightRegisterReqMultiError) AllErrors() []error { return m }

// CopyrightRegisterReqValidationError is the validation error returned by
// CopyrightRegisterReq.Validate if the designated constraints aren't met.
type CopyrightRegisterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightRegisterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightRegisterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightRegisterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightRegisterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightRegisterReqValidationError) ErrorName() string {
	return "CopyrightRegisterReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightRegisterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightRegisterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightRegisterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightRegisterReqValidationError{}

// Validate checks the field values on CopyrightRegisterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightRegisterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightRegisterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightRegisterRespMultiError, or nil if none found.
func (m *CopyrightRegisterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightRegisterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightRegisterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightRegisterRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightRegisterRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightRegisterRespMultiError(errors)
	}

	return nil
}

// CopyrightRegisterRespMultiError is an error wrapping multiple validation
// errors returned by CopyrightRegisterResp.ValidateAll() if the designated
// constraints aren't met.
type CopyrightRegisterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightRegisterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightRegisterRespMultiError) AllErrors() []error { return m }

// CopyrightRegisterRespValidationError is the validation error returned by
// CopyrightRegisterResp.Validate if the designated constraints aren't met.
type CopyrightRegisterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightRegisterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightRegisterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightRegisterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightRegisterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightRegisterRespValidationError) ErrorName() string {
	return "CopyrightRegisterRespValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightRegisterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightRegisterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightRegisterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightRegisterRespValidationError{}

// Validate checks the field values on CopyrightRegisterListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightRegisterListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightRegisterListReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightRegisterListReqMultiError, or nil if none found.
func (m *CopyrightRegisterListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightRegisterListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightTitle

	// no validation rules for CopyrightHash

	// no validation rules for CopyrightType

	// no validation rules for IsOriginal

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return CopyrightRegisterListReqMultiError(errors)
	}

	return nil
}

// CopyrightRegisterListReqMultiError is an error wrapping multiple validation
// errors returned by CopyrightRegisterListReq.ValidateAll() if the designated
// constraints aren't met.
type CopyrightRegisterListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightRegisterListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightRegisterListReqMultiError) AllErrors() []error { return m }

// CopyrightRegisterListReqValidationError is the validation error returned by
// CopyrightRegisterListReq.Validate if the designated constraints aren't met.
type CopyrightRegisterListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightRegisterListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightRegisterListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightRegisterListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightRegisterListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightRegisterListReqValidationError) ErrorName() string {
	return "CopyrightRegisterListReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightRegisterListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightRegisterListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightRegisterListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightRegisterListReqValidationError{}

// Validate checks the field values on CopyrightRegisterListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightRegisterListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightRegisterListResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightRegisterListRespMultiError, or nil if none found.
func (m *CopyrightRegisterListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightRegisterListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightRegisterListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightRegisterListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightRegisterListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightRegisterListRespMultiError(errors)
	}

	return nil
}

// CopyrightRegisterListRespMultiError is an error wrapping multiple validation
// errors returned by CopyrightRegisterListResp.ValidateAll() if the
// designated constraints aren't met.
type CopyrightRegisterListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightRegisterListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightRegisterListRespMultiError) AllErrors() []error { return m }

// CopyrightRegisterListRespValidationError is the validation error returned by
// CopyrightRegisterListResp.Validate if the designated constraints aren't met.
type CopyrightRegisterListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightRegisterListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightRegisterListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightRegisterListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightRegisterListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightRegisterListRespValidationError) ErrorName() string {
	return "CopyrightRegisterListRespValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightRegisterListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightRegisterListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightRegisterListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightRegisterListRespValidationError{}

// Validate checks the field values on CopyrightRegisterInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightRegisterInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightRegisterInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightRegisterInfoMultiError, or nil if none found.
func (m *CopyrightRegisterInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightRegisterInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightId

	// no validation rules for CopyrightTitle

	// no validation rules for CopyrightType

	// no validation rules for CopyrightHash

	// no validation rules for IsOriginal

	// no validation rules for Creator

	// no validation rules for CreativeTime

	// no validation rules for Remarks

	// no validation rules for AttachUrl

	// no validation rules for AppNo

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return CopyrightRegisterInfoMultiError(errors)
	}

	return nil
}

// CopyrightRegisterInfoMultiError is an error wrapping multiple validation
// errors returned by CopyrightRegisterInfo.ValidateAll() if the designated
// constraints aren't met.
type CopyrightRegisterInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightRegisterInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightRegisterInfoMultiError) AllErrors() []error { return m }

// CopyrightRegisterInfoValidationError is the validation error returned by
// CopyrightRegisterInfo.Validate if the designated constraints aren't met.
type CopyrightRegisterInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightRegisterInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightRegisterInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightRegisterInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightRegisterInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightRegisterInfoValidationError) ErrorName() string {
	return "CopyrightRegisterInfoValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightRegisterInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightRegisterInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightRegisterInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightRegisterInfoValidationError{}

// Validate checks the field values on CopyrightAuthorizationListReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightAuthorizationListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightAuthorizationListReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CopyrightAuthorizationListReqMultiError, or nil if none found.
func (m *CopyrightAuthorizationListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightAuthorizationListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Credential

	// no validation rules for AuthorizationIds

	// no validation rules for ContractIds

	// no validation rules for AuthorizerUserAddress

	// no validation rules for AuthorizedUserAddress

	// no validation rules for AuthorizationCode

	if val := m.GetAuthorizationType(); val < 0 || val > 2 {
		err := CopyrightAuthorizationListReqValidationError{
			field:  "AuthorizationType",
			reason: "value must be inside range [0, 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return CopyrightAuthorizationListReqMultiError(errors)
	}

	return nil
}

// CopyrightAuthorizationListReqMultiError is an error wrapping multiple
// validation errors returned by CopyrightAuthorizationListReq.ValidateAll()
// if the designated constraints aren't met.
type CopyrightAuthorizationListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightAuthorizationListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightAuthorizationListReqMultiError) AllErrors() []error { return m }

// CopyrightAuthorizationListReqValidationError is the validation error
// returned by CopyrightAuthorizationListReq.Validate if the designated
// constraints aren't met.
type CopyrightAuthorizationListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightAuthorizationListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightAuthorizationListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightAuthorizationListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightAuthorizationListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightAuthorizationListReqValidationError) ErrorName() string {
	return "CopyrightAuthorizationListReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightAuthorizationListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightAuthorizationListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightAuthorizationListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightAuthorizationListReqValidationError{}

// Validate checks the field values on CopyrightAuthorizationListResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightAuthorizationListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightAuthorizationListResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CopyrightAuthorizationListRespMultiError, or nil if none found.
func (m *CopyrightAuthorizationListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightAuthorizationListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightAuthorizationListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightAuthorizationListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightAuthorizationListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightAuthorizationListRespMultiError(errors)
	}

	return nil
}

// CopyrightAuthorizationListRespMultiError is an error wrapping multiple
// validation errors returned by CopyrightAuthorizationListResp.ValidateAll()
// if the designated constraints aren't met.
type CopyrightAuthorizationListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightAuthorizationListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightAuthorizationListRespMultiError) AllErrors() []error { return m }

// CopyrightAuthorizationListRespValidationError is the validation error
// returned by CopyrightAuthorizationListResp.Validate if the designated
// constraints aren't met.
type CopyrightAuthorizationListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightAuthorizationListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightAuthorizationListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightAuthorizationListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightAuthorizationListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightAuthorizationListRespValidationError) ErrorName() string {
	return "CopyrightAuthorizationListRespValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightAuthorizationListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightAuthorizationListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightAuthorizationListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightAuthorizationListRespValidationError{}

// Validate checks the field values on CopyrightAuthorizationInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightAuthorizationInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightAuthorizationInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightAuthorizationInfoMultiError, or nil if none found.
func (m *CopyrightAuthorizationInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightAuthorizationInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizationId

	// no validation rules for ContractId

	// no validation rules for AuthorizationCode

	// no validation rules for AuthorizerUid

	// no validation rules for AuthorizerUidName

	// no validation rules for AuthorizerUserAddress

	// no validation rules for AuthorizedUid

	// no validation rules for AuthorizedUidName

	// no validation rules for AuthorizedUserAddress

	// no validation rules for AppNo

	// no validation rules for AuthorizationCategory

	// no validation rules for AuthorizationNumber

	// no validation rules for AuthorizationContent

	// no validation rules for Credential

	for idx, item := range m.GetCopyrights() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CopyrightAuthorizationInfoValidationError{
						field:  fmt.Sprintf("Copyrights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CopyrightAuthorizationInfoValidationError{
						field:  fmt.Sprintf("Copyrights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CopyrightAuthorizationInfoValidationError{
					field:  fmt.Sprintf("Copyrights[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCopyrightClaims() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CopyrightAuthorizationInfoValidationError{
						field:  fmt.Sprintf("CopyrightClaims[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CopyrightAuthorizationInfoValidationError{
						field:  fmt.Sprintf("CopyrightClaims[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CopyrightAuthorizationInfoValidationError{
					field:  fmt.Sprintf("CopyrightClaims[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return CopyrightAuthorizationInfoMultiError(errors)
	}

	return nil
}

// CopyrightAuthorizationInfoMultiError is an error wrapping multiple
// validation errors returned by CopyrightAuthorizationInfo.ValidateAll() if
// the designated constraints aren't met.
type CopyrightAuthorizationInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightAuthorizationInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightAuthorizationInfoMultiError) AllErrors() []error { return m }

// CopyrightAuthorizationInfoValidationError is the validation error returned
// by CopyrightAuthorizationInfo.Validate if the designated constraints aren't met.
type CopyrightAuthorizationInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightAuthorizationInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightAuthorizationInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightAuthorizationInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightAuthorizationInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightAuthorizationInfoValidationError) ErrorName() string {
	return "CopyrightAuthorizationInfoValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightAuthorizationInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightAuthorizationInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightAuthorizationInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightAuthorizationInfoValidationError{}

// Validate checks the field values on AuthorizationClaimListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizationClaimListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizationClaimListReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizationClaimListReqMultiError, or nil if none found.
func (m *AuthorizationClaimListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizationClaimListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizationId

	// no validation rules for CopyrightTitle

	// no validation rules for CopyrightHash

	// no validation rules for CopyrightType

	// no validation rules for IsOriginal

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return AuthorizationClaimListReqMultiError(errors)
	}

	return nil
}

// AuthorizationClaimListReqMultiError is an error wrapping multiple validation
// errors returned by AuthorizationClaimListReq.ValidateAll() if the
// designated constraints aren't met.
type AuthorizationClaimListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationClaimListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationClaimListReqMultiError) AllErrors() []error { return m }

// AuthorizationClaimListReqValidationError is the validation error returned by
// AuthorizationClaimListReq.Validate if the designated constraints aren't met.
type AuthorizationClaimListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationClaimListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationClaimListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationClaimListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationClaimListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationClaimListReqValidationError) ErrorName() string {
	return "AuthorizationClaimListReqValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizationClaimListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizationClaimListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationClaimListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationClaimListReqValidationError{}

// Validate checks the field values on CopyrightClaimAddReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimAddReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimAddReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimAddReqMultiError, or nil if none found.
func (m *CopyrightClaimAddReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimAddReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightId

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimAddReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimAddReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimAddReqValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Remarks

	if len(errors) > 0 {
		return CopyrightClaimAddReqMultiError(errors)
	}

	return nil
}

// CopyrightClaimAddReqMultiError is an error wrapping multiple validation
// errors returned by CopyrightClaimAddReq.ValidateAll() if the designated
// constraints aren't met.
type CopyrightClaimAddReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimAddReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimAddReqMultiError) AllErrors() []error { return m }

// CopyrightClaimAddReqValidationError is the validation error returned by
// CopyrightClaimAddReq.Validate if the designated constraints aren't met.
type CopyrightClaimAddReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimAddReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimAddReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimAddReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimAddReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimAddReqValidationError) ErrorName() string {
	return "CopyrightClaimAddReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimAddReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimAddReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimAddReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimAddReqValidationError{}

// Validate checks the field values on CopyrightClaimEditReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimEditReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimEditReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimEditReqMultiError, or nil if none found.
func (m *CopyrightClaimEditReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimEditReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightClaimId

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimEditReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimEditReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimEditReqValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Remarks

	if len(errors) > 0 {
		return CopyrightClaimEditReqMultiError(errors)
	}

	return nil
}

// CopyrightClaimEditReqMultiError is an error wrapping multiple validation
// errors returned by CopyrightClaimEditReq.ValidateAll() if the designated
// constraints aren't met.
type CopyrightClaimEditReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimEditReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimEditReqMultiError) AllErrors() []error { return m }

// CopyrightClaimEditReqValidationError is the validation error returned by
// CopyrightClaimEditReq.Validate if the designated constraints aren't met.
type CopyrightClaimEditReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimEditReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimEditReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimEditReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimEditReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimEditReqValidationError) ErrorName() string {
	return "CopyrightClaimEditReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimEditReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimEditReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimEditReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimEditReqValidationError{}

// Validate checks the field values on CopyrightClaim with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaim with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CopyrightClaimMultiError,
// or nil if none found.
func (m *CopyrightClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDidCredential()) < 1 {
		err := CopyrightClaimValidationError{
			field:  "DidCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CopyrightHash

	if utf8.RuneCountInString(m.GetClaimTitle()) < 1 {
		err := CopyrightClaimValidationError{
			field:  "ClaimTitle",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) < 1 {
		err := CopyrightClaimValidationError{
			field:  "Creator",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreativeTime

	// no validation rules for IsOriginal

	if utf8.RuneCountInString(m.GetAttachUrl()) < 1 {
		err := CopyrightClaimValidationError{
			field:  "AttachUrl",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCopyrightCategory()) < 1 {
		err := CopyrightClaimValidationError{
			field:  "CopyrightCategory",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AuthorizedNumber

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := CopyrightClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return CopyrightClaimMultiError(errors)
	}

	return nil
}

// CopyrightClaimMultiError is an error wrapping multiple validation errors
// returned by CopyrightClaim.ValidateAll() if the designated constraints
// aren't met.
type CopyrightClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimMultiError) AllErrors() []error { return m }

// CopyrightClaimValidationError is the validation error returned by
// CopyrightClaim.Validate if the designated constraints aren't met.
type CopyrightClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimValidationError) ErrorName() string { return "CopyrightClaimValidationError" }

// Error satisfies the builtin error interface
func (e CopyrightClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimValidationError{}

// Validate checks the field values on CopyrightClaimRegister with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimRegister) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimRegister with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimRegisterMultiError, or nil if none found.
func (m *CopyrightClaimRegister) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimRegister) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClaimTitle()) < 1 {
		err := CopyrightClaimRegisterValidationError{
			field:  "ClaimTitle",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCopyrightCategory()) < 1 {
		err := CopyrightClaimRegisterValidationError{
			field:  "CopyrightCategory",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AuthorizedNumber

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := CopyrightClaimRegisterValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	// no validation rules for Remarks

	if len(errors) > 0 {
		return CopyrightClaimRegisterMultiError(errors)
	}

	return nil
}

// CopyrightClaimRegisterMultiError is an error wrapping multiple validation
// errors returned by CopyrightClaimRegister.ValidateAll() if the designated
// constraints aren't met.
type CopyrightClaimRegisterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimRegisterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimRegisterMultiError) AllErrors() []error { return m }

// CopyrightClaimRegisterValidationError is the validation error returned by
// CopyrightClaimRegister.Validate if the designated constraints aren't met.
type CopyrightClaimRegisterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimRegisterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimRegisterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimRegisterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimRegisterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimRegisterValidationError) ErrorName() string {
	return "CopyrightClaimRegisterValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimRegisterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimRegister.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimRegisterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimRegisterValidationError{}

// Validate checks the field values on CopyrightContractRegister with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightContractRegister) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightContractRegister with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightContractRegisterMultiError, or nil if none found.
func (m *CopyrightContractRegister) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightContractRegister) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizedNumber

	if utf8.RuneCountInString(m.GetCopyrightCategory()) < 1 {
		err := CopyrightContractRegisterValidationError{
			field:  "CopyrightCategory",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetContent()) < 1 {
		err := CopyrightContractRegisterValidationError{
			field:  "Content",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CopyrightContractRegisterMultiError(errors)
	}

	return nil
}

// CopyrightContractRegisterMultiError is an error wrapping multiple validation
// errors returned by CopyrightContractRegister.ValidateAll() if the
// designated constraints aren't met.
type CopyrightContractRegisterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightContractRegisterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightContractRegisterMultiError) AllErrors() []error { return m }

// CopyrightContractRegisterValidationError is the validation error returned by
// CopyrightContractRegister.Validate if the designated constraints aren't met.
type CopyrightContractRegisterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightContractRegisterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightContractRegisterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightContractRegisterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightContractRegisterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightContractRegisterValidationError) ErrorName() string {
	return "CopyrightContractRegisterValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightContractRegisterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightContractRegister.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightContractRegisterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightContractRegisterValidationError{}

// Validate checks the field values on CopyrightContractAuthorizationRegister
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CopyrightContractAuthorizationRegister) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CopyrightContractAuthorizationRegister with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// CopyrightContractAuthorizationRegisterMultiError, or nil if none found.
func (m *CopyrightContractAuthorizationRegister) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightContractAuthorizationRegister) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAuthorizedAddress()) < 1 {
		err := CopyrightContractAuthorizationRegisterValidationError{
			field:  "AuthorizedAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizationContent()) < 1 {
		err := CopyrightContractAuthorizationRegisterValidationError{
			field:  "AuthorizationContent",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Remarks

	if utf8.RuneCountInString(m.GetAuthorizationCategory()) < 1 {
		err := CopyrightContractAuthorizationRegisterValidationError{
			field:  "AuthorizationCategory",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AuthorizedNumber

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := CopyrightContractAuthorizationRegisterValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return CopyrightContractAuthorizationRegisterMultiError(errors)
	}

	return nil
}

// CopyrightContractAuthorizationRegisterMultiError is an error wrapping
// multiple validation errors returned by
// CopyrightContractAuthorizationRegister.ValidateAll() if the designated
// constraints aren't met.
type CopyrightContractAuthorizationRegisterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightContractAuthorizationRegisterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightContractAuthorizationRegisterMultiError) AllErrors() []error { return m }

// CopyrightContractAuthorizationRegisterValidationError is the validation
// error returned by CopyrightContractAuthorizationRegister.Validate if the
// designated constraints aren't met.
type CopyrightContractAuthorizationRegisterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightContractAuthorizationRegisterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightContractAuthorizationRegisterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightContractAuthorizationRegisterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightContractAuthorizationRegisterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightContractAuthorizationRegisterValidationError) ErrorName() string {
	return "CopyrightContractAuthorizationRegisterValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightContractAuthorizationRegisterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightContractAuthorizationRegister.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightContractAuthorizationRegisterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightContractAuthorizationRegisterValidationError{}

// Validate checks the field values on CopyrightClaimAuthorizationReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimAuthorizationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimAuthorizationReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CopyrightClaimAuthorizationReqMultiError, or nil if none found.
func (m *CopyrightClaimAuthorizationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimAuthorizationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightType

	if utf8.RuneCountInString(m.GetCopyrightTitle()) < 1 {
		err := CopyrightClaimAuthorizationReqValidationError{
			field:  "CopyrightTitle",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) < 1 {
		err := CopyrightClaimAuthorizationReqValidationError{
			field:  "Creator",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AttachUrl

	// no validation rules for CreativeTime

	// no validation rules for IsOriginal

	// no validation rules for Remarks

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if all {
		switch v := interface{}(m.GetCopyrightClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqValidationError{
					field:  "CopyrightClaim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqValidationError{
					field:  "CopyrightClaim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopyrightClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimAuthorizationReqValidationError{
				field:  "CopyrightClaim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCopyrightContract()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqValidationError{
					field:  "CopyrightContract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqValidationError{
					field:  "CopyrightContract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopyrightContract()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimAuthorizationReqValidationError{
				field:  "CopyrightContract",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCopyrightContractAuthorization()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqValidationError{
					field:  "CopyrightContractAuthorization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqValidationError{
					field:  "CopyrightContractAuthorization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopyrightContractAuthorization()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimAuthorizationReqValidationError{
				field:  "CopyrightContractAuthorization",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightClaimAuthorizationReqMultiError(errors)
	}

	return nil
}

// CopyrightClaimAuthorizationReqMultiError is an error wrapping multiple
// validation errors returned by CopyrightClaimAuthorizationReq.ValidateAll()
// if the designated constraints aren't met.
type CopyrightClaimAuthorizationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimAuthorizationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimAuthorizationReqMultiError) AllErrors() []error { return m }

// CopyrightClaimAuthorizationReqValidationError is the validation error
// returned by CopyrightClaimAuthorizationReq.Validate if the designated
// constraints aren't met.
type CopyrightClaimAuthorizationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimAuthorizationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimAuthorizationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimAuthorizationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimAuthorizationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimAuthorizationReqValidationError) ErrorName() string {
	return "CopyrightClaimAuthorizationReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimAuthorizationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimAuthorizationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimAuthorizationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimAuthorizationReqValidationError{}

// Validate checks the field values on CopyrightClaimAuthorizationResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimAuthorizationResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimAuthorizationResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CopyrightClaimAuthorizationRespMultiError, or nil if none found.
func (m *CopyrightClaimAuthorizationResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimAuthorizationResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimAuthorizationRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightClaimAuthorizationRespMultiError(errors)
	}

	return nil
}

// CopyrightClaimAuthorizationRespMultiError is an error wrapping multiple
// validation errors returned by CopyrightClaimAuthorizationResp.ValidateAll()
// if the designated constraints aren't met.
type CopyrightClaimAuthorizationRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimAuthorizationRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimAuthorizationRespMultiError) AllErrors() []error { return m }

// CopyrightClaimAuthorizationRespValidationError is the validation error
// returned by CopyrightClaimAuthorizationResp.Validate if the designated
// constraints aren't met.
type CopyrightClaimAuthorizationRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimAuthorizationRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimAuthorizationRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimAuthorizationRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimAuthorizationRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimAuthorizationRespValidationError) ErrorName() string {
	return "CopyrightClaimAuthorizationRespValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimAuthorizationRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimAuthorizationResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimAuthorizationRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimAuthorizationRespValidationError{}

// Validate checks the field values on CopyrightMintReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CopyrightMintReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightMintReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightMintReqMultiError, or nil if none found.
func (m *CopyrightMintReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightMintReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightType

	if utf8.RuneCountInString(m.GetCopyrightTitle()) < 2 {
		err := CopyrightMintReqValidationError{
			field:  "CopyrightTitle",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) < 1 {
		err := CopyrightMintReqValidationError{
			field:  "Creator",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AttachUrl

	// no validation rules for CreativeTime

	// no validation rules for IsOriginal

	// no validation rules for Remarks

	if all {
		switch v := interface{}(m.GetCopyrightClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightMintReqValidationError{
					field:  "CopyrightClaim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightMintReqValidationError{
					field:  "CopyrightClaim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopyrightClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightMintReqValidationError{
				field:  "CopyrightClaim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCopyrightContract()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightMintReqValidationError{
					field:  "CopyrightContract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightMintReqValidationError{
					field:  "CopyrightContract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopyrightContract()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightMintReqValidationError{
				field:  "CopyrightContract",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCopyrightContractAuthorization()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightMintReqValidationError{
					field:  "CopyrightContractAuthorization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightMintReqValidationError{
					field:  "CopyrightContractAuthorization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopyrightContractAuthorization()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightMintReqValidationError{
				field:  "CopyrightContractAuthorization",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightMintReqMultiError(errors)
	}

	return nil
}

// CopyrightMintReqMultiError is an error wrapping multiple validation errors
// returned by CopyrightMintReq.ValidateAll() if the designated constraints
// aren't met.
type CopyrightMintReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightMintReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightMintReqMultiError) AllErrors() []error { return m }

// CopyrightMintReqValidationError is the validation error returned by
// CopyrightMintReq.Validate if the designated constraints aren't met.
type CopyrightMintReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightMintReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightMintReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightMintReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightMintReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightMintReqValidationError) ErrorName() string { return "CopyrightMintReqValidationError" }

// Error satisfies the builtin error interface
func (e CopyrightMintReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightMintReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightMintReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightMintReqValidationError{}

// Validate checks the field values on CopyrightMintResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CopyrightMintResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightMintResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightMintRespMultiError, or nil if none found.
func (m *CopyrightMintResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightMintResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightMintRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightMintRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightMintRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightMintRespMultiError(errors)
	}

	return nil
}

// CopyrightMintRespMultiError is an error wrapping multiple validation errors
// returned by CopyrightMintResp.ValidateAll() if the designated constraints
// aren't met.
type CopyrightMintRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightMintRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightMintRespMultiError) AllErrors() []error { return m }

// CopyrightMintRespValidationError is the validation error returned by
// CopyrightMintResp.Validate if the designated constraints aren't met.
type CopyrightMintRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightMintRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightMintRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightMintRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightMintRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightMintRespValidationError) ErrorName() string {
	return "CopyrightMintRespValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightMintRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightMintResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightMintRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightMintRespValidationError{}

// Validate checks the field values on ContractCreateReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ContractCreateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractCreateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractCreateReqMultiError, or nil if none found.
func (m *ContractCreateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractCreateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCopyrightClaimIds()) < 1 {
		err := ContractCreateReqValidationError{
			field:  "CopyrightClaimIds",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AuthorizedNumber

	if utf8.RuneCountInString(m.GetCopyrightCategory()) < 1 {
		err := ContractCreateReqValidationError{
			field:  "CopyrightCategory",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetContent()) < 1 {
		err := ContractCreateReqValidationError{
			field:  "Content",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ContractCreateReqMultiError(errors)
	}

	return nil
}

// ContractCreateReqMultiError is an error wrapping multiple validation errors
// returned by ContractCreateReq.ValidateAll() if the designated constraints
// aren't met.
type ContractCreateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractCreateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractCreateReqMultiError) AllErrors() []error { return m }

// ContractCreateReqValidationError is the validation error returned by
// ContractCreateReq.Validate if the designated constraints aren't met.
type ContractCreateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractCreateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractCreateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractCreateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractCreateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractCreateReqValidationError) ErrorName() string {
	return "ContractCreateReqValidationError"
}

// Error satisfies the builtin error interface
func (e ContractCreateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractCreateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractCreateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractCreateReqValidationError{}

// Validate checks the field values on ContractCreateResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractCreateResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractCreateResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractCreateRespMultiError, or nil if none found.
func (m *ContractCreateResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractCreateResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContractCreateRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContractCreateRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContractCreateRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContractCreateRespMultiError(errors)
	}

	return nil
}

// ContractCreateRespMultiError is an error wrapping multiple validation errors
// returned by ContractCreateResp.ValidateAll() if the designated constraints
// aren't met.
type ContractCreateRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractCreateRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractCreateRespMultiError) AllErrors() []error { return m }

// ContractCreateRespValidationError is the validation error returned by
// ContractCreateResp.Validate if the designated constraints aren't met.
type ContractCreateRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractCreateRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractCreateRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractCreateRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractCreateRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractCreateRespValidationError) ErrorName() string {
	return "ContractCreateRespValidationError"
}

// Error satisfies the builtin error interface
func (e ContractCreateRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractCreateResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractCreateRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractCreateRespValidationError{}

// Validate checks the field values on ContractListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ContractListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractListReqMultiError, or nil if none found.
func (m *ContractListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContractIds

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return ContractListReqMultiError(errors)
	}

	return nil
}

// ContractListReqMultiError is an error wrapping multiple validation errors
// returned by ContractListReq.ValidateAll() if the designated constraints
// aren't met.
type ContractListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractListReqMultiError) AllErrors() []error { return m }

// ContractListReqValidationError is the validation error returned by
// ContractListReq.Validate if the designated constraints aren't met.
type ContractListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractListReqValidationError) ErrorName() string { return "ContractListReqValidationError" }

// Error satisfies the builtin error interface
func (e ContractListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractListReqValidationError{}

// Validate checks the field values on ContractListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ContractListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractListRespMultiError, or nil if none found.
func (m *ContractListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContractListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContractListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContractListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContractListRespMultiError(errors)
	}

	return nil
}

// ContractListRespMultiError is an error wrapping multiple validation errors
// returned by ContractListResp.ValidateAll() if the designated constraints
// aren't met.
type ContractListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractListRespMultiError) AllErrors() []error { return m }

// ContractListRespValidationError is the validation error returned by
// ContractListResp.Validate if the designated constraints aren't met.
type ContractListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractListRespValidationError) ErrorName() string { return "ContractListRespValidationError" }

// Error satisfies the builtin error interface
func (e ContractListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractListRespValidationError{}

// Validate checks the field values on ContractInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ContractInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContractInfoMultiError, or
// nil if none found.
func (m *ContractInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContractId

	// no validation rules for CopyrightCategory

	// no validation rules for AuthorizedNumber

	// no validation rules for AuthorizedUsedNumber

	// no validation rules for CastedCollectionNumber

	// no validation rules for Content

	// no validation rules for CopyrightCredential

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return ContractInfoMultiError(errors)
	}

	return nil
}

// ContractInfoMultiError is an error wrapping multiple validation errors
// returned by ContractInfo.ValidateAll() if the designated constraints aren't met.
type ContractInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractInfoMultiError) AllErrors() []error { return m }

// ContractInfoValidationError is the validation error returned by
// ContractInfo.Validate if the designated constraints aren't met.
type ContractInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractInfoValidationError) ErrorName() string { return "ContractInfoValidationError" }

// Error satisfies the builtin error interface
func (e ContractInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractInfoValidationError{}

// Validate checks the field values on ContractAuthorizationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractAuthorizationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractAuthorizationReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractAuthorizationReqMultiError, or nil if none found.
func (m *ContractAuthorizationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractAuthorizationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetContractId() <= 0 {
		err := ContractAuthorizationReqValidationError{
			field:  "ContractId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizedAddress()) < 1 {
		err := ContractAuthorizationReqValidationError{
			field:  "AuthorizedAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizationContent()) < 1 {
		err := ContractAuthorizationReqValidationError{
			field:  "AuthorizationContent",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContractAuthorizationReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContractAuthorizationReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContractAuthorizationReqValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Remarks

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return ContractAuthorizationReqMultiError(errors)
	}

	return nil
}

// ContractAuthorizationReqMultiError is an error wrapping multiple validation
// errors returned by ContractAuthorizationReq.ValidateAll() if the designated
// constraints aren't met.
type ContractAuthorizationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractAuthorizationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractAuthorizationReqMultiError) AllErrors() []error { return m }

// ContractAuthorizationReqValidationError is the validation error returned by
// ContractAuthorizationReq.Validate if the designated constraints aren't met.
type ContractAuthorizationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractAuthorizationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractAuthorizationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractAuthorizationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractAuthorizationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractAuthorizationReqValidationError) ErrorName() string {
	return "ContractAuthorizationReqValidationError"
}

// Error satisfies the builtin error interface
func (e ContractAuthorizationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractAuthorizationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractAuthorizationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractAuthorizationReqValidationError{}

// Validate checks the field values on ContractAuthorizationClaim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractAuthorizationClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractAuthorizationClaim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractAuthorizationClaimMultiError, or nil if none found.
func (m *ContractAuthorizationClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractAuthorizationClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDidCredential()) < 1 {
		err := ContractAuthorizationClaimValidationError{
			field:  "DidCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCopyrightCredential()) < 1 {
		err := ContractAuthorizationClaimValidationError{
			field:  "CopyrightCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizationCategory()) < 1 {
		err := ContractAuthorizationClaimValidationError{
			field:  "AuthorizationCategory",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AuthorizedNumber

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := ContractAuthorizationClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return ContractAuthorizationClaimMultiError(errors)
	}

	return nil
}

// ContractAuthorizationClaimMultiError is an error wrapping multiple
// validation errors returned by ContractAuthorizationClaim.ValidateAll() if
// the designated constraints aren't met.
type ContractAuthorizationClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractAuthorizationClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractAuthorizationClaimMultiError) AllErrors() []error { return m }

// ContractAuthorizationClaimValidationError is the validation error returned
// by ContractAuthorizationClaim.Validate if the designated constraints aren't met.
type ContractAuthorizationClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractAuthorizationClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractAuthorizationClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractAuthorizationClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractAuthorizationClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractAuthorizationClaimValidationError) ErrorName() string {
	return "ContractAuthorizationClaimValidationError"
}

// Error satisfies the builtin error interface
func (e ContractAuthorizationClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractAuthorizationClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractAuthorizationClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractAuthorizationClaimValidationError{}

// Validate checks the field values on ContractAuthorizationResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractAuthorizationResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractAuthorizationResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractAuthorizationRespMultiError, or nil if none found.
func (m *ContractAuthorizationResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractAuthorizationResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContractAuthorizationRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContractAuthorizationRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContractAuthorizationRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContractAuthorizationRespMultiError(errors)
	}

	return nil
}

// ContractAuthorizationRespMultiError is an error wrapping multiple validation
// errors returned by ContractAuthorizationResp.ValidateAll() if the
// designated constraints aren't met.
type ContractAuthorizationRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractAuthorizationRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractAuthorizationRespMultiError) AllErrors() []error { return m }

// ContractAuthorizationRespValidationError is the validation error returned by
// ContractAuthorizationResp.Validate if the designated constraints aren't met.
type ContractAuthorizationRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractAuthorizationRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractAuthorizationRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractAuthorizationRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractAuthorizationRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractAuthorizationRespValidationError) ErrorName() string {
	return "ContractAuthorizationRespValidationError"
}

// Error satisfies the builtin error interface
func (e ContractAuthorizationRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractAuthorizationResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractAuthorizationRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractAuthorizationRespValidationError{}

// Validate checks the field values on CopyrightClaimListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimListReqMultiError, or nil if none found.
func (m *CopyrightClaimListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClaimTitle

	// no validation rules for CopyrightHash

	// no validation rules for Credential

	// no validation rules for RegisterAddress

	// no validation rules for ContractIds

	// no validation rules for AuditStatus

	// no validation rules for AuditTimeStart

	// no validation rules for AuditTimeEnd

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return CopyrightClaimListReqMultiError(errors)
	}

	return nil
}

// CopyrightClaimListReqMultiError is an error wrapping multiple validation
// errors returned by CopyrightClaimListReq.ValidateAll() if the designated
// constraints aren't met.
type CopyrightClaimListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimListReqMultiError) AllErrors() []error { return m }

// CopyrightClaimListReqValidationError is the validation error returned by
// CopyrightClaimListReq.Validate if the designated constraints aren't met.
type CopyrightClaimListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimListReqValidationError) ErrorName() string {
	return "CopyrightClaimListReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimListReqValidationError{}

// Validate checks the field values on CopyrightClaimListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimListRespMultiError, or nil if none found.
func (m *CopyrightClaimListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightClaimListRespMultiError(errors)
	}

	return nil
}

// CopyrightClaimListRespMultiError is an error wrapping multiple validation
// errors returned by CopyrightClaimListResp.ValidateAll() if the designated
// constraints aren't met.
type CopyrightClaimListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimListRespMultiError) AllErrors() []error { return m }

// CopyrightClaimListRespValidationError is the validation error returned by
// CopyrightClaimListResp.Validate if the designated constraints aren't met.
type CopyrightClaimListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimListRespValidationError) ErrorName() string {
	return "CopyrightClaimListRespValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimListRespValidationError{}

// Validate checks the field values on CopyrightClaimInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimInfoMultiError, or nil if none found.
func (m *CopyrightClaimInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightClaimId

	// no validation rules for ClaimTitle

	// no validation rules for CopyrightId

	// no validation rules for RegisterAddress

	// no validation rules for AppNo

	// no validation rules for Credential

	// no validation rules for CopyrightHash

	// no validation rules for AuditStatus

	// no validation rules for AuditTime

	// no validation rules for RejectReason

	// no validation rules for Remarks

	// no validation rules for CopyrightCategory

	// no validation rules for AuthorizedNumber

	// no validation rules for AuthorizedUsedNumber

	// no validation rules for CastedCollectionNumber

	// no validation rules for Claim

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return CopyrightClaimInfoMultiError(errors)
	}

	return nil
}

// CopyrightClaimInfoMultiError is an error wrapping multiple validation errors
// returned by CopyrightClaimInfo.ValidateAll() if the designated constraints
// aren't met.
type CopyrightClaimInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimInfoMultiError) AllErrors() []error { return m }

// CopyrightClaimInfoValidationError is the validation error returned by
// CopyrightClaimInfo.Validate if the designated constraints aren't met.
type CopyrightClaimInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimInfoValidationError) ErrorName() string {
	return "CopyrightClaimInfoValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimInfoValidationError{}

// Validate checks the field values on CopyrightStatisticsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightStatisticsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightStatisticsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightStatisticsReqMultiError, or nil if none found.
func (m *CopyrightStatisticsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightStatisticsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CopyrightStatisticsReqMultiError(errors)
	}

	return nil
}

// CopyrightStatisticsReqMultiError is an error wrapping multiple validation
// errors returned by CopyrightStatisticsReq.ValidateAll() if the designated
// constraints aren't met.
type CopyrightStatisticsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightStatisticsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightStatisticsReqMultiError) AllErrors() []error { return m }

// CopyrightStatisticsReqValidationError is the validation error returned by
// CopyrightStatisticsReq.Validate if the designated constraints aren't met.
type CopyrightStatisticsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightStatisticsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightStatisticsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightStatisticsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightStatisticsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightStatisticsReqValidationError) ErrorName() string {
	return "CopyrightStatisticsReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightStatisticsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightStatisticsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightStatisticsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightStatisticsReqValidationError{}

// Validate checks the field values on CopyrightStatisticsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightStatisticsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightStatisticsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightStatisticsRespMultiError, or nil if none found.
func (m *CopyrightStatisticsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightStatisticsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightStatisticsRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightStatisticsRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightStatisticsRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightStatisticsRespMultiError(errors)
	}

	return nil
}

// CopyrightStatisticsRespMultiError is an error wrapping multiple validation
// errors returned by CopyrightStatisticsResp.ValidateAll() if the designated
// constraints aren't met.
type CopyrightStatisticsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightStatisticsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightStatisticsRespMultiError) AllErrors() []error { return m }

// CopyrightStatisticsRespValidationError is the validation error returned by
// CopyrightStatisticsResp.Validate if the designated constraints aren't met.
type CopyrightStatisticsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightStatisticsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightStatisticsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightStatisticsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightStatisticsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightStatisticsRespValidationError) ErrorName() string {
	return "CopyrightStatisticsRespValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightStatisticsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightStatisticsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightStatisticsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightStatisticsRespValidationError{}

// Validate checks the field values on CopyrightRegisterResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightRegisterResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightRegisterResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightRegisterResp_DataMultiError, or nil if none found.
func (m *CopyrightRegisterResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightRegisterResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightId

	// no validation rules for CopyrightHash

	// no validation rules for CopyrightClaimId

	// no validation rules for CopyrightCredential

	if len(errors) > 0 {
		return CopyrightRegisterResp_DataMultiError(errors)
	}

	return nil
}

// CopyrightRegisterResp_DataMultiError is an error wrapping multiple
// validation errors returned by CopyrightRegisterResp_Data.ValidateAll() if
// the designated constraints aren't met.
type CopyrightRegisterResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightRegisterResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightRegisterResp_DataMultiError) AllErrors() []error { return m }

// CopyrightRegisterResp_DataValidationError is the validation error returned
// by CopyrightRegisterResp_Data.Validate if the designated constraints aren't met.
type CopyrightRegisterResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightRegisterResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightRegisterResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightRegisterResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightRegisterResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightRegisterResp_DataValidationError) ErrorName() string {
	return "CopyrightRegisterResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightRegisterResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightRegisterResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightRegisterResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightRegisterResp_DataValidationError{}

// Validate checks the field values on CopyrightRegisterListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightRegisterListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightRegisterListResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CopyrightRegisterListResp_DataMultiError, or nil if none found.
func (m *CopyrightRegisterListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightRegisterListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CopyrightRegisterListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CopyrightRegisterListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CopyrightRegisterListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CopyrightRegisterListResp_DataMultiError(errors)
	}

	return nil
}

// CopyrightRegisterListResp_DataMultiError is an error wrapping multiple
// validation errors returned by CopyrightRegisterListResp_Data.ValidateAll()
// if the designated constraints aren't met.
type CopyrightRegisterListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightRegisterListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightRegisterListResp_DataMultiError) AllErrors() []error { return m }

// CopyrightRegisterListResp_DataValidationError is the validation error
// returned by CopyrightRegisterListResp_Data.Validate if the designated
// constraints aren't met.
type CopyrightRegisterListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightRegisterListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightRegisterListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightRegisterListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightRegisterListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightRegisterListResp_DataValidationError) ErrorName() string {
	return "CopyrightRegisterListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightRegisterListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightRegisterListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightRegisterListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightRegisterListResp_DataValidationError{}

// Validate checks the field values on CopyrightAuthorizationListResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CopyrightAuthorizationListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightAuthorizationListResp_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CopyrightAuthorizationListResp_DataMultiError, or nil if none found.
func (m *CopyrightAuthorizationListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightAuthorizationListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CopyrightAuthorizationListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CopyrightAuthorizationListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CopyrightAuthorizationListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CopyrightAuthorizationListResp_DataMultiError(errors)
	}

	return nil
}

// CopyrightAuthorizationListResp_DataMultiError is an error wrapping multiple
// validation errors returned by
// CopyrightAuthorizationListResp_Data.ValidateAll() if the designated
// constraints aren't met.
type CopyrightAuthorizationListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightAuthorizationListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightAuthorizationListResp_DataMultiError) AllErrors() []error { return m }

// CopyrightAuthorizationListResp_DataValidationError is the validation error
// returned by CopyrightAuthorizationListResp_Data.Validate if the designated
// constraints aren't met.
type CopyrightAuthorizationListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightAuthorizationListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightAuthorizationListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightAuthorizationListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightAuthorizationListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightAuthorizationListResp_DataValidationError) ErrorName() string {
	return "CopyrightAuthorizationListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightAuthorizationListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightAuthorizationListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightAuthorizationListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightAuthorizationListResp_DataValidationError{}

// Validate checks the field values on CopyrightClaimAuthorizationResp_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CopyrightClaimAuthorizationResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimAuthorizationResp_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CopyrightClaimAuthorizationResp_DataMultiError, or nil if none found.
func (m *CopyrightClaimAuthorizationResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimAuthorizationResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizationId

	// no validation rules for AuthorizationCode

	// no validation rules for DidCredential

	// no validation rules for CopyrightCredential

	// no validation rules for AuthorizationCredential

	if len(errors) > 0 {
		return CopyrightClaimAuthorizationResp_DataMultiError(errors)
	}

	return nil
}

// CopyrightClaimAuthorizationResp_DataMultiError is an error wrapping multiple
// validation errors returned by
// CopyrightClaimAuthorizationResp_Data.ValidateAll() if the designated
// constraints aren't met.
type CopyrightClaimAuthorizationResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimAuthorizationResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimAuthorizationResp_DataMultiError) AllErrors() []error { return m }

// CopyrightClaimAuthorizationResp_DataValidationError is the validation error
// returned by CopyrightClaimAuthorizationResp_Data.Validate if the designated
// constraints aren't met.
type CopyrightClaimAuthorizationResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimAuthorizationResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimAuthorizationResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimAuthorizationResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimAuthorizationResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimAuthorizationResp_DataValidationError) ErrorName() string {
	return "CopyrightClaimAuthorizationResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimAuthorizationResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimAuthorizationResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimAuthorizationResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimAuthorizationResp_DataValidationError{}

// Validate checks the field values on CopyrightMintResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightMintResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightMintResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightMintResp_DataMultiError, or nil if none found.
func (m *CopyrightMintResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightMintResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyrightId

	// no validation rules for CopyrightHash

	// no validation rules for CopyrightClaimId

	if len(errors) > 0 {
		return CopyrightMintResp_DataMultiError(errors)
	}

	return nil
}

// CopyrightMintResp_DataMultiError is an error wrapping multiple validation
// errors returned by CopyrightMintResp_Data.ValidateAll() if the designated
// constraints aren't met.
type CopyrightMintResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightMintResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightMintResp_DataMultiError) AllErrors() []error { return m }

// CopyrightMintResp_DataValidationError is the validation error returned by
// CopyrightMintResp_Data.Validate if the designated constraints aren't met.
type CopyrightMintResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightMintResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightMintResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightMintResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightMintResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightMintResp_DataValidationError) ErrorName() string {
	return "CopyrightMintResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightMintResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightMintResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightMintResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightMintResp_DataValidationError{}

// Validate checks the field values on ContractCreateResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractCreateResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractCreateResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractCreateResp_DataMultiError, or nil if none found.
func (m *ContractCreateResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractCreateResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContractId

	if len(errors) > 0 {
		return ContractCreateResp_DataMultiError(errors)
	}

	return nil
}

// ContractCreateResp_DataMultiError is an error wrapping multiple validation
// errors returned by ContractCreateResp_Data.ValidateAll() if the designated
// constraints aren't met.
type ContractCreateResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractCreateResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractCreateResp_DataMultiError) AllErrors() []error { return m }

// ContractCreateResp_DataValidationError is the validation error returned by
// ContractCreateResp_Data.Validate if the designated constraints aren't met.
type ContractCreateResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractCreateResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractCreateResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractCreateResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractCreateResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractCreateResp_DataValidationError) ErrorName() string {
	return "ContractCreateResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e ContractCreateResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractCreateResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractCreateResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractCreateResp_DataValidationError{}

// Validate checks the field values on ContractListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractListResp_DataMultiError, or nil if none found.
func (m *ContractListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ContractListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ContractListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ContractListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ContractListResp_DataMultiError(errors)
	}

	return nil
}

// ContractListResp_DataMultiError is an error wrapping multiple validation
// errors returned by ContractListResp_Data.ValidateAll() if the designated
// constraints aren't met.
type ContractListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractListResp_DataMultiError) AllErrors() []error { return m }

// ContractListResp_DataValidationError is the validation error returned by
// ContractListResp_Data.Validate if the designated constraints aren't met.
type ContractListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractListResp_DataValidationError) ErrorName() string {
	return "ContractListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e ContractListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractListResp_DataValidationError{}

// Validate checks the field values on ContractAuthorizationResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractAuthorizationResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractAuthorizationResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ContractAuthorizationResp_DataMultiError, or nil if none found.
func (m *ContractAuthorizationResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractAuthorizationResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizationId

	// no validation rules for AuthorizationCredential

	if len(errors) > 0 {
		return ContractAuthorizationResp_DataMultiError(errors)
	}

	return nil
}

// ContractAuthorizationResp_DataMultiError is an error wrapping multiple
// validation errors returned by ContractAuthorizationResp_Data.ValidateAll()
// if the designated constraints aren't met.
type ContractAuthorizationResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractAuthorizationResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractAuthorizationResp_DataMultiError) AllErrors() []error { return m }

// ContractAuthorizationResp_DataValidationError is the validation error
// returned by ContractAuthorizationResp_Data.Validate if the designated
// constraints aren't met.
type ContractAuthorizationResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractAuthorizationResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractAuthorizationResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractAuthorizationResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractAuthorizationResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractAuthorizationResp_DataValidationError) ErrorName() string {
	return "ContractAuthorizationResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e ContractAuthorizationResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractAuthorizationResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractAuthorizationResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractAuthorizationResp_DataValidationError{}

// Validate checks the field values on CopyrightClaimListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimListResp_DataMultiError, or nil if none found.
func (m *CopyrightClaimListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CopyrightClaimListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CopyrightClaimListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CopyrightClaimListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CopyrightClaimListResp_DataMultiError(errors)
	}

	return nil
}

// CopyrightClaimListResp_DataMultiError is an error wrapping multiple
// validation errors returned by CopyrightClaimListResp_Data.ValidateAll() if
// the designated constraints aren't met.
type CopyrightClaimListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimListResp_DataMultiError) AllErrors() []error { return m }

// CopyrightClaimListResp_DataValidationError is the validation error returned
// by CopyrightClaimListResp_Data.Validate if the designated constraints
// aren't met.
type CopyrightClaimListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimListResp_DataValidationError) ErrorName() string {
	return "CopyrightClaimListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimListResp_DataValidationError{}

// Validate checks the field values on CopyrightStatisticsResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightStatisticsResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightStatisticsResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightStatisticsResp_DataMultiError, or nil if none found.
func (m *CopyrightStatisticsResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightStatisticsResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompositionNum

	// no validation rules for CopyrightNum

	// no validation rules for CollectionNum

	// no validation rules for HoldCollectionNum

	// no validation rules for DealAmount

	// no validation rules for DealNum

	if len(errors) > 0 {
		return CopyrightStatisticsResp_DataMultiError(errors)
	}

	return nil
}

// CopyrightStatisticsResp_DataMultiError is an error wrapping multiple
// validation errors returned by CopyrightStatisticsResp_Data.ValidateAll() if
// the designated constraints aren't met.
type CopyrightStatisticsResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightStatisticsResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightStatisticsResp_DataMultiError) AllErrors() []error { return m }

// CopyrightStatisticsResp_DataValidationError is the validation error returned
// by CopyrightStatisticsResp_Data.Validate if the designated constraints
// aren't met.
type CopyrightStatisticsResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightStatisticsResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightStatisticsResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightStatisticsResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightStatisticsResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightStatisticsResp_DataValidationError) ErrorName() string {
	return "CopyrightStatisticsResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightStatisticsResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightStatisticsResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightStatisticsResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightStatisticsResp_DataValidationError{}
