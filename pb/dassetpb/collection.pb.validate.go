// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pb/dassetpb/collection.proto

package dassetpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CollectionClaimCreateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionClaimCreateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionClaimCreateReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionClaimCreateReqMultiError, or nil if none found.
func (m *CollectionClaimCreateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionClaimCreateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizationId

	// no validation rules for AuthorizationCode

	if utf8.RuneCountInString(m.GetCollectionName()) < 1 {
		err := CollectionClaimCreateReqValidationError{
			field:  "CollectionName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := CollectionClaimCreateReqValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CollectionClaimCreateReqMultiError(errors)
	}

	return nil
}

// CollectionClaimCreateReqMultiError is an error wrapping multiple validation
// errors returned by CollectionClaimCreateReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionClaimCreateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionClaimCreateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionClaimCreateReqMultiError) AllErrors() []error { return m }

// CollectionClaimCreateReqValidationError is the validation error returned by
// CollectionClaimCreateReq.Validate if the designated constraints aren't met.
type CollectionClaimCreateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionClaimCreateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionClaimCreateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionClaimCreateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionClaimCreateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionClaimCreateReqValidationError) ErrorName() string {
	return "CollectionClaimCreateReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionClaimCreateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionClaimCreateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionClaimCreateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionClaimCreateReqValidationError{}

// Validate checks the field values on CollectionClaimCreateResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionClaimCreateResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionClaimCreateResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionClaimCreateRespMultiError, or nil if none found.
func (m *CollectionClaimCreateResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionClaimCreateResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionClaimCreateRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionClaimCreateRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionClaimCreateRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionClaimCreateRespMultiError(errors)
	}

	return nil
}

// CollectionClaimCreateRespMultiError is an error wrapping multiple validation
// errors returned by CollectionClaimCreateResp.ValidateAll() if the
// designated constraints aren't met.
type CollectionClaimCreateRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionClaimCreateRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionClaimCreateRespMultiError) AllErrors() []error { return m }

// CollectionClaimCreateRespValidationError is the validation error returned by
// CollectionClaimCreateResp.Validate if the designated constraints aren't met.
type CollectionClaimCreateRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionClaimCreateRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionClaimCreateRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionClaimCreateRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionClaimCreateRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionClaimCreateRespValidationError) ErrorName() string {
	return "CollectionClaimCreateRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionClaimCreateRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionClaimCreateResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionClaimCreateRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionClaimCreateRespValidationError{}

// Validate checks the field values on CollectionTokenReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionTokenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTokenReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionTokenReqMultiError, or nil if none found.
func (m *CollectionTokenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTokenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenId

	if len(errors) > 0 {
		return CollectionTokenReqMultiError(errors)
	}

	return nil
}

// CollectionTokenReqMultiError is an error wrapping multiple validation errors
// returned by CollectionTokenReq.ValidateAll() if the designated constraints
// aren't met.
type CollectionTokenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTokenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTokenReqMultiError) AllErrors() []error { return m }

// CollectionTokenReqValidationError is the validation error returned by
// CollectionTokenReq.Validate if the designated constraints aren't met.
type CollectionTokenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTokenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTokenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTokenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTokenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTokenReqValidationError) ErrorName() string {
	return "CollectionTokenReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTokenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTokenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTokenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTokenReqValidationError{}

// Validate checks the field values on CollectionTokenResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionTokenResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTokenResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionTokenRespMultiError, or nil if none found.
func (m *CollectionTokenResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTokenResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Description

	// no validation rules for ExternalUrl

	// no validation rules for Image

	// no validation rules for Name

	// no validation rules for Num

	// no validation rules for TxId

	// no validation rules for TxTime

	if len(errors) > 0 {
		return CollectionTokenRespMultiError(errors)
	}

	return nil
}

// CollectionTokenRespMultiError is an error wrapping multiple validation
// errors returned by CollectionTokenResp.ValidateAll() if the designated
// constraints aren't met.
type CollectionTokenRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTokenRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTokenRespMultiError) AllErrors() []error { return m }

// CollectionTokenRespValidationError is the validation error returned by
// CollectionTokenResp.Validate if the designated constraints aren't met.
type CollectionTokenRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTokenRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTokenRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTokenRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTokenRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTokenRespValidationError) ErrorName() string {
	return "CollectionTokenRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTokenRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTokenResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTokenRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTokenRespValidationError{}

// Validate checks the field values on CollectionCreateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCreateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCreateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCreateReqMultiError, or nil if none found.
func (m *CollectionCreateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCreateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizationId

	// no validation rules for AuthorizationCode

	if m.GetPrice() < 0 {
		err := CollectionCreateReqValidationError{
			field:  "Price",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TokenUrl

	// no validation rules for AvailableTimes

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCreateReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCreateReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCreateReqValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return CollectionCreateReqMultiError(errors)
	}

	return nil
}

// CollectionCreateReqMultiError is an error wrapping multiple validation
// errors returned by CollectionCreateReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionCreateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCreateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCreateReqMultiError) AllErrors() []error { return m }

// CollectionCreateReqValidationError is the validation error returned by
// CollectionCreateReq.Validate if the designated constraints aren't met.
type CollectionCreateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCreateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCreateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCreateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCreateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCreateReqValidationError) ErrorName() string {
	return "CollectionCreateReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCreateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCreateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCreateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCreateReqValidationError{}

// Validate checks the field values on CollectionClaim with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CollectionClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionClaim with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionClaimMultiError, or nil if none found.
func (m *CollectionClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCollectionName()) < 1 {
		err := CollectionClaimValidationError{
			field:  "CollectionName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDidCredential()) < 1 {
		err := CollectionClaimValidationError{
			field:  "DidCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCopyrightCredential()) < 1 {
		err := CollectionClaimValidationError{
			field:  "CopyrightCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizationCredential()) < 1 {
		err := CollectionClaimValidationError{
			field:  "AuthorizationCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CollectionHash

	// no validation rules for TokenId

	if utf8.RuneCountInString(m.GetFrom()) < 1 {
		err := CollectionClaimValidationError{
			field:  "From",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := CollectionClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return CollectionClaimMultiError(errors)
	}

	return nil
}

// CollectionClaimMultiError is an error wrapping multiple validation errors
// returned by CollectionClaim.ValidateAll() if the designated constraints
// aren't met.
type CollectionClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionClaimMultiError) AllErrors() []error { return m }

// CollectionClaimValidationError is the validation error returned by
// CollectionClaim.Validate if the designated constraints aren't met.
type CollectionClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionClaimValidationError) ErrorName() string { return "CollectionClaimValidationError" }

// Error satisfies the builtin error interface
func (e CollectionClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionClaimValidationError{}

// Validate checks the field values on CollectionCreateResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCreateResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCreateResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCreateRespMultiError, or nil if none found.
func (m *CollectionCreateResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCreateResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCreateRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCreateRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCreateRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionCreateRespMultiError(errors)
	}

	return nil
}

// CollectionCreateRespMultiError is an error wrapping multiple validation
// errors returned by CollectionCreateResp.ValidateAll() if the designated
// constraints aren't met.
type CollectionCreateRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCreateRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCreateRespMultiError) AllErrors() []error { return m }

// CollectionCreateRespValidationError is the validation error returned by
// CollectionCreateResp.Validate if the designated constraints aren't met.
type CollectionCreateRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCreateRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCreateRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCreateRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCreateRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCreateRespValidationError) ErrorName() string {
	return "CollectionCreateRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCreateRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCreateResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCreateRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCreateRespValidationError{}

// Validate checks the field values on CollectionBatchCreateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionBatchCreateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionBatchCreateReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionBatchCreateReqMultiError, or nil if none found.
func (m *CollectionBatchCreateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionBatchCreateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizationId

	// no validation rules for AuthorizationCode

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CollectionBatchCreateReqValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CollectionBatchCreateReqValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CollectionBatchCreateReqValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return CollectionBatchCreateReqMultiError(errors)
	}

	return nil
}

// CollectionBatchCreateReqMultiError is an error wrapping multiple validation
// errors returned by CollectionBatchCreateReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionBatchCreateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionBatchCreateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionBatchCreateReqMultiError) AllErrors() []error { return m }

// CollectionBatchCreateReqValidationError is the validation error returned by
// CollectionBatchCreateReq.Validate if the designated constraints aren't met.
type CollectionBatchCreateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionBatchCreateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionBatchCreateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionBatchCreateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionBatchCreateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionBatchCreateReqValidationError) ErrorName() string {
	return "CollectionBatchCreateReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionBatchCreateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionBatchCreateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionBatchCreateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionBatchCreateReqValidationError{}

// Validate checks the field values on CollectionCreateInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCreateInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCreateInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCreateInfoMultiError, or nil if none found.
func (m *CollectionCreateInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCreateInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPrice() < 0 {
		err := CollectionCreateInfoValidationError{
			field:  "Price",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TokenUrl

	// no validation rules for AvailableTimes

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCreateInfoValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCreateInfoValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCreateInfoValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionCreateInfoMultiError(errors)
	}

	return nil
}

// CollectionCreateInfoMultiError is an error wrapping multiple validation
// errors returned by CollectionCreateInfo.ValidateAll() if the designated
// constraints aren't met.
type CollectionCreateInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCreateInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCreateInfoMultiError) AllErrors() []error { return m }

// CollectionCreateInfoValidationError is the validation error returned by
// CollectionCreateInfo.Validate if the designated constraints aren't met.
type CollectionCreateInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCreateInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCreateInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCreateInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCreateInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCreateInfoValidationError) ErrorName() string {
	return "CollectionCreateInfoValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCreateInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCreateInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCreateInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCreateInfoValidationError{}

// Validate checks the field values on CollectionBatchCreateResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionBatchCreateResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionBatchCreateResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionBatchCreateRespMultiError, or nil if none found.
func (m *CollectionBatchCreateResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionBatchCreateResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionBatchCreateRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionBatchCreateRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionBatchCreateRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionBatchCreateRespMultiError(errors)
	}

	return nil
}

// CollectionBatchCreateRespMultiError is an error wrapping multiple validation
// errors returned by CollectionBatchCreateResp.ValidateAll() if the
// designated constraints aren't met.
type CollectionBatchCreateRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionBatchCreateRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionBatchCreateRespMultiError) AllErrors() []error { return m }

// CollectionBatchCreateRespValidationError is the validation error returned by
// CollectionBatchCreateResp.Validate if the designated constraints aren't met.
type CollectionBatchCreateRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionBatchCreateRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionBatchCreateRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionBatchCreateRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionBatchCreateRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionBatchCreateRespValidationError) ErrorName() string {
	return "CollectionBatchCreateRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionBatchCreateRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionBatchCreateResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionBatchCreateRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionBatchCreateRespValidationError{}

// Validate checks the field values on CollectionLightCreateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionLightCreateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionLightCreateReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionLightCreateReqMultiError, or nil if none found.
func (m *CollectionLightCreateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionLightCreateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CollectionLightCreateReqValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CollectionLightCreateReqValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CollectionLightCreateReqValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return CollectionLightCreateReqMultiError(errors)
	}

	return nil
}

// CollectionLightCreateReqMultiError is an error wrapping multiple validation
// errors returned by CollectionLightCreateReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionLightCreateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionLightCreateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionLightCreateReqMultiError) AllErrors() []error { return m }

// CollectionLightCreateReqValidationError is the validation error returned by
// CollectionLightCreateReq.Validate if the designated constraints aren't met.
type CollectionLightCreateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionLightCreateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionLightCreateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionLightCreateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionLightCreateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionLightCreateReqValidationError) ErrorName() string {
	return "CollectionLightCreateReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionLightCreateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionLightCreateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionLightCreateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionLightCreateReqValidationError{}

// Validate checks the field values on CollectionLight with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CollectionLight) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionLight with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionLightMultiError, or nil if none found.
func (m *CollectionLight) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionLight) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCollectionName()) < 1 {
		err := CollectionLightValidationError{
			field:  "CollectionName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPrice() < 0 {
		err := CollectionLightValidationError{
			field:  "Price",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TokenUrl

	// no validation rules for AvailableTimes

	if len(errors) > 0 {
		return CollectionLightMultiError(errors)
	}

	return nil
}

// CollectionLightMultiError is an error wrapping multiple validation errors
// returned by CollectionLight.ValidateAll() if the designated constraints
// aren't met.
type CollectionLightMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionLightMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionLightMultiError) AllErrors() []error { return m }

// CollectionLightValidationError is the validation error returned by
// CollectionLight.Validate if the designated constraints aren't met.
type CollectionLightValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionLightValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionLightValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionLightValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionLightValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionLightValidationError) ErrorName() string { return "CollectionLightValidationError" }

// Error satisfies the builtin error interface
func (e CollectionLightValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionLight.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionLightValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionLightValidationError{}

// Validate checks the field values on CollectionLightCreateResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionLightCreateResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionLightCreateResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionLightCreateRespMultiError, or nil if none found.
func (m *CollectionLightCreateResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionLightCreateResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionLightCreateRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionLightCreateRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionLightCreateRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionLightCreateRespMultiError(errors)
	}

	return nil
}

// CollectionLightCreateRespMultiError is an error wrapping multiple validation
// errors returned by CollectionLightCreateResp.ValidateAll() if the
// designated constraints aren't met.
type CollectionLightCreateRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionLightCreateRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionLightCreateRespMultiError) AllErrors() []error { return m }

// CollectionLightCreateRespValidationError is the validation error returned by
// CollectionLightCreateResp.Validate if the designated constraints aren't met.
type CollectionLightCreateRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionLightCreateRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionLightCreateRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionLightCreateRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionLightCreateRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionLightCreateRespValidationError) ErrorName() string {
	return "CollectionLightCreateRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionLightCreateRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionLightCreateResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionLightCreateRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionLightCreateRespValidationError{}

// Validate checks the field values on CollectionListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CollectionListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionListReqMultiError, or nil if none found.
func (m *CollectionListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionHash

	// no validation rules for AuthorizationCode

	// no validation rules for CastingAddress

	// no validation rules for OwnerAddress

	// no validation rules for Credential

	// no validation rules for CollectionType

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return CollectionListReqMultiError(errors)
	}

	return nil
}

// CollectionListReqMultiError is an error wrapping multiple validation errors
// returned by CollectionListReq.ValidateAll() if the designated constraints
// aren't met.
type CollectionListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionListReqMultiError) AllErrors() []error { return m }

// CollectionListReqValidationError is the validation error returned by
// CollectionListReq.Validate if the designated constraints aren't met.
type CollectionListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionListReqValidationError) ErrorName() string {
	return "CollectionListReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionListReqValidationError{}

// Validate checks the field values on CollectionListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionListRespMultiError, or nil if none found.
func (m *CollectionListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionListRespMultiError(errors)
	}

	return nil
}

// CollectionListRespMultiError is an error wrapping multiple validation errors
// returned by CollectionListResp.ValidateAll() if the designated constraints
// aren't met.
type CollectionListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionListRespMultiError) AllErrors() []error { return m }

// CollectionListRespValidationError is the validation error returned by
// CollectionListResp.Validate if the designated constraints aren't met.
type CollectionListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionListRespValidationError) ErrorName() string {
	return "CollectionListRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionListRespValidationError{}

// Validate checks the field values on CollectionInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CollectionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CollectionInfoMultiError,
// or nil if none found.
func (m *CollectionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	// no validation rules for CollectionName

	// no validation rules for CollectionHash

	// no validation rules for AuthorizationCode

	// no validation rules for TokenId

	// no validation rules for Credential

	// no validation rules for CastingUid

	// no validation rules for CastingUidName

	// no validation rules for CastingAddress

	// no validation rules for OwnerUid

	// no validation rules for OwnerUidName

	// no validation rules for OwnerAddress

	// no validation rules for HolderAddress

	// no validation rules for AvailableTimes

	// no validation rules for CheckedTimes

	// no validation rules for SellStatus

	// no validation rules for AppNo

	// no validation rules for Price

	// no validation rules for ChainStatus

	// no validation rules for ChainTxid

	// no validation rules for ChainBlockNumber

	// no validation rules for ChainTime

	// no validation rules for CheckInAppNo

	// no validation rules for UsedScene

	// no validation rules for CreateTime

	// no validation rules for ModifyTime

	if len(errors) > 0 {
		return CollectionInfoMultiError(errors)
	}

	return nil
}

// CollectionInfoMultiError is an error wrapping multiple validation errors
// returned by CollectionInfo.ValidateAll() if the designated constraints
// aren't met.
type CollectionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionInfoMultiError) AllErrors() []error { return m }

// CollectionInfoValidationError is the validation error returned by
// CollectionInfo.Validate if the designated constraints aren't met.
type CollectionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionInfoValidationError) ErrorName() string { return "CollectionInfoValidationError" }

// Error satisfies the builtin error interface
func (e CollectionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionInfoValidationError{}

// Validate checks the field values on CollectionTransactionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionTransactionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTransactionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionTransactionReqMultiError, or nil if none found.
func (m *CollectionTransactionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTransactionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCollectionId() <= 0 {
		err := CollectionTransactionReqValidationError{
			field:  "CollectionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionTransactionReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionTransactionReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionTransactionReqValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return CollectionTransactionReqMultiError(errors)
	}

	return nil
}

// CollectionTransactionReqMultiError is an error wrapping multiple validation
// errors returned by CollectionTransactionReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionTransactionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTransactionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTransactionReqMultiError) AllErrors() []error { return m }

// CollectionTransactionReqValidationError is the validation error returned by
// CollectionTransactionReq.Validate if the designated constraints aren't met.
type CollectionTransactionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTransactionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTransactionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTransactionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTransactionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTransactionReqValidationError) ErrorName() string {
	return "CollectionTransactionReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTransactionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTransactionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTransactionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTransactionReqValidationError{}

// Validate checks the field values on CollectionTransactionClaim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionTransactionClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTransactionClaim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionTransactionClaimMultiError, or nil if none found.
func (m *CollectionTransactionClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTransactionClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCollectionName()) < 1 {
		err := CollectionTransactionClaimValidationError{
			field:  "CollectionName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDidCredential()) < 1 {
		err := CollectionTransactionClaimValidationError{
			field:  "DidCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCopyrightCredential()) < 1 {
		err := CollectionTransactionClaimValidationError{
			field:  "CopyrightCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizationCredential()) < 1 {
		err := CollectionTransactionClaimValidationError{
			field:  "AuthorizationCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCollectionCredential()) < 1 {
		err := CollectionTransactionClaimValidationError{
			field:  "CollectionCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PreviousTransactionCredential

	// no validation rules for CollectionHash

	// no validation rules for TokenId

	if utf8.RuneCountInString(m.GetFrom()) < 1 {
		err := CollectionTransactionClaimValidationError{
			field:  "From",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTo()) < 1 {
		err := CollectionTransactionClaimValidationError{
			field:  "To",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := CollectionTransactionClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return CollectionTransactionClaimMultiError(errors)
	}

	return nil
}

// CollectionTransactionClaimMultiError is an error wrapping multiple
// validation errors returned by CollectionTransactionClaim.ValidateAll() if
// the designated constraints aren't met.
type CollectionTransactionClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTransactionClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTransactionClaimMultiError) AllErrors() []error { return m }

// CollectionTransactionClaimValidationError is the validation error returned
// by CollectionTransactionClaim.Validate if the designated constraints aren't met.
type CollectionTransactionClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTransactionClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTransactionClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTransactionClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTransactionClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTransactionClaimValidationError) ErrorName() string {
	return "CollectionTransactionClaimValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTransactionClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTransactionClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTransactionClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTransactionClaimValidationError{}

// Validate checks the field values on CollectionTransactionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionTransactionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTransactionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionTransactionRespMultiError, or nil if none found.
func (m *CollectionTransactionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTransactionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionTransactionRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionTransactionRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionTransactionRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionTransactionRespMultiError(errors)
	}

	return nil
}

// CollectionTransactionRespMultiError is an error wrapping multiple validation
// errors returned by CollectionTransactionResp.ValidateAll() if the
// designated constraints aren't met.
type CollectionTransactionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTransactionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTransactionRespMultiError) AllErrors() []error { return m }

// CollectionTransactionRespValidationError is the validation error returned by
// CollectionTransactionResp.Validate if the designated constraints aren't met.
type CollectionTransactionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTransactionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTransactionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTransactionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTransactionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTransactionRespValidationError) ErrorName() string {
	return "CollectionTransactionRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTransactionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTransactionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTransactionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTransactionRespValidationError{}

// Validate checks the field values on CollectionLightTransactionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionLightTransactionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionLightTransactionReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionLightTransactionReqMultiError, or nil if none found.
func (m *CollectionLightTransactionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionLightTransactionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CollectionLightTransactionReqValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CollectionLightTransactionReqValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CollectionLightTransactionReqValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return CollectionLightTransactionReqMultiError(errors)
	}

	return nil
}

// CollectionLightTransactionReqMultiError is an error wrapping multiple
// validation errors returned by CollectionLightTransactionReq.ValidateAll()
// if the designated constraints aren't met.
type CollectionLightTransactionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionLightTransactionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionLightTransactionReqMultiError) AllErrors() []error { return m }

// CollectionLightTransactionReqValidationError is the validation error
// returned by CollectionLightTransactionReq.Validate if the designated
// constraints aren't met.
type CollectionLightTransactionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionLightTransactionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionLightTransactionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionLightTransactionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionLightTransactionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionLightTransactionReqValidationError) ErrorName() string {
	return "CollectionLightTransactionReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionLightTransactionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionLightTransactionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionLightTransactionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionLightTransactionReqValidationError{}

// Validate checks the field values on CollectionLightTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionLightTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionLightTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionLightTransactionMultiError, or nil if none found.
func (m *CollectionLightTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionLightTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenId

	if utf8.RuneCountInString(m.GetFrom()) < 1 {
		err := CollectionLightTransactionValidationError{
			field:  "From",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTo()) < 1 {
		err := CollectionLightTransactionValidationError{
			field:  "To",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CollectionLightTransactionMultiError(errors)
	}

	return nil
}

// CollectionLightTransactionMultiError is an error wrapping multiple
// validation errors returned by CollectionLightTransaction.ValidateAll() if
// the designated constraints aren't met.
type CollectionLightTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionLightTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionLightTransactionMultiError) AllErrors() []error { return m }

// CollectionLightTransactionValidationError is the validation error returned
// by CollectionLightTransaction.Validate if the designated constraints aren't met.
type CollectionLightTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionLightTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionLightTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionLightTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionLightTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionLightTransactionValidationError) ErrorName() string {
	return "CollectionLightTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionLightTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionLightTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionLightTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionLightTransactionValidationError{}

// Validate checks the field values on CollectionLightTransactionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionLightTransactionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionLightTransactionResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionLightTransactionRespMultiError, or nil if none found.
func (m *CollectionLightTransactionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionLightTransactionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionLightTransactionRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionLightTransactionRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionLightTransactionRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionLightTransactionRespMultiError(errors)
	}

	return nil
}

// CollectionLightTransactionRespMultiError is an error wrapping multiple
// validation errors returned by CollectionLightTransactionResp.ValidateAll()
// if the designated constraints aren't met.
type CollectionLightTransactionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionLightTransactionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionLightTransactionRespMultiError) AllErrors() []error { return m }

// CollectionLightTransactionRespValidationError is the validation error
// returned by CollectionLightTransactionResp.Validate if the designated
// constraints aren't met.
type CollectionLightTransactionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionLightTransactionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionLightTransactionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionLightTransactionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionLightTransactionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionLightTransactionRespValidationError) ErrorName() string {
	return "CollectionLightTransactionRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionLightTransactionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionLightTransactionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionLightTransactionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionLightTransactionRespValidationError{}

// Validate checks the field values on CollectionTransactionClaimReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionTransactionClaimReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTransactionClaimReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionTransactionClaimReqMultiError, or nil if none found.
func (m *CollectionTransactionClaimReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTransactionClaimReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCollectionId() <= 0 {
		err := CollectionTransactionClaimReqValidationError{
			field:  "CollectionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CollectionTransactionClaimReqMultiError(errors)
	}

	return nil
}

// CollectionTransactionClaimReqMultiError is an error wrapping multiple
// validation errors returned by CollectionTransactionClaimReq.ValidateAll()
// if the designated constraints aren't met.
type CollectionTransactionClaimReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTransactionClaimReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTransactionClaimReqMultiError) AllErrors() []error { return m }

// CollectionTransactionClaimReqValidationError is the validation error
// returned by CollectionTransactionClaimReq.Validate if the designated
// constraints aren't met.
type CollectionTransactionClaimReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTransactionClaimReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTransactionClaimReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTransactionClaimReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTransactionClaimReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTransactionClaimReqValidationError) ErrorName() string {
	return "CollectionTransactionClaimReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTransactionClaimReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTransactionClaimReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTransactionClaimReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTransactionClaimReqValidationError{}

// Validate checks the field values on CollectionTransactionClaimResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionTransactionClaimResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTransactionClaimResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionTransactionClaimRespMultiError, or nil if none found.
func (m *CollectionTransactionClaimResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTransactionClaimResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionTransactionClaimRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionTransactionClaimRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionTransactionClaimRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionTransactionClaimRespMultiError(errors)
	}

	return nil
}

// CollectionTransactionClaimRespMultiError is an error wrapping multiple
// validation errors returned by CollectionTransactionClaimResp.ValidateAll()
// if the designated constraints aren't met.
type CollectionTransactionClaimRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTransactionClaimRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTransactionClaimRespMultiError) AllErrors() []error { return m }

// CollectionTransactionClaimRespValidationError is the validation error
// returned by CollectionTransactionClaimResp.Validate if the designated
// constraints aren't met.
type CollectionTransactionClaimRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTransactionClaimRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTransactionClaimRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTransactionClaimRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTransactionClaimRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTransactionClaimRespValidationError) ErrorName() string {
	return "CollectionTransactionClaimRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTransactionClaimRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTransactionClaimResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTransactionClaimRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTransactionClaimRespValidationError{}

// Validate checks the field values on CollectionCheckInReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCheckInReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCheckInReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCheckInReqMultiError, or nil if none found.
func (m *CollectionCheckInReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCheckInReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCollectionId() <= 0 {
		err := CollectionCheckInReqValidationError{
			field:  "CollectionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCheckinScene()) < 1 {
		err := CollectionCheckInReqValidationError{
			field:  "CheckinScene",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return CollectionCheckInReqMultiError(errors)
	}

	return nil
}

// CollectionCheckInReqMultiError is an error wrapping multiple validation
// errors returned by CollectionCheckInReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionCheckInReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCheckInReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCheckInReqMultiError) AllErrors() []error { return m }

// CollectionCheckInReqValidationError is the validation error returned by
// CollectionCheckInReq.Validate if the designated constraints aren't met.
type CollectionCheckInReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCheckInReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCheckInReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCheckInReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCheckInReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCheckInReqValidationError) ErrorName() string {
	return "CollectionCheckInReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCheckInReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCheckInReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCheckInReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCheckInReqValidationError{}

// Validate checks the field values on CollectionCheckInResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCheckInResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCheckInResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCheckInRespMultiError, or nil if none found.
func (m *CollectionCheckInResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCheckInResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCheckInRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCheckInRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCheckInRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionCheckInRespMultiError(errors)
	}

	return nil
}

// CollectionCheckInRespMultiError is an error wrapping multiple validation
// errors returned by CollectionCheckInResp.ValidateAll() if the designated
// constraints aren't met.
type CollectionCheckInRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCheckInRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCheckInRespMultiError) AllErrors() []error { return m }

// CollectionCheckInRespValidationError is the validation error returned by
// CollectionCheckInResp.Validate if the designated constraints aren't met.
type CollectionCheckInRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCheckInRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCheckInRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCheckInRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCheckInRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCheckInRespValidationError) ErrorName() string {
	return "CollectionCheckInRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCheckInRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCheckInResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCheckInRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCheckInRespValidationError{}

// Validate checks the field values on CollectionCheckInListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCheckInListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCheckInListReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCheckInListReqMultiError, or nil if none found.
func (m *CollectionCheckInListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCheckInListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	// no validation rules for CheckinScene

	// no validation rules for CheckinTimeStart

	// no validation rules for CheckinTimeEnd

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return CollectionCheckInListReqMultiError(errors)
	}

	return nil
}

// CollectionCheckInListReqMultiError is an error wrapping multiple validation
// errors returned by CollectionCheckInListReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionCheckInListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCheckInListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCheckInListReqMultiError) AllErrors() []error { return m }

// CollectionCheckInListReqValidationError is the validation error returned by
// CollectionCheckInListReq.Validate if the designated constraints aren't met.
type CollectionCheckInListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCheckInListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCheckInListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCheckInListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCheckInListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCheckInListReqValidationError) ErrorName() string {
	return "CollectionCheckInListReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCheckInListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCheckInListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCheckInListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCheckInListReqValidationError{}

// Validate checks the field values on CollectionCheckInListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCheckInListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCheckInListResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCheckInListRespMultiError, or nil if none found.
func (m *CollectionCheckInListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCheckInListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCheckInListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCheckInListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCheckInListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionCheckInListRespMultiError(errors)
	}

	return nil
}

// CollectionCheckInListRespMultiError is an error wrapping multiple validation
// errors returned by CollectionCheckInListResp.ValidateAll() if the
// designated constraints aren't met.
type CollectionCheckInListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCheckInListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCheckInListRespMultiError) AllErrors() []error { return m }

// CollectionCheckInListRespValidationError is the validation error returned by
// CollectionCheckInListResp.Validate if the designated constraints aren't met.
type CollectionCheckInListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCheckInListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCheckInListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCheckInListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCheckInListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCheckInListRespValidationError) ErrorName() string {
	return "CollectionCheckInListRespValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCheckInListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCheckInListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCheckInListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCheckInListRespValidationError{}

// Validate checks the field values on CollectionCheckInInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCheckInInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCheckInInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCheckInInfoMultiError, or nil if none found.
func (m *CollectionCheckInInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCheckInInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CollectionId

	// no validation rules for TokenId

	// no validation rules for CheckinScene

	// no validation rules for CheckinTime

	// no validation rules for AppNo

	// no validation rules for UserUid

	// no validation rules for UserUidName

	// no validation rules for UserAddress

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return CollectionCheckInInfoMultiError(errors)
	}

	return nil
}

// CollectionCheckInInfoMultiError is an error wrapping multiple validation
// errors returned by CollectionCheckInInfo.ValidateAll() if the designated
// constraints aren't met.
type CollectionCheckInInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCheckInInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCheckInInfoMultiError) AllErrors() []error { return m }

// CollectionCheckInInfoValidationError is the validation error returned by
// CollectionCheckInInfo.Validate if the designated constraints aren't met.
type CollectionCheckInInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCheckInInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCheckInInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCheckInInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCheckInInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCheckInInfoValidationError) ErrorName() string {
	return "CollectionCheckInInfoValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCheckInInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCheckInInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCheckInInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCheckInInfoValidationError{}

// Validate checks the field values on CollectionClaimCreateResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionClaimCreateResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionClaimCreateResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionClaimCreateResp_DataMultiError, or nil if none found.
func (m *CollectionClaimCreateResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionClaimCreateResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenId

	// no validation rules for DidCredential

	// no validation rules for CopyrightCredential

	// no validation rules for AuthorizationCredential

	// no validation rules for CollectionHash

	// no validation rules for From

	if len(errors) > 0 {
		return CollectionClaimCreateResp_DataMultiError(errors)
	}

	return nil
}

// CollectionClaimCreateResp_DataMultiError is an error wrapping multiple
// validation errors returned by CollectionClaimCreateResp_Data.ValidateAll()
// if the designated constraints aren't met.
type CollectionClaimCreateResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionClaimCreateResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionClaimCreateResp_DataMultiError) AllErrors() []error { return m }

// CollectionClaimCreateResp_DataValidationError is the validation error
// returned by CollectionClaimCreateResp_Data.Validate if the designated
// constraints aren't met.
type CollectionClaimCreateResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionClaimCreateResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionClaimCreateResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionClaimCreateResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionClaimCreateResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionClaimCreateResp_DataValidationError) ErrorName() string {
	return "CollectionClaimCreateResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionClaimCreateResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionClaimCreateResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionClaimCreateResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionClaimCreateResp_DataValidationError{}

// Validate checks the field values on CollectionCreateResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCreateResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCreateResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCreateResp_DataMultiError, or nil if none found.
func (m *CollectionCreateResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCreateResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	// no validation rules for CollectionCredential

	if len(errors) > 0 {
		return CollectionCreateResp_DataMultiError(errors)
	}

	return nil
}

// CollectionCreateResp_DataMultiError is an error wrapping multiple validation
// errors returned by CollectionCreateResp_Data.ValidateAll() if the
// designated constraints aren't met.
type CollectionCreateResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCreateResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCreateResp_DataMultiError) AllErrors() []error { return m }

// CollectionCreateResp_DataValidationError is the validation error returned by
// CollectionCreateResp_Data.Validate if the designated constraints aren't met.
type CollectionCreateResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCreateResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCreateResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCreateResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCreateResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCreateResp_DataValidationError) ErrorName() string {
	return "CollectionCreateResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCreateResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCreateResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCreateResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCreateResp_DataValidationError{}

// Validate checks the field values on CollectionBatchCreateResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionBatchCreateResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionBatchCreateResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionBatchCreateResp_DataMultiError, or nil if none found.
func (m *CollectionBatchCreateResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionBatchCreateResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionBid

	if len(errors) > 0 {
		return CollectionBatchCreateResp_DataMultiError(errors)
	}

	return nil
}

// CollectionBatchCreateResp_DataMultiError is an error wrapping multiple
// validation errors returned by CollectionBatchCreateResp_Data.ValidateAll()
// if the designated constraints aren't met.
type CollectionBatchCreateResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionBatchCreateResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionBatchCreateResp_DataMultiError) AllErrors() []error { return m }

// CollectionBatchCreateResp_DataValidationError is the validation error
// returned by CollectionBatchCreateResp_Data.Validate if the designated
// constraints aren't met.
type CollectionBatchCreateResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionBatchCreateResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionBatchCreateResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionBatchCreateResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionBatchCreateResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionBatchCreateResp_DataValidationError) ErrorName() string {
	return "CollectionBatchCreateResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionBatchCreateResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionBatchCreateResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionBatchCreateResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionBatchCreateResp_DataValidationError{}

// Validate checks the field values on CollectionLightCreateResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionLightCreateResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionLightCreateResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionLightCreateResp_DataMultiError, or nil if none found.
func (m *CollectionLightCreateResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionLightCreateResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionBid

	if len(errors) > 0 {
		return CollectionLightCreateResp_DataMultiError(errors)
	}

	return nil
}

// CollectionLightCreateResp_DataMultiError is an error wrapping multiple
// validation errors returned by CollectionLightCreateResp_Data.ValidateAll()
// if the designated constraints aren't met.
type CollectionLightCreateResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionLightCreateResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionLightCreateResp_DataMultiError) AllErrors() []error { return m }

// CollectionLightCreateResp_DataValidationError is the validation error
// returned by CollectionLightCreateResp_Data.Validate if the designated
// constraints aren't met.
type CollectionLightCreateResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionLightCreateResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionLightCreateResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionLightCreateResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionLightCreateResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionLightCreateResp_DataValidationError) ErrorName() string {
	return "CollectionLightCreateResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionLightCreateResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionLightCreateResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionLightCreateResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionLightCreateResp_DataValidationError{}

// Validate checks the field values on CollectionListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionListResp_DataMultiError, or nil if none found.
func (m *CollectionListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CollectionListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CollectionListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CollectionListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CollectionListResp_DataMultiError(errors)
	}

	return nil
}

// CollectionListResp_DataMultiError is an error wrapping multiple validation
// errors returned by CollectionListResp_Data.ValidateAll() if the designated
// constraints aren't met.
type CollectionListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionListResp_DataMultiError) AllErrors() []error { return m }

// CollectionListResp_DataValidationError is the validation error returned by
// CollectionListResp_Data.Validate if the designated constraints aren't met.
type CollectionListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionListResp_DataValidationError) ErrorName() string {
	return "CollectionListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionListResp_DataValidationError{}

// Validate checks the field values on CollectionTransactionResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionTransactionResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTransactionResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionTransactionResp_DataMultiError, or nil if none found.
func (m *CollectionTransactionResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTransactionResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for TransactionCredential

	if len(errors) > 0 {
		return CollectionTransactionResp_DataMultiError(errors)
	}

	return nil
}

// CollectionTransactionResp_DataMultiError is an error wrapping multiple
// validation errors returned by CollectionTransactionResp_Data.ValidateAll()
// if the designated constraints aren't met.
type CollectionTransactionResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTransactionResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTransactionResp_DataMultiError) AllErrors() []error { return m }

// CollectionTransactionResp_DataValidationError is the validation error
// returned by CollectionTransactionResp_Data.Validate if the designated
// constraints aren't met.
type CollectionTransactionResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTransactionResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTransactionResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTransactionResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTransactionResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTransactionResp_DataValidationError) ErrorName() string {
	return "CollectionTransactionResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTransactionResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTransactionResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTransactionResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTransactionResp_DataValidationError{}

// Validate checks the field values on CollectionLightTransactionResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CollectionLightTransactionResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionLightTransactionResp_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CollectionLightTransactionResp_DataMultiError, or nil if none found.
func (m *CollectionLightTransactionResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionLightTransactionResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionBid

	if len(errors) > 0 {
		return CollectionLightTransactionResp_DataMultiError(errors)
	}

	return nil
}

// CollectionLightTransactionResp_DataMultiError is an error wrapping multiple
// validation errors returned by
// CollectionLightTransactionResp_Data.ValidateAll() if the designated
// constraints aren't met.
type CollectionLightTransactionResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionLightTransactionResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionLightTransactionResp_DataMultiError) AllErrors() []error { return m }

// CollectionLightTransactionResp_DataValidationError is the validation error
// returned by CollectionLightTransactionResp_Data.Validate if the designated
// constraints aren't met.
type CollectionLightTransactionResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionLightTransactionResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionLightTransactionResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionLightTransactionResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionLightTransactionResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionLightTransactionResp_DataValidationError) ErrorName() string {
	return "CollectionLightTransactionResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionLightTransactionResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionLightTransactionResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionLightTransactionResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionLightTransactionResp_DataValidationError{}

// Validate checks the field values on CollectionTransactionClaimResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CollectionTransactionClaimResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTransactionClaimResp_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CollectionTransactionClaimResp_DataMultiError, or nil if none found.
func (m *CollectionTransactionClaimResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTransactionClaimResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDidCredential()) < 1 {
		err := CollectionTransactionClaimResp_DataValidationError{
			field:  "DidCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCopyrightCredential()) < 1 {
		err := CollectionTransactionClaimResp_DataValidationError{
			field:  "CopyrightCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizationCredential()) < 1 {
		err := CollectionTransactionClaimResp_DataValidationError{
			field:  "AuthorizationCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCollectionCredential()) < 1 {
		err := CollectionTransactionClaimResp_DataValidationError{
			field:  "CollectionCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPreviousTransactionCredential()) < 1 {
		err := CollectionTransactionClaimResp_DataValidationError{
			field:  "PreviousTransactionCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CollectionHash

	// no validation rules for TokenId

	if utf8.RuneCountInString(m.GetFrom()) < 1 {
		err := CollectionTransactionClaimResp_DataValidationError{
			field:  "From",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CollectionTransactionClaimResp_DataMultiError(errors)
	}

	return nil
}

// CollectionTransactionClaimResp_DataMultiError is an error wrapping multiple
// validation errors returned by
// CollectionTransactionClaimResp_Data.ValidateAll() if the designated
// constraints aren't met.
type CollectionTransactionClaimResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTransactionClaimResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTransactionClaimResp_DataMultiError) AllErrors() []error { return m }

// CollectionTransactionClaimResp_DataValidationError is the validation error
// returned by CollectionTransactionClaimResp_Data.Validate if the designated
// constraints aren't met.
type CollectionTransactionClaimResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTransactionClaimResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTransactionClaimResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTransactionClaimResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTransactionClaimResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTransactionClaimResp_DataValidationError) ErrorName() string {
	return "CollectionTransactionClaimResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTransactionClaimResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTransactionClaimResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTransactionClaimResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTransactionClaimResp_DataValidationError{}

// Validate checks the field values on CollectionCheckInResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCheckInResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCheckInResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCheckInResp_DataMultiError, or nil if none found.
func (m *CollectionCheckInResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCheckInResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CollectionCheckInResp_DataMultiError(errors)
	}

	return nil
}

// CollectionCheckInResp_DataMultiError is an error wrapping multiple
// validation errors returned by CollectionCheckInResp_Data.ValidateAll() if
// the designated constraints aren't met.
type CollectionCheckInResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCheckInResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCheckInResp_DataMultiError) AllErrors() []error { return m }

// CollectionCheckInResp_DataValidationError is the validation error returned
// by CollectionCheckInResp_Data.Validate if the designated constraints aren't met.
type CollectionCheckInResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCheckInResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCheckInResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCheckInResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCheckInResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCheckInResp_DataValidationError) ErrorName() string {
	return "CollectionCheckInResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCheckInResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCheckInResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCheckInResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCheckInResp_DataValidationError{}

// Validate checks the field values on CollectionCheckInListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCheckInListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCheckInListResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionCheckInListResp_DataMultiError, or nil if none found.
func (m *CollectionCheckInListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCheckInListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CollectionCheckInListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CollectionCheckInListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CollectionCheckInListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CollectionCheckInListResp_DataMultiError(errors)
	}

	return nil
}

// CollectionCheckInListResp_DataMultiError is an error wrapping multiple
// validation errors returned by CollectionCheckInListResp_Data.ValidateAll()
// if the designated constraints aren't met.
type CollectionCheckInListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCheckInListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCheckInListResp_DataMultiError) AllErrors() []error { return m }

// CollectionCheckInListResp_DataValidationError is the validation error
// returned by CollectionCheckInListResp_Data.Validate if the designated
// constraints aren't met.
type CollectionCheckInListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCheckInListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCheckInListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCheckInListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCheckInListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCheckInListResp_DataValidationError) ErrorName() string {
	return "CollectionCheckInListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCheckInListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCheckInListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCheckInListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCheckInListResp_DataValidationError{}
