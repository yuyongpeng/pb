// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pb/dassetpb/copyrightnew.proto

package dassetpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CopyrightRegisterReqNew with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightRegisterReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightRegisterReqNew with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightRegisterReqNewMultiError, or nil if none found.
func (m *CopyrightRegisterReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightRegisterReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CopyrightRegisterReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CopyrightType

	if utf8.RuneCountInString(m.GetCopyrightTitle()) < 1 {
		err := CopyrightRegisterReqNewValidationError{
			field:  "CopyrightTitle",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) < 1 {
		err := CopyrightRegisterReqNewValidationError{
			field:  "Creator",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAttachUrl()) < 1 {
		err := CopyrightRegisterReqNewValidationError{
			field:  "AttachUrl",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreativeTime

	// no validation rules for IsOriginal

	// no validation rules for Remarks

	if len(errors) > 0 {
		return CopyrightRegisterReqNewMultiError(errors)
	}

	return nil
}

// CopyrightRegisterReqNewMultiError is an error wrapping multiple validation
// errors returned by CopyrightRegisterReqNew.ValidateAll() if the designated
// constraints aren't met.
type CopyrightRegisterReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightRegisterReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightRegisterReqNewMultiError) AllErrors() []error { return m }

// CopyrightRegisterReqNewValidationError is the validation error returned by
// CopyrightRegisterReqNew.Validate if the designated constraints aren't met.
type CopyrightRegisterReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightRegisterReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightRegisterReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightRegisterReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightRegisterReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightRegisterReqNewValidationError) ErrorName() string {
	return "CopyrightRegisterReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightRegisterReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightRegisterReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightRegisterReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightRegisterReqNewValidationError{}

// Validate checks the field values on CopyrightClaimAuthorizationReqNew with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CopyrightClaimAuthorizationReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimAuthorizationReqNew
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CopyrightClaimAuthorizationReqNewMultiError, or nil if none found.
func (m *CopyrightClaimAuthorizationReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimAuthorizationReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CopyrightClaimAuthorizationReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CopyrightType

	if utf8.RuneCountInString(m.GetCopyrightTitle()) < 1 {
		err := CopyrightClaimAuthorizationReqNewValidationError{
			field:  "CopyrightTitle",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreator()) < 1 {
		err := CopyrightClaimAuthorizationReqNewValidationError{
			field:  "Creator",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AttachUrl

	// no validation rules for CreativeTime

	// no validation rules for IsOriginal

	// no validation rules for Remarks

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if all {
		switch v := interface{}(m.GetCopyrightClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqNewValidationError{
					field:  "CopyrightClaim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqNewValidationError{
					field:  "CopyrightClaim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopyrightClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimAuthorizationReqNewValidationError{
				field:  "CopyrightClaim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCopyrightContract()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqNewValidationError{
					field:  "CopyrightContract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqNewValidationError{
					field:  "CopyrightContract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopyrightContract()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimAuthorizationReqNewValidationError{
				field:  "CopyrightContract",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCopyrightContractAuthorization()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqNewValidationError{
					field:  "CopyrightContractAuthorization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimAuthorizationReqNewValidationError{
					field:  "CopyrightContractAuthorization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopyrightContractAuthorization()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimAuthorizationReqNewValidationError{
				field:  "CopyrightContractAuthorization",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightClaimAuthorizationReqNewMultiError(errors)
	}

	return nil
}

// CopyrightClaimAuthorizationReqNewMultiError is an error wrapping multiple
// validation errors returned by
// CopyrightClaimAuthorizationReqNew.ValidateAll() if the designated
// constraints aren't met.
type CopyrightClaimAuthorizationReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimAuthorizationReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimAuthorizationReqNewMultiError) AllErrors() []error { return m }

// CopyrightClaimAuthorizationReqNewValidationError is the validation error
// returned by CopyrightClaimAuthorizationReqNew.Validate if the designated
// constraints aren't met.
type CopyrightClaimAuthorizationReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimAuthorizationReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimAuthorizationReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimAuthorizationReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimAuthorizationReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimAuthorizationReqNewValidationError) ErrorName() string {
	return "CopyrightClaimAuthorizationReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimAuthorizationReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimAuthorizationReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimAuthorizationReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimAuthorizationReqNewValidationError{}

// Validate checks the field values on CopyrightRegisterListReqNew with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightRegisterListReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightRegisterListReqNew with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightRegisterListReqNewMultiError, or nil if none found.
func (m *CopyrightRegisterListReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightRegisterListReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CopyrightRegisterListReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CopyrightTitle

	// no validation rules for CopyrightHash

	// no validation rules for CopyrightType

	// no validation rules for IsOriginal

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return CopyrightRegisterListReqNewMultiError(errors)
	}

	return nil
}

// CopyrightRegisterListReqNewMultiError is an error wrapping multiple
// validation errors returned by CopyrightRegisterListReqNew.ValidateAll() if
// the designated constraints aren't met.
type CopyrightRegisterListReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightRegisterListReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightRegisterListReqNewMultiError) AllErrors() []error { return m }

// CopyrightRegisterListReqNewValidationError is the validation error returned
// by CopyrightRegisterListReqNew.Validate if the designated constraints
// aren't met.
type CopyrightRegisterListReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightRegisterListReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightRegisterListReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightRegisterListReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightRegisterListReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightRegisterListReqNewValidationError) ErrorName() string {
	return "CopyrightRegisterListReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightRegisterListReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightRegisterListReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightRegisterListReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightRegisterListReqNewValidationError{}

// Validate checks the field values on CopyrightClaimAddReqNew with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimAddReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimAddReqNew with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimAddReqNewMultiError, or nil if none found.
func (m *CopyrightClaimAddReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimAddReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CopyrightClaimAddReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CopyrightId

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimAddReqNewValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimAddReqNewValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimAddReqNewValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Remarks

	if len(errors) > 0 {
		return CopyrightClaimAddReqNewMultiError(errors)
	}

	return nil
}

// CopyrightClaimAddReqNewMultiError is an error wrapping multiple validation
// errors returned by CopyrightClaimAddReqNew.ValidateAll() if the designated
// constraints aren't met.
type CopyrightClaimAddReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimAddReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimAddReqNewMultiError) AllErrors() []error { return m }

// CopyrightClaimAddReqNewValidationError is the validation error returned by
// CopyrightClaimAddReqNew.Validate if the designated constraints aren't met.
type CopyrightClaimAddReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimAddReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimAddReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimAddReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimAddReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimAddReqNewValidationError) ErrorName() string {
	return "CopyrightClaimAddReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimAddReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimAddReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimAddReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimAddReqNewValidationError{}

// Validate checks the field values on CopyrightClaimListReqNew with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimListReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimListReqNew with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimListReqNewMultiError, or nil if none found.
func (m *CopyrightClaimListReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimListReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CopyrightClaimListReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClaimTitle

	// no validation rules for CopyrightHash

	// no validation rules for Credential

	// no validation rules for RegisterAddress

	// no validation rules for ContractIds

	// no validation rules for AuditStatus

	// no validation rules for AuditTimeStart

	// no validation rules for AuditTimeEnd

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return CopyrightClaimListReqNewMultiError(errors)
	}

	return nil
}

// CopyrightClaimListReqNewMultiError is an error wrapping multiple validation
// errors returned by CopyrightClaimListReqNew.ValidateAll() if the designated
// constraints aren't met.
type CopyrightClaimListReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimListReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimListReqNewMultiError) AllErrors() []error { return m }

// CopyrightClaimListReqNewValidationError is the validation error returned by
// CopyrightClaimListReqNew.Validate if the designated constraints aren't met.
type CopyrightClaimListReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimListReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimListReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimListReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimListReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimListReqNewValidationError) ErrorName() string {
	return "CopyrightClaimListReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimListReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimListReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimListReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimListReqNewValidationError{}

// Validate checks the field values on AuthorizationClaimListReqNew with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizationClaimListReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizationClaimListReqNew with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizationClaimListReqNewMultiError, or nil if none found.
func (m *AuthorizationClaimListReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizationClaimListReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := AuthorizationClaimListReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AuthorizationId

	// no validation rules for CopyrightTitle

	// no validation rules for CopyrightHash

	// no validation rules for CopyrightType

	// no validation rules for IsOriginal

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return AuthorizationClaimListReqNewMultiError(errors)
	}

	return nil
}

// AuthorizationClaimListReqNewMultiError is an error wrapping multiple
// validation errors returned by AuthorizationClaimListReqNew.ValidateAll() if
// the designated constraints aren't met.
type AuthorizationClaimListReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationClaimListReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationClaimListReqNewMultiError) AllErrors() []error { return m }

// AuthorizationClaimListReqNewValidationError is the validation error returned
// by AuthorizationClaimListReqNew.Validate if the designated constraints
// aren't met.
type AuthorizationClaimListReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationClaimListReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationClaimListReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationClaimListReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationClaimListReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationClaimListReqNewValidationError) ErrorName() string {
	return "AuthorizationClaimListReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizationClaimListReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizationClaimListReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationClaimListReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationClaimListReqNewValidationError{}

// Validate checks the field values on CopyrightAuthorizationListReqNew with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CopyrightAuthorizationListReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightAuthorizationListReqNew with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CopyrightAuthorizationListReqNewMultiError, or nil if none found.
func (m *CopyrightAuthorizationListReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightAuthorizationListReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CopyrightAuthorizationListReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Credential

	// no validation rules for AuthorizationIds

	// no validation rules for ContractIds

	// no validation rules for AuthorizerUserAddress

	// no validation rules for AuthorizedUserAddress

	// no validation rules for AuthorizationCode

	if val := m.GetAuthorizationType(); val < 0 || val > 2 {
		err := CopyrightAuthorizationListReqNewValidationError{
			field:  "AuthorizationType",
			reason: "value must be inside range [0, 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return CopyrightAuthorizationListReqNewMultiError(errors)
	}

	return nil
}

// CopyrightAuthorizationListReqNewMultiError is an error wrapping multiple
// validation errors returned by
// CopyrightAuthorizationListReqNew.ValidateAll() if the designated
// constraints aren't met.
type CopyrightAuthorizationListReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightAuthorizationListReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightAuthorizationListReqNewMultiError) AllErrors() []error { return m }

// CopyrightAuthorizationListReqNewValidationError is the validation error
// returned by CopyrightAuthorizationListReqNew.Validate if the designated
// constraints aren't met.
type CopyrightAuthorizationListReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightAuthorizationListReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightAuthorizationListReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightAuthorizationListReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightAuthorizationListReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightAuthorizationListReqNewValidationError) ErrorName() string {
	return "CopyrightAuthorizationListReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightAuthorizationListReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightAuthorizationListReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightAuthorizationListReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightAuthorizationListReqNewValidationError{}

// Validate checks the field values on ContractCreateReqNew with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractCreateReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractCreateReqNew with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractCreateReqNewMultiError, or nil if none found.
func (m *ContractCreateReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractCreateReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := ContractCreateReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCopyrightClaimIds()) < 1 {
		err := ContractCreateReqNewValidationError{
			field:  "CopyrightClaimIds",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AuthorizedNumber

	if utf8.RuneCountInString(m.GetCopyrightCategory()) < 1 {
		err := ContractCreateReqNewValidationError{
			field:  "CopyrightCategory",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetContent()) < 1 {
		err := ContractCreateReqNewValidationError{
			field:  "Content",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ContractCreateReqNewMultiError(errors)
	}

	return nil
}

// ContractCreateReqNewMultiError is an error wrapping multiple validation
// errors returned by ContractCreateReqNew.ValidateAll() if the designated
// constraints aren't met.
type ContractCreateReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractCreateReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractCreateReqNewMultiError) AllErrors() []error { return m }

// ContractCreateReqNewValidationError is the validation error returned by
// ContractCreateReqNew.Validate if the designated constraints aren't met.
type ContractCreateReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractCreateReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractCreateReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractCreateReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractCreateReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractCreateReqNewValidationError) ErrorName() string {
	return "ContractCreateReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e ContractCreateReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractCreateReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractCreateReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractCreateReqNewValidationError{}

// Validate checks the field values on ContractAuthorizationReqNew with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractAuthorizationReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractAuthorizationReqNew with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractAuthorizationReqNewMultiError, or nil if none found.
func (m *ContractAuthorizationReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractAuthorizationReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetContractId() <= 0 {
		err := ContractAuthorizationReqNewValidationError{
			field:  "ContractId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizedAddress()) < 1 {
		err := ContractAuthorizationReqNewValidationError{
			field:  "AuthorizedAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizationContent()) < 1 {
		err := ContractAuthorizationReqNewValidationError{
			field:  "AuthorizationContent",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContractAuthorizationReqNewValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContractAuthorizationReqNewValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContractAuthorizationReqNewValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Remarks

	if m.GetUserId() <= 0 {
		err := ContractAuthorizationReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return ContractAuthorizationReqNewMultiError(errors)
	}

	return nil
}

// ContractAuthorizationReqNewMultiError is an error wrapping multiple
// validation errors returned by ContractAuthorizationReqNew.ValidateAll() if
// the designated constraints aren't met.
type ContractAuthorizationReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractAuthorizationReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractAuthorizationReqNewMultiError) AllErrors() []error { return m }

// ContractAuthorizationReqNewValidationError is the validation error returned
// by ContractAuthorizationReqNew.Validate if the designated constraints
// aren't met.
type ContractAuthorizationReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractAuthorizationReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractAuthorizationReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractAuthorizationReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractAuthorizationReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractAuthorizationReqNewValidationError) ErrorName() string {
	return "ContractAuthorizationReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e ContractAuthorizationReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractAuthorizationReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractAuthorizationReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractAuthorizationReqNewValidationError{}

// Validate checks the field values on ContractListReqNew with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractListReqNew) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractListReqNew with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractListReqNewMultiError, or nil if none found.
func (m *ContractListReqNew) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractListReqNew) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := ContractListReqNewValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ContractIds

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return ContractListReqNewMultiError(errors)
	}

	return nil
}

// ContractListReqNewMultiError is an error wrapping multiple validation errors
// returned by ContractListReqNew.ValidateAll() if the designated constraints
// aren't met.
type ContractListReqNewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractListReqNewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractListReqNewMultiError) AllErrors() []error { return m }

// ContractListReqNewValidationError is the validation error returned by
// ContractListReqNew.Validate if the designated constraints aren't met.
type ContractListReqNewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractListReqNewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractListReqNewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractListReqNewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractListReqNewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractListReqNewValidationError) ErrorName() string {
	return "ContractListReqNewValidationError"
}

// Error satisfies the builtin error interface
func (e ContractListReqNewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractListReqNew.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractListReqNewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractListReqNewValidationError{}
