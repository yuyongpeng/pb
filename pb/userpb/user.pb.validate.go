// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pb/userpb/user.proto

package userpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RegisterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterReqMultiError, or
// nil if none found.
func (m *RegisterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := RegisterReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 16 {
		err := RegisterReqValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetCode(); val <= 1000 || val >= 9999 {
		err := RegisterReqValidationError{
			field:  "Code",
			reason: "value must be inside range (1000, 9999)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterReqMultiError(errors)
	}

	return nil
}

// RegisterReqMultiError is an error wrapping multiple validation errors
// returned by RegisterReq.ValidateAll() if the designated constraints aren't met.
type RegisterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReqMultiError) AllErrors() []error { return m }

// RegisterReqValidationError is the validation error returned by
// RegisterReq.Validate if the designated constraints aren't met.
type RegisterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReqValidationError) ErrorName() string { return "RegisterReqValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReqValidationError{}

// Validate checks the field values on AuthLoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AuthLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthLoginReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthLoginReqMultiError, or
// nil if none found.
func (m *AuthLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := AuthLoginReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSign()) < 1 {
		err := AuthLoginReqValidationError{
			field:  "Sign",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNonce()) < 1 {
		err := AuthLoginReqValidationError{
			field:  "Nonce",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AuthLoginReqMultiError(errors)
	}

	return nil
}

// AuthLoginReqMultiError is an error wrapping multiple validation errors
// returned by AuthLoginReq.ValidateAll() if the designated constraints aren't met.
type AuthLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthLoginReqMultiError) AllErrors() []error { return m }

// AuthLoginReqValidationError is the validation error returned by
// AuthLoginReq.Validate if the designated constraints aren't met.
type AuthLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthLoginReqValidationError) ErrorName() string { return "AuthLoginReqValidationError" }

// Error satisfies the builtin error interface
func (e AuthLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthLoginReqValidationError{}

// Validate checks the field values on LoginReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReqMultiError, or nil
// if none found.
func (m *LoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := LoginReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Password

	if val := m.GetType(); val <= 0 || val >= 3 {
		err := LoginReqValidationError{
			field:  "Type",
			reason: "value must be inside range (0, 3)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Code

	if len(errors) > 0 {
		return LoginReqMultiError(errors)
	}

	return nil
}

// LoginReqMultiError is an error wrapping multiple validation errors returned
// by LoginReq.ValidateAll() if the designated constraints aren't met.
type LoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReqMultiError) AllErrors() []error { return m }

// LoginReqValidationError is the validation error returned by
// LoginReq.Validate if the designated constraints aren't met.
type LoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReqValidationError) ErrorName() string { return "LoginReqValidationError" }

// Error satisfies the builtin error interface
func (e LoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReqValidationError{}

// Validate checks the field values on LoginResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRespMultiError, or nil
// if none found.
func (m *LoginResp) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginRespMultiError(errors)
	}

	return nil
}

// LoginRespMultiError is an error wrapping multiple validation errors returned
// by LoginResp.ValidateAll() if the designated constraints aren't met.
type LoginRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRespMultiError) AllErrors() []error { return m }

// LoginRespValidationError is the validation error returned by
// LoginResp.Validate if the designated constraints aren't met.
type LoginRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRespValidationError) ErrorName() string { return "LoginRespValidationError" }

// Error satisfies the builtin error interface
func (e LoginRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRespValidationError{}

// Validate checks the field values on BindReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BindReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BindReqMultiError, or nil if none found.
func (m *BindReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BindReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := BindReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetCode(); val <= 1000 || val >= 9999 {
		err := BindReqValidationError{
			field:  "Code",
			reason: "value must be inside range (1000, 9999)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BindReqMultiError(errors)
	}

	return nil
}

// BindReqMultiError is an error wrapping multiple validation errors returned
// by BindReq.ValidateAll() if the designated constraints aren't met.
type BindReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindReqMultiError) AllErrors() []error { return m }

// BindReqValidationError is the validation error returned by BindReq.Validate
// if the designated constraints aren't met.
type BindReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindReqValidationError) ErrorName() string { return "BindReqValidationError" }

// Error satisfies the builtin error interface
func (e BindReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindReqValidationError{}

// Validate checks the field values on ChangePwdReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChangePwdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangePwdReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChangePwdReqMultiError, or
// nil if none found.
func (m *ChangePwdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangePwdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetOldPassword()); l < 6 || l > 16 {
		err := ChangePwdReqValidationError{
			field:  "OldPassword",
			reason: "value length must be between 6 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 16 {
		err := ChangePwdReqValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ChangePwdReqMultiError(errors)
	}

	return nil
}

// ChangePwdReqMultiError is an error wrapping multiple validation errors
// returned by ChangePwdReq.ValidateAll() if the designated constraints aren't met.
type ChangePwdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangePwdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangePwdReqMultiError) AllErrors() []error { return m }

// ChangePwdReqValidationError is the validation error returned by
// ChangePwdReq.Validate if the designated constraints aren't met.
type ChangePwdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangePwdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangePwdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangePwdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangePwdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangePwdReqValidationError) ErrorName() string { return "ChangePwdReqValidationError" }

// Error satisfies the builtin error interface
func (e ChangePwdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangePwdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangePwdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangePwdReqValidationError{}

// Validate checks the field values on SendSetPwdCodeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SendSetPwdCodeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendSetPwdCodeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendSetPwdCodeReqMultiError, or nil if none found.
func (m *SendSetPwdCodeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SendSetPwdCodeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetCodeType(); val < 0 || val > 1 {
		err := SendSetPwdCodeReqValidationError{
			field:  "CodeType",
			reason: "value must be inside range [0, 1]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for SourceType

	if len(errors) > 0 {
		return SendSetPwdCodeReqMultiError(errors)
	}

	return nil
}

// SendSetPwdCodeReqMultiError is an error wrapping multiple validation errors
// returned by SendSetPwdCodeReq.ValidateAll() if the designated constraints
// aren't met.
type SendSetPwdCodeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendSetPwdCodeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendSetPwdCodeReqMultiError) AllErrors() []error { return m }

// SendSetPwdCodeReqValidationError is the validation error returned by
// SendSetPwdCodeReq.Validate if the designated constraints aren't met.
type SendSetPwdCodeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendSetPwdCodeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendSetPwdCodeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendSetPwdCodeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendSetPwdCodeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendSetPwdCodeReqValidationError) ErrorName() string {
	return "SendSetPwdCodeReqValidationError"
}

// Error satisfies the builtin error interface
func (e SendSetPwdCodeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendSetPwdCodeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendSetPwdCodeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendSetPwdCodeReqValidationError{}

// Validate checks the field values on SetPwdReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetPwdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetPwdReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetPwdReqMultiError, or nil
// if none found.
func (m *SetPwdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetPwdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetCode(); val <= 1000 || val >= 9999 {
		err := SetPwdReqValidationError{
			field:  "Code",
			reason: "value must be inside range (1000, 9999)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetCodeType(); val < 0 || val > 1 {
		err := SetPwdReqValidationError{
			field:  "CodeType",
			reason: "value must be inside range [0, 1]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 16 {
		err := SetPwdReqValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SetPwdReqMultiError(errors)
	}

	return nil
}

// SetPwdReqMultiError is an error wrapping multiple validation errors returned
// by SetPwdReq.ValidateAll() if the designated constraints aren't met.
type SetPwdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetPwdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetPwdReqMultiError) AllErrors() []error { return m }

// SetPwdReqValidationError is the validation error returned by
// SetPwdReq.Validate if the designated constraints aren't met.
type SetPwdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetPwdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetPwdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetPwdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetPwdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetPwdReqValidationError) ErrorName() string { return "SetPwdReqValidationError" }

// Error satisfies the builtin error interface
func (e SetPwdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetPwdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetPwdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetPwdReqValidationError{}

// Validate checks the field values on ForgetPwdReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ForgetPwdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ForgetPwdReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ForgetPwdReqMultiError, or
// nil if none found.
func (m *ForgetPwdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ForgetPwdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) < 1 {
		err := ForgetPwdReqValidationError{
			field:  "Account",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetCode(); val <= 1000 || val >= 9999 {
		err := ForgetPwdReqValidationError{
			field:  "Code",
			reason: "value must be inside range (1000, 9999)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 16 {
		err := ForgetPwdReqValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ForgetPwdReqMultiError(errors)
	}

	return nil
}

// ForgetPwdReqMultiError is an error wrapping multiple validation errors
// returned by ForgetPwdReq.ValidateAll() if the designated constraints aren't met.
type ForgetPwdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForgetPwdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForgetPwdReqMultiError) AllErrors() []error { return m }

// ForgetPwdReqValidationError is the validation error returned by
// ForgetPwdReq.Validate if the designated constraints aren't met.
type ForgetPwdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForgetPwdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForgetPwdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForgetPwdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForgetPwdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForgetPwdReqValidationError) ErrorName() string { return "ForgetPwdReqValidationError" }

// Error satisfies the builtin error interface
func (e ForgetPwdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForgetPwdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForgetPwdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForgetPwdReqValidationError{}

// Validate checks the field values on AdminSetPwdReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AdminSetPwdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdminSetPwdReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AdminSetPwdReqMultiError,
// or nil if none found.
func (m *AdminSetPwdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AdminSetPwdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountId() < 0 {
		err := AdminSetPwdReqValidationError{
			field:  "AccountId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 16 {
		err := AdminSetPwdReqValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AdminSetPwdReqMultiError(errors)
	}

	return nil
}

// AdminSetPwdReqMultiError is an error wrapping multiple validation errors
// returned by AdminSetPwdReq.ValidateAll() if the designated constraints
// aren't met.
type AdminSetPwdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdminSetPwdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdminSetPwdReqMultiError) AllErrors() []error { return m }

// AdminSetPwdReqValidationError is the validation error returned by
// AdminSetPwdReq.Validate if the designated constraints aren't met.
type AdminSetPwdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdminSetPwdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdminSetPwdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdminSetPwdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdminSetPwdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdminSetPwdReqValidationError) ErrorName() string { return "AdminSetPwdReqValidationError" }

// Error satisfies the builtin error interface
func (e AdminSetPwdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdminSetPwdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdminSetPwdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdminSetPwdReqValidationError{}

// Validate checks the field values on ChangeStatusReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChangeStatusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeStatusReqMultiError, or nil if none found.
func (m *ChangeStatusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeStatusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() < 1 {
		err := ChangeStatusReqValidationError{
			field:  "Id",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetStatus(); val < 1 || val > 2 {
		err := ChangeStatusReqValidationError{
			field:  "Status",
			reason: "value must be inside range [1, 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ChangeStatusReqMultiError(errors)
	}

	return nil
}

// ChangeStatusReqMultiError is an error wrapping multiple validation errors
// returned by ChangeStatusReq.ValidateAll() if the designated constraints
// aren't met.
type ChangeStatusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeStatusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeStatusReqMultiError) AllErrors() []error { return m }

// ChangeStatusReqValidationError is the validation error returned by
// ChangeStatusReq.Validate if the designated constraints aren't met.
type ChangeStatusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeStatusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeStatusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeStatusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeStatusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeStatusReqValidationError) ErrorName() string { return "ChangeStatusReqValidationError" }

// Error satisfies the builtin error interface
func (e ChangeStatusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeStatusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeStatusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeStatusReqValidationError{}

// Validate checks the field values on ChangeCredential with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChangeCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeCredentialMultiError, or nil if none found.
func (m *ChangeCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountId() < 0 {
		err := ChangeCredentialValidationError{
			field:  "AccountId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCredential()) < 0 {
		err := ChangeCredentialValidationError{
			field:  "Credential",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ChangeCredentialMultiError(errors)
	}

	return nil
}

// ChangeCredentialMultiError is an error wrapping multiple validation errors
// returned by ChangeCredential.ValidateAll() if the designated constraints
// aren't met.
type ChangeCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeCredentialMultiError) AllErrors() []error { return m }

// ChangeCredentialValidationError is the validation error returned by
// ChangeCredential.Validate if the designated constraints aren't met.
type ChangeCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeCredentialValidationError) ErrorName() string { return "ChangeCredentialValidationError" }

// Error satisfies the builtin error interface
func (e ChangeCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeCredentialValidationError{}

// Validate checks the field values on RealNameReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RealNameReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealNameReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RealNameReqMultiError, or
// nil if none found.
func (m *RealNameReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RealNameReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetAccountType(); val <= 0 || val >= 3 {
		err := RealNameReqValidationError{
			field:  "AccountType",
			reason: "value must be inside range (0, 3)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRealName()) < 2 {
		err := RealNameReqValidationError{
			field:  "RealName",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ShortName

	if utf8.RuneCountInString(m.GetIdNo()) < 1 {
		err := RealNameReqValidationError{
			field:  "IdNo",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IdPhone

	// no validation rules for IdPhoneCode

	// no validation rules for IdPicFront

	// no validation rules for IdPicBack

	// no validation rules for IdPicHand

	// no validation rules for LicenseNo

	// no validation rules for LicensePic

	// no validation rules for LegalPersonName

	// no validation rules for ContactName

	// no validation rules for ContactPhone

	// no validation rules for ContactAddress

	// no validation rules for Logo

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RealNameReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RealNameReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RealNameReqValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DeveloperFlag

	if len(errors) > 0 {
		return RealNameReqMultiError(errors)
	}

	return nil
}

// RealNameReqMultiError is an error wrapping multiple validation errors
// returned by RealNameReq.ValidateAll() if the designated constraints aren't met.
type RealNameReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealNameReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealNameReqMultiError) AllErrors() []error { return m }

// RealNameReqValidationError is the validation error returned by
// RealNameReq.Validate if the designated constraints aren't met.
type RealNameReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealNameReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealNameReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealNameReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealNameReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealNameReqValidationError) ErrorName() string { return "RealNameReqValidationError" }

// Error satisfies the builtin error interface
func (e RealNameReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealNameReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealNameReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealNameReqValidationError{}

// Validate checks the field values on RealNameResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RealNameResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealNameResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RealNameRespMultiError, or
// nil if none found.
func (m *RealNameResp) ValidateAll() error {
	return m.validate(true)
}

func (m *RealNameResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RealNameRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RealNameRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RealNameRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RealNameRespMultiError(errors)
	}

	return nil
}

// RealNameRespMultiError is an error wrapping multiple validation errors
// returned by RealNameResp.ValidateAll() if the designated constraints aren't met.
type RealNameRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealNameRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealNameRespMultiError) AllErrors() []error { return m }

// RealNameRespValidationError is the validation error returned by
// RealNameResp.Validate if the designated constraints aren't met.
type RealNameRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealNameRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealNameRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealNameRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealNameRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealNameRespValidationError) ErrorName() string { return "RealNameRespValidationError" }

// Error satisfies the builtin error interface
func (e RealNameRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealNameResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealNameRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealNameRespValidationError{}

// Validate checks the field values on RealNameClaim with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RealNameClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealNameClaim with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RealNameClaimMultiError, or
// nil if none found.
func (m *RealNameClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *RealNameClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDidType()) < 1 {
		err := RealNameClaimValidationError{
			field:  "DidType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := RealNameClaimValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Profile

	// no validation rules for Address

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := RealNameClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return RealNameClaimMultiError(errors)
	}

	return nil
}

// RealNameClaimMultiError is an error wrapping multiple validation errors
// returned by RealNameClaim.ValidateAll() if the designated constraints
// aren't met.
type RealNameClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealNameClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealNameClaimMultiError) AllErrors() []error { return m }

// RealNameClaimValidationError is the validation error returned by
// RealNameClaim.Validate if the designated constraints aren't met.
type RealNameClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealNameClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealNameClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealNameClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealNameClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealNameClaimValidationError) ErrorName() string { return "RealNameClaimValidationError" }

// Error satisfies the builtin error interface
func (e RealNameClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealNameClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealNameClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealNameClaimValidationError{}

// Validate checks the field values on UserServiceBaseListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserServiceBaseListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserServiceBaseListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserServiceBaseListReqMultiError, or nil if none found.
func (m *UserServiceBaseListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserServiceBaseListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserIds

	// no validation rules for IsAll

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return UserServiceBaseListReqMultiError(errors)
	}

	return nil
}

// UserServiceBaseListReqMultiError is an error wrapping multiple validation
// errors returned by UserServiceBaseListReq.ValidateAll() if the designated
// constraints aren't met.
type UserServiceBaseListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserServiceBaseListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserServiceBaseListReqMultiError) AllErrors() []error { return m }

// UserServiceBaseListReqValidationError is the validation error returned by
// UserServiceBaseListReq.Validate if the designated constraints aren't met.
type UserServiceBaseListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserServiceBaseListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserServiceBaseListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserServiceBaseListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserServiceBaseListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserServiceBaseListReqValidationError) ErrorName() string {
	return "UserServiceBaseListReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserServiceBaseListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserServiceBaseListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserServiceBaseListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserServiceBaseListReqValidationError{}

// Validate checks the field values on UserServiceBaseListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserServiceBaseListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserServiceBaseListResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserServiceBaseListRespMultiError, or nil if none found.
func (m *UserServiceBaseListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserServiceBaseListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserServiceBaseListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserServiceBaseListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserServiceBaseListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserServiceBaseListRespMultiError(errors)
	}

	return nil
}

// UserServiceBaseListRespMultiError is an error wrapping multiple validation
// errors returned by UserServiceBaseListResp.ValidateAll() if the designated
// constraints aren't met.
type UserServiceBaseListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserServiceBaseListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserServiceBaseListRespMultiError) AllErrors() []error { return m }

// UserServiceBaseListRespValidationError is the validation error returned by
// UserServiceBaseListResp.Validate if the designated constraints aren't met.
type UserServiceBaseListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserServiceBaseListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserServiceBaseListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserServiceBaseListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserServiceBaseListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserServiceBaseListRespValidationError) ErrorName() string {
	return "UserServiceBaseListRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserServiceBaseListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserServiceBaseListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserServiceBaseListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserServiceBaseListRespValidationError{}

// Validate checks the field values on UserListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserListRespMultiError, or
// nil if none found.
func (m *UserListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserListRespMultiError(errors)
	}

	return nil
}

// UserListRespMultiError is an error wrapping multiple validation errors
// returned by UserListResp.ValidateAll() if the designated constraints aren't met.
type UserListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserListRespMultiError) AllErrors() []error { return m }

// UserListRespValidationError is the validation error returned by
// UserListResp.Validate if the designated constraints aren't met.
type UserListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserListRespValidationError) ErrorName() string { return "UserListRespValidationError" }

// Error satisfies the builtin error interface
func (e UserListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserListRespValidationError{}

// Validate checks the field values on UserInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoMultiError, or nil
// if none found.
func (m *UserInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for UserId

	// no validation rules for AppNo

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for RealName

	// no validation rules for ShortName

	// no validation rules for CertifyApplyTime

	// no validation rules for CertifyAuditTime

	// no validation rules for CertifyAuditStatus

	// no validation rules for CertifyRejectReason

	// no validation rules for CreatorApplyTime

	// no validation rules for CreatorAuditTime

	// no validation rules for CreatorAuditStatus

	// no validation rules for CreatorRejectReason

	// no validation rules for MerchantStatus

	// no validation rules for ChainStatus

	// no validation rules for ChainTime

	// no validation rules for ChainFailedReason

	// no validation rules for UserAddress

	// no validation rules for UserPrivateKey

	// no validation rules for Credential

	// no validation rules for AccountStatus

	// no validation rules for UserStatus

	// no validation rules for CreateTime

	if all {
		switch v := interface{}(m.GetUserCertificationInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "UserCertificationInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "UserCertificationInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserCertificationInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "UserCertificationInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DeveloperAuditStatus

	// no validation rules for DeveloperRejectReason

	// no validation rules for DeveloperContract

	if len(errors) > 0 {
		return UserInfoMultiError(errors)
	}

	return nil
}

// UserInfoMultiError is an error wrapping multiple validation errors returned
// by UserInfo.ValidateAll() if the designated constraints aren't met.
type UserInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoMultiError) AllErrors() []error { return m }

// UserInfoValidationError is the validation error returned by
// UserInfo.Validate if the designated constraints aren't met.
type UserInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoValidationError) ErrorName() string { return "UserInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoValidationError{}

// Validate checks the field values on UserCertificationInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCertificationInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCertificationInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCertificationInfoMultiError, or nil if none found.
func (m *UserCertificationInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCertificationInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdNo

	// no validation rules for IdPicFront

	// no validation rules for IdPicBack

	// no validation rules for IdPicHand

	// no validation rules for LicenseNo

	// no validation rules for LicensePic

	// no validation rules for LegalPersonName

	// no validation rules for ApplyMaterial

	// no validation rules for ContactName

	// no validation rules for ContactPhone

	// no validation rules for ContactAddress

	// no validation rules for Logo

	// no validation rules for IdPhone

	// no validation rules for AccountType

	// no validation rules for RealName

	// no validation rules for ShortName

	// no validation rules for ApplyTime

	// no validation rules for AuditTime

	// no validation rules for AuditStatus

	// no validation rules for RejectReason

	// no validation rules for Credential

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserCertificationInfoValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserCertificationInfoValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserCertificationInfoValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserCertificationInfoMultiError(errors)
	}

	return nil
}

// UserCertificationInfoMultiError is an error wrapping multiple validation
// errors returned by UserCertificationInfo.ValidateAll() if the designated
// constraints aren't met.
type UserCertificationInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCertificationInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCertificationInfoMultiError) AllErrors() []error { return m }

// UserCertificationInfoValidationError is the validation error returned by
// UserCertificationInfo.Validate if the designated constraints aren't met.
type UserCertificationInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCertificationInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCertificationInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCertificationInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCertificationInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCertificationInfoValidationError) ErrorName() string {
	return "UserCertificationInfoValidationError"
}

// Error satisfies the builtin error interface
func (e UserCertificationInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCertificationInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCertificationInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCertificationInfoValidationError{}

// Validate checks the field values on UserInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoReqMultiError, or
// nil if none found.
func (m *UserInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := UserInfoReqValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserInfoReqMultiError(errors)
	}

	return nil
}

// UserInfoReqMultiError is an error wrapping multiple validation errors
// returned by UserInfoReq.ValidateAll() if the designated constraints aren't met.
type UserInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoReqMultiError) AllErrors() []error { return m }

// UserInfoReqValidationError is the validation error returned by
// UserInfoReq.Validate if the designated constraints aren't met.
type UserInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoReqValidationError) ErrorName() string { return "UserInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoReqValidationError{}

// Validate checks the field values on UserInfoResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfoResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoRespMultiError, or
// nil if none found.
func (m *UserInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserInfoRespMultiError(errors)
	}

	return nil
}

// UserInfoRespMultiError is an error wrapping multiple validation errors
// returned by UserInfoResp.ValidateAll() if the designated constraints aren't met.
type UserInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoRespMultiError) AllErrors() []error { return m }

// UserInfoRespValidationError is the validation error returned by
// UserInfoResp.Validate if the designated constraints aren't met.
type UserInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoRespValidationError) ErrorName() string { return "UserInfoRespValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoRespValidationError{}

// Validate checks the field values on UserBaseInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserBaseInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserBaseInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserBaseInfoReqMultiError, or nil if none found.
func (m *UserBaseInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserBaseInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for UserAddress

	// no validation rules for AppNo

	// no validation rules for Mobile

	// no validation rules for Email

	if len(errors) > 0 {
		return UserBaseInfoReqMultiError(errors)
	}

	return nil
}

// UserBaseInfoReqMultiError is an error wrapping multiple validation errors
// returned by UserBaseInfoReq.ValidateAll() if the designated constraints
// aren't met.
type UserBaseInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserBaseInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserBaseInfoReqMultiError) AllErrors() []error { return m }

// UserBaseInfoReqValidationError is the validation error returned by
// UserBaseInfoReq.Validate if the designated constraints aren't met.
type UserBaseInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserBaseInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserBaseInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserBaseInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserBaseInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserBaseInfoReqValidationError) ErrorName() string { return "UserBaseInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e UserBaseInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserBaseInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserBaseInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserBaseInfoReqValidationError{}

// Validate checks the field values on UserBaseInfoResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserBaseInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserBaseInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserBaseInfoRespMultiError, or nil if none found.
func (m *UserBaseInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserBaseInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserBaseInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserBaseInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserBaseInfoRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserBaseInfoRespMultiError(errors)
	}

	return nil
}

// UserBaseInfoRespMultiError is an error wrapping multiple validation errors
// returned by UserBaseInfoResp.ValidateAll() if the designated constraints
// aren't met.
type UserBaseInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserBaseInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserBaseInfoRespMultiError) AllErrors() []error { return m }

// UserBaseInfoRespValidationError is the validation error returned by
// UserBaseInfoResp.Validate if the designated constraints aren't met.
type UserBaseInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserBaseInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserBaseInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserBaseInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserBaseInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserBaseInfoRespValidationError) ErrorName() string { return "UserBaseInfoRespValidationError" }

// Error satisfies the builtin error interface
func (e UserBaseInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserBaseInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserBaseInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserBaseInfoRespValidationError{}

// Validate checks the field values on UserBaseInfoListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserBaseInfoListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserBaseInfoListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserBaseInfoListReqMultiError, or nil if none found.
func (m *UserBaseInfoListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserBaseInfoListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserBaseInfoListReqMultiError(errors)
	}

	return nil
}

// UserBaseInfoListReqMultiError is an error wrapping multiple validation
// errors returned by UserBaseInfoListReq.ValidateAll() if the designated
// constraints aren't met.
type UserBaseInfoListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserBaseInfoListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserBaseInfoListReqMultiError) AllErrors() []error { return m }

// UserBaseInfoListReqValidationError is the validation error returned by
// UserBaseInfoListReq.Validate if the designated constraints aren't met.
type UserBaseInfoListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserBaseInfoListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserBaseInfoListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserBaseInfoListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserBaseInfoListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserBaseInfoListReqValidationError) ErrorName() string {
	return "UserBaseInfoListReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserBaseInfoListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserBaseInfoListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserBaseInfoListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserBaseInfoListReqValidationError{}

// Validate checks the field values on UserBaseInfoListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserBaseInfoListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserBaseInfoListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserBaseInfoListRespMultiError, or nil if none found.
func (m *UserBaseInfoListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserBaseInfoListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserBaseInfoListRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserBaseInfoListRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserBaseInfoListRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserBaseInfoListRespMultiError(errors)
	}

	return nil
}

// UserBaseInfoListRespMultiError is an error wrapping multiple validation
// errors returned by UserBaseInfoListResp.ValidateAll() if the designated
// constraints aren't met.
type UserBaseInfoListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserBaseInfoListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserBaseInfoListRespMultiError) AllErrors() []error { return m }

// UserBaseInfoListRespValidationError is the validation error returned by
// UserBaseInfoListResp.Validate if the designated constraints aren't met.
type UserBaseInfoListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserBaseInfoListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserBaseInfoListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserBaseInfoListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserBaseInfoListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserBaseInfoListRespValidationError) ErrorName() string {
	return "UserBaseInfoListRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserBaseInfoListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserBaseInfoListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserBaseInfoListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserBaseInfoListRespValidationError{}

// Validate checks the field values on UserBaseInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserBaseInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserBaseInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserBaseInfoMultiError, or
// nil if none found.
func (m *UserBaseInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserBaseInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for UserId

	// no validation rules for AppNo

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for RealName

	// no validation rules for ShortName

	// no validation rules for CertifyApplyTime

	// no validation rules for CertifyAuditTime

	// no validation rules for CertifyAuditStatus

	// no validation rules for CertifyRejectReason

	// no validation rules for CreatorApplyTime

	// no validation rules for CreatorAuditTime

	// no validation rules for CreatorAuditStatus

	// no validation rules for CreatorRejectReason

	// no validation rules for MerchantStatus

	// no validation rules for UserAddress

	// no validation rules for UserPrivateKey

	// no validation rules for AccountStatus

	// no validation rules for UserStatus

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return UserBaseInfoMultiError(errors)
	}

	return nil
}

// UserBaseInfoMultiError is an error wrapping multiple validation errors
// returned by UserBaseInfo.ValidateAll() if the designated constraints aren't met.
type UserBaseInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserBaseInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserBaseInfoMultiError) AllErrors() []error { return m }

// UserBaseInfoValidationError is the validation error returned by
// UserBaseInfo.Validate if the designated constraints aren't met.
type UserBaseInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserBaseInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserBaseInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserBaseInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserBaseInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserBaseInfoValidationError) ErrorName() string { return "UserBaseInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserBaseInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserBaseInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserBaseInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserBaseInfoValidationError{}

// Validate checks the field values on UserResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserRespMultiError, or nil
// if none found.
func (m *UserResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if len(errors) > 0 {
		return UserRespMultiError(errors)
	}

	return nil
}

// UserRespMultiError is an error wrapping multiple validation errors returned
// by UserResp.ValidateAll() if the designated constraints aren't met.
type UserRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRespMultiError) AllErrors() []error { return m }

// UserRespValidationError is the validation error returned by
// UserResp.Validate if the designated constraints aren't met.
type UserRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRespValidationError) ErrorName() string { return "UserRespValidationError" }

// Error satisfies the builtin error interface
func (e UserRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRespValidationError{}

// Validate checks the field values on CreatorApplyReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatorApplyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatorApplyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatorApplyReqMultiError, or nil if none found.
func (m *CreatorApplyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatorApplyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplyMaterial()) < 1 {
		err := CreatorApplyReqValidationError{
			field:  "ApplyMaterial",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreatorApplyReqMultiError(errors)
	}

	return nil
}

// CreatorApplyReqMultiError is an error wrapping multiple validation errors
// returned by CreatorApplyReq.ValidateAll() if the designated constraints
// aren't met.
type CreatorApplyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatorApplyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatorApplyReqMultiError) AllErrors() []error { return m }

// CreatorApplyReqValidationError is the validation error returned by
// CreatorApplyReq.Validate if the designated constraints aren't met.
type CreatorApplyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatorApplyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatorApplyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatorApplyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatorApplyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatorApplyReqValidationError) ErrorName() string { return "CreatorApplyReqValidationError" }

// Error satisfies the builtin error interface
func (e CreatorApplyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatorApplyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatorApplyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatorApplyReqValidationError{}

// Validate checks the field values on CreatorApplyResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatorApplyResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatorApplyResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatorApplyRespMultiError, or nil if none found.
func (m *CreatorApplyResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatorApplyResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatorApplyRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatorApplyRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatorApplyRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatorApplyRespMultiError(errors)
	}

	return nil
}

// CreatorApplyRespMultiError is an error wrapping multiple validation errors
// returned by CreatorApplyResp.ValidateAll() if the designated constraints
// aren't met.
type CreatorApplyRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatorApplyRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatorApplyRespMultiError) AllErrors() []error { return m }

// CreatorApplyRespValidationError is the validation error returned by
// CreatorApplyResp.Validate if the designated constraints aren't met.
type CreatorApplyRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatorApplyRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatorApplyRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatorApplyRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatorApplyRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatorApplyRespValidationError) ErrorName() string { return "CreatorApplyRespValidationError" }

// Error satisfies the builtin error interface
func (e CreatorApplyRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatorApplyResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatorApplyRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatorApplyRespValidationError{}

// Validate checks the field values on CreatorListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreatorListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatorListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreatorListReqMultiError,
// or nil if none found.
func (m *CreatorListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatorListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for AuditStatus

	// no validation rules for ApplyTimeStart

	// no validation rules for ApplyTimeEnd

	// no validation rules for AuditTimeStart

	// no validation rules for AuditTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return CreatorListReqMultiError(errors)
	}

	return nil
}

// CreatorListReqMultiError is an error wrapping multiple validation errors
// returned by CreatorListReq.ValidateAll() if the designated constraints
// aren't met.
type CreatorListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatorListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatorListReqMultiError) AllErrors() []error { return m }

// CreatorListReqValidationError is the validation error returned by
// CreatorListReq.Validate if the designated constraints aren't met.
type CreatorListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatorListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatorListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatorListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatorListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatorListReqValidationError) ErrorName() string { return "CreatorListReqValidationError" }

// Error satisfies the builtin error interface
func (e CreatorListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatorListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatorListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatorListReqValidationError{}

// Validate checks the field values on CreatorListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatorListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatorListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatorListRespMultiError, or nil if none found.
func (m *CreatorListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatorListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatorListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatorListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatorListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatorListRespMultiError(errors)
	}

	return nil
}

// CreatorListRespMultiError is an error wrapping multiple validation errors
// returned by CreatorListResp.ValidateAll() if the designated constraints
// aren't met.
type CreatorListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatorListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatorListRespMultiError) AllErrors() []error { return m }

// CreatorListRespValidationError is the validation error returned by
// CreatorListResp.Validate if the designated constraints aren't met.
type CreatorListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatorListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatorListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatorListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatorListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatorListRespValidationError) ErrorName() string { return "CreatorListRespValidationError" }

// Error satisfies the builtin error interface
func (e CreatorListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatorListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatorListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatorListRespValidationError{}

// Validate checks the field values on CreatorUserInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatorUserInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatorUserInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatorUserInfoMultiError, or nil if none found.
func (m *CreatorUserInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatorUserInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for RealName

	// no validation rules for ShortName

	// no validation rules for ApplyTime

	// no validation rules for AuditTime

	// no validation rules for AuditStatus

	// no validation rules for RejectReason

	// no validation rules for ApplyMaterial

	if len(errors) > 0 {
		return CreatorUserInfoMultiError(errors)
	}

	return nil
}

// CreatorUserInfoMultiError is an error wrapping multiple validation errors
// returned by CreatorUserInfo.ValidateAll() if the designated constraints
// aren't met.
type CreatorUserInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatorUserInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatorUserInfoMultiError) AllErrors() []error { return m }

// CreatorUserInfoValidationError is the validation error returned by
// CreatorUserInfo.Validate if the designated constraints aren't met.
type CreatorUserInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatorUserInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatorUserInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatorUserInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatorUserInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatorUserInfoValidationError) ErrorName() string { return "CreatorUserInfoValidationError" }

// Error satisfies the builtin error interface
func (e CreatorUserInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatorUserInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatorUserInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatorUserInfoValidationError{}

// Validate checks the field values on CreatorAuditReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatorAuditReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatorAuditReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatorAuditReqMultiError, or nil if none found.
func (m *CreatorAuditReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatorAuditReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() < 1 {
		err := CreatorAuditReqValidationError{
			field:  "Id",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetStatus(); val < 1 || val > 2 {
		err := CreatorAuditReqValidationError{
			field:  "Status",
			reason: "value must be inside range [1, 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RejectReason

	if len(errors) > 0 {
		return CreatorAuditReqMultiError(errors)
	}

	return nil
}

// CreatorAuditReqMultiError is an error wrapping multiple validation errors
// returned by CreatorAuditReq.ValidateAll() if the designated constraints
// aren't met.
type CreatorAuditReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatorAuditReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatorAuditReqMultiError) AllErrors() []error { return m }

// CreatorAuditReqValidationError is the validation error returned by
// CreatorAuditReq.Validate if the designated constraints aren't met.
type CreatorAuditReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatorAuditReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatorAuditReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatorAuditReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatorAuditReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatorAuditReqValidationError) ErrorName() string { return "CreatorAuditReqValidationError" }

// Error satisfies the builtin error interface
func (e CreatorAuditReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatorAuditReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatorAuditReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatorAuditReqValidationError{}

// Validate checks the field values on UserAdminListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserAdminListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminListReqMultiError, or nil if none found.
func (m *UserAdminListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for Address

	// no validation rules for AppNo

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Status

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return UserAdminListReqMultiError(errors)
	}

	return nil
}

// UserAdminListReqMultiError is an error wrapping multiple validation errors
// returned by UserAdminListReq.ValidateAll() if the designated constraints
// aren't met.
type UserAdminListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminListReqMultiError) AllErrors() []error { return m }

// UserAdminListReqValidationError is the validation error returned by
// UserAdminListReq.Validate if the designated constraints aren't met.
type UserAdminListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminListReqValidationError) ErrorName() string { return "UserAdminListReqValidationError" }

// Error satisfies the builtin error interface
func (e UserAdminListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminListReqValidationError{}

// Validate checks the field values on UserAdminListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserAdminListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminListRespMultiError, or nil if none found.
func (m *UserAdminListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAdminListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAdminListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAdminListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserAdminListRespMultiError(errors)
	}

	return nil
}

// UserAdminListRespMultiError is an error wrapping multiple validation errors
// returned by UserAdminListResp.ValidateAll() if the designated constraints
// aren't met.
type UserAdminListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminListRespMultiError) AllErrors() []error { return m }

// UserAdminListRespValidationError is the validation error returned by
// UserAdminListResp.Validate if the designated constraints aren't met.
type UserAdminListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminListRespValidationError) ErrorName() string {
	return "UserAdminListRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminListRespValidationError{}

// Validate checks the field values on UserAdminInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserAdminInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserAdminInfoMultiError, or
// nil if none found.
func (m *UserAdminInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for UserId

	// no validation rules for AppNo

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for Address

	// no validation rules for Status

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return UserAdminInfoMultiError(errors)
	}

	return nil
}

// UserAdminInfoMultiError is an error wrapping multiple validation errors
// returned by UserAdminInfo.ValidateAll() if the designated constraints
// aren't met.
type UserAdminInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInfoMultiError) AllErrors() []error { return m }

// UserAdminInfoValidationError is the validation error returned by
// UserAdminInfo.Validate if the designated constraints aren't met.
type UserAdminInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInfoValidationError) ErrorName() string { return "UserAdminInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserAdminInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInfoValidationError{}

// Validate checks the field values on UserAccountAdminListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAccountAdminListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAccountAdminListReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAccountAdminListReqMultiError, or nil if none found.
func (m *UserAccountAdminListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAccountAdminListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for CertifyAuditStatus

	// no validation rules for CreatorAuditStatus

	// no validation rules for MerchantStatus

	// no validation rules for AccountType

	// no validation rules for AppNo

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Status

	// no validation rules for Page

	// no validation rules for Limit

	// no validation rules for DeveloperAuditStatusList

	if len(errors) > 0 {
		return UserAccountAdminListReqMultiError(errors)
	}

	return nil
}

// UserAccountAdminListReqMultiError is an error wrapping multiple validation
// errors returned by UserAccountAdminListReq.ValidateAll() if the designated
// constraints aren't met.
type UserAccountAdminListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAccountAdminListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAccountAdminListReqMultiError) AllErrors() []error { return m }

// UserAccountAdminListReqValidationError is the validation error returned by
// UserAccountAdminListReq.Validate if the designated constraints aren't met.
type UserAccountAdminListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAccountAdminListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAccountAdminListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAccountAdminListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAccountAdminListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAccountAdminListReqValidationError) ErrorName() string {
	return "UserAccountAdminListReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAccountAdminListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAccountAdminListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAccountAdminListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAccountAdminListReqValidationError{}

// Validate checks the field values on UserAccountAdminListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAccountAdminListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAccountAdminListResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAccountAdminListRespMultiError, or nil if none found.
func (m *UserAccountAdminListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAccountAdminListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAccountAdminListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAccountAdminListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAccountAdminListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserAccountAdminListRespMultiError(errors)
	}

	return nil
}

// UserAccountAdminListRespMultiError is an error wrapping multiple validation
// errors returned by UserAccountAdminListResp.ValidateAll() if the designated
// constraints aren't met.
type UserAccountAdminListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAccountAdminListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAccountAdminListRespMultiError) AllErrors() []error { return m }

// UserAccountAdminListRespValidationError is the validation error returned by
// UserAccountAdminListResp.Validate if the designated constraints aren't met.
type UserAccountAdminListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAccountAdminListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAccountAdminListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAccountAdminListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAccountAdminListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAccountAdminListRespValidationError) ErrorName() string {
	return "UserAccountAdminListRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAccountAdminListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAccountAdminListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAccountAdminListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAccountAdminListRespValidationError{}

// Validate checks the field values on UserAccountAdminInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAccountAdminInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAccountAdminInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAccountAdminInfoMultiError, or nil if none found.
func (m *UserAccountAdminInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAccountAdminInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for AppNo

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for CertifyAuditStatus

	// no validation rules for CreatorAuditStatus

	// no validation rules for MerchantStatus

	// no validation rules for DeveloperAuditStatus

	// no validation rules for DeveloperRejectReason

	// no validation rules for DeveloperAuditTime

	// no validation rules for CapitalBalance

	// no validation rules for PresentBalance

	// no validation rules for FrozenPaidAmount

	// no validation rules for FrozenPresentAmount

	// no validation rules for CredentialChainPrice

	// no validation rules for CollectionCastingPrice

	// no validation rules for CollectionOnlinePrice

	// no validation rules for CollectionOfflinePrice

	// no validation rules for CollectionTransferPrice

	// no validation rules for ApiCallPrice

	// no validation rules for Status

	// no validation rules for CreateTime

	if all {
		switch v := interface{}(m.GetCertInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAccountAdminInfoValidationError{
					field:  "CertInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAccountAdminInfoValidationError{
					field:  "CertInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCertInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAccountAdminInfoValidationError{
				field:  "CertInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserAccountAdminInfoMultiError(errors)
	}

	return nil
}

// UserAccountAdminInfoMultiError is an error wrapping multiple validation
// errors returned by UserAccountAdminInfo.ValidateAll() if the designated
// constraints aren't met.
type UserAccountAdminInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAccountAdminInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAccountAdminInfoMultiError) AllErrors() []error { return m }

// UserAccountAdminInfoValidationError is the validation error returned by
// UserAccountAdminInfo.Validate if the designated constraints aren't met.
type UserAccountAdminInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAccountAdminInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAccountAdminInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAccountAdminInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAccountAdminInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAccountAdminInfoValidationError) ErrorName() string {
	return "UserAccountAdminInfoValidationError"
}

// Error satisfies the builtin error interface
func (e UserAccountAdminInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAccountAdminInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAccountAdminInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAccountAdminInfoValidationError{}

// Validate checks the field values on UserIndexStatisticsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserIndexStatisticsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserIndexStatisticsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserIndexStatisticsReqMultiError, or nil if none found.
func (m *UserIndexStatisticsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserIndexStatisticsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserIndexStatisticsReqMultiError(errors)
	}

	return nil
}

// UserIndexStatisticsReqMultiError is an error wrapping multiple validation
// errors returned by UserIndexStatisticsReq.ValidateAll() if the designated
// constraints aren't met.
type UserIndexStatisticsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserIndexStatisticsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserIndexStatisticsReqMultiError) AllErrors() []error { return m }

// UserIndexStatisticsReqValidationError is the validation error returned by
// UserIndexStatisticsReq.Validate if the designated constraints aren't met.
type UserIndexStatisticsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserIndexStatisticsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserIndexStatisticsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserIndexStatisticsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserIndexStatisticsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserIndexStatisticsReqValidationError) ErrorName() string {
	return "UserIndexStatisticsReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserIndexStatisticsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserIndexStatisticsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserIndexStatisticsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserIndexStatisticsReqValidationError{}

// Validate checks the field values on UserIndexStatisticsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserIndexStatisticsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserIndexStatisticsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserIndexStatisticsRespMultiError, or nil if none found.
func (m *UserIndexStatisticsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserIndexStatisticsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserIndexStatisticsRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserIndexStatisticsRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserIndexStatisticsRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserIndexStatisticsRespMultiError(errors)
	}

	return nil
}

// UserIndexStatisticsRespMultiError is an error wrapping multiple validation
// errors returned by UserIndexStatisticsResp.ValidateAll() if the designated
// constraints aren't met.
type UserIndexStatisticsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserIndexStatisticsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserIndexStatisticsRespMultiError) AllErrors() []error { return m }

// UserIndexStatisticsRespValidationError is the validation error returned by
// UserIndexStatisticsResp.Validate if the designated constraints aren't met.
type UserIndexStatisticsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserIndexStatisticsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserIndexStatisticsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserIndexStatisticsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserIndexStatisticsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserIndexStatisticsRespValidationError) ErrorName() string {
	return "UserIndexStatisticsRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserIndexStatisticsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserIndexStatisticsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserIndexStatisticsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserIndexStatisticsRespValidationError{}

// Validate checks the field values on UserCapitalReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserCapitalReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserCapitalReqMultiError,
// or nil if none found.
func (m *UserCapitalReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserCapitalReqMultiError(errors)
	}

	return nil
}

// UserCapitalReqMultiError is an error wrapping multiple validation errors
// returned by UserCapitalReq.ValidateAll() if the designated constraints
// aren't met.
type UserCapitalReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalReqMultiError) AllErrors() []error { return m }

// UserCapitalReqValidationError is the validation error returned by
// UserCapitalReq.Validate if the designated constraints aren't met.
type UserCapitalReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalReqValidationError) ErrorName() string { return "UserCapitalReqValidationError" }

// Error satisfies the builtin error interface
func (e UserCapitalReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalReqValidationError{}

// Validate checks the field values on UserCapitalResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalRespMultiError, or nil if none found.
func (m *UserCapitalResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserCapitalRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserCapitalRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserCapitalRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserCapitalRespMultiError(errors)
	}

	return nil
}

// UserCapitalRespMultiError is an error wrapping multiple validation errors
// returned by UserCapitalResp.ValidateAll() if the designated constraints
// aren't met.
type UserCapitalRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalRespMultiError) AllErrors() []error { return m }

// UserCapitalRespValidationError is the validation error returned by
// UserCapitalResp.Validate if the designated constraints aren't met.
type UserCapitalRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalRespValidationError) ErrorName() string { return "UserCapitalRespValidationError" }

// Error satisfies the builtin error interface
func (e UserCapitalRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalRespValidationError{}

// Validate checks the field values on UserCapitalListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalListReqMultiError, or nil if none found.
func (m *UserCapitalListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for TradeNo

	if _, ok := _UserCapitalListReq_TransactionType_InLookup[m.GetTransactionType()]; !ok {
		err := UserCapitalListReqValidationError{
			field:  "TransactionType",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UserCapitalListReq_Status_InLookup[m.GetStatus()]; !ok {
		err := UserCapitalListReqValidationError{
			field:  "Status",
			reason: "value must be in list [0 1 2 3]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for Limit

	if _, ok := _UserCapitalListReq_TransactionMode_InLookup[m.GetTransactionMode()]; !ok {
		err := UserCapitalListReqValidationError{
			field:  "TransactionMode",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserCapitalListReqMultiError(errors)
	}

	return nil
}

// UserCapitalListReqMultiError is an error wrapping multiple validation errors
// returned by UserCapitalListReq.ValidateAll() if the designated constraints
// aren't met.
type UserCapitalListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalListReqMultiError) AllErrors() []error { return m }

// UserCapitalListReqValidationError is the validation error returned by
// UserCapitalListReq.Validate if the designated constraints aren't met.
type UserCapitalListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalListReqValidationError) ErrorName() string {
	return "UserCapitalListReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserCapitalListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalListReqValidationError{}

var _UserCapitalListReq_TransactionType_InLookup = map[uint32]struct{}{
	0: {},
	1: {},
	2: {},
}

var _UserCapitalListReq_Status_InLookup = map[uint32]struct{}{
	0: {},
	1: {},
	2: {},
	3: {},
}

var _UserCapitalListReq_TransactionMode_InLookup = map[uint32]struct{}{
	0: {},
	1: {},
	2: {},
}

// Validate checks the field values on UserCapitalListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalListRespMultiError, or nil if none found.
func (m *UserCapitalListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserCapitalListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserCapitalListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserCapitalListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserCapitalListRespMultiError(errors)
	}

	return nil
}

// UserCapitalListRespMultiError is an error wrapping multiple validation
// errors returned by UserCapitalListResp.ValidateAll() if the designated
// constraints aren't met.
type UserCapitalListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalListRespMultiError) AllErrors() []error { return m }

// UserCapitalListRespValidationError is the validation error returned by
// UserCapitalListResp.Validate if the designated constraints aren't met.
type UserCapitalListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalListRespValidationError) ErrorName() string {
	return "UserCapitalListRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserCapitalListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalListRespValidationError{}

// Validate checks the field values on UserCapitalInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalInfoMultiError, or nil if none found.
func (m *UserCapitalInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionType

	// no validation rules for TradeNo

	// no validation rules for Status

	// no validation rules for CreateTime

	// no validation rules for PaidAmount

	// no validation rules for PresentAmount

	// no validation rules for TransactionMode

	if len(errors) > 0 {
		return UserCapitalInfoMultiError(errors)
	}

	return nil
}

// UserCapitalInfoMultiError is an error wrapping multiple validation errors
// returned by UserCapitalInfo.ValidateAll() if the designated constraints
// aren't met.
type UserCapitalInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalInfoMultiError) AllErrors() []error { return m }

// UserCapitalInfoValidationError is the validation error returned by
// UserCapitalInfo.Validate if the designated constraints aren't met.
type UserCapitalInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalInfoValidationError) ErrorName() string { return "UserCapitalInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserCapitalInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalInfoValidationError{}

// Validate checks the field values on UserCapitalAllListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalAllListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalAllListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalAllListReqMultiError, or nil if none found.
func (m *UserCapitalAllListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalAllListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for TradeNo

	if _, ok := _UserCapitalAllListReq_TransactionType_InLookup[m.GetTransactionType()]; !ok {
		err := UserCapitalAllListReqValidationError{
			field:  "TransactionType",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UserCapitalAllListReq_Status_InLookup[m.GetStatus()]; !ok {
		err := UserCapitalAllListReqValidationError{
			field:  "Status",
			reason: "value must be in list [0 1 2 3]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for Limit

	if _, ok := _UserCapitalAllListReq_TransactionMode_InLookup[m.GetTransactionMode()]; !ok {
		err := UserCapitalAllListReqValidationError{
			field:  "TransactionMode",
			reason: "value must be in list [0 1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserCapitalAllListReqMultiError(errors)
	}

	return nil
}

// UserCapitalAllListReqMultiError is an error wrapping multiple validation
// errors returned by UserCapitalAllListReq.ValidateAll() if the designated
// constraints aren't met.
type UserCapitalAllListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalAllListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalAllListReqMultiError) AllErrors() []error { return m }

// UserCapitalAllListReqValidationError is the validation error returned by
// UserCapitalAllListReq.Validate if the designated constraints aren't met.
type UserCapitalAllListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalAllListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalAllListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalAllListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalAllListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalAllListReqValidationError) ErrorName() string {
	return "UserCapitalAllListReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserCapitalAllListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalAllListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalAllListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalAllListReqValidationError{}

var _UserCapitalAllListReq_TransactionType_InLookup = map[uint32]struct{}{
	0: {},
	1: {},
	2: {},
}

var _UserCapitalAllListReq_Status_InLookup = map[uint32]struct{}{
	0: {},
	1: {},
	2: {},
	3: {},
}

var _UserCapitalAllListReq_TransactionMode_InLookup = map[uint32]struct{}{
	0: {},
	1: {},
	2: {},
}

// Validate checks the field values on UserCapitalAllListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalAllListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalAllListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalAllListRespMultiError, or nil if none found.
func (m *UserCapitalAllListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalAllListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserCapitalAllListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserCapitalAllListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserCapitalAllListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserCapitalAllListRespMultiError(errors)
	}

	return nil
}

// UserCapitalAllListRespMultiError is an error wrapping multiple validation
// errors returned by UserCapitalAllListResp.ValidateAll() if the designated
// constraints aren't met.
type UserCapitalAllListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalAllListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalAllListRespMultiError) AllErrors() []error { return m }

// UserCapitalAllListRespValidationError is the validation error returned by
// UserCapitalAllListResp.Validate if the designated constraints aren't met.
type UserCapitalAllListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalAllListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalAllListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalAllListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalAllListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalAllListRespValidationError) ErrorName() string {
	return "UserCapitalAllListRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserCapitalAllListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalAllListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalAllListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalAllListRespValidationError{}

// Validate checks the field values on UserCapitalAllInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalAllInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalAllInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalAllInfoMultiError, or nil if none found.
func (m *UserCapitalAllInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalAllInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionType

	// no validation rules for TradeNo

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for PaidAmount

	// no validation rules for PresentAmount

	// no validation rules for Status

	// no validation rules for CreateTime

	// no validation rules for TransactionMode

	if len(errors) > 0 {
		return UserCapitalAllInfoMultiError(errors)
	}

	return nil
}

// UserCapitalAllInfoMultiError is an error wrapping multiple validation errors
// returned by UserCapitalAllInfo.ValidateAll() if the designated constraints
// aren't met.
type UserCapitalAllInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalAllInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalAllInfoMultiError) AllErrors() []error { return m }

// UserCapitalAllInfoValidationError is the validation error returned by
// UserCapitalAllInfo.Validate if the designated constraints aren't met.
type UserCapitalAllInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalAllInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalAllInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalAllInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalAllInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalAllInfoValidationError) ErrorName() string {
	return "UserCapitalAllInfoValidationError"
}

// Error satisfies the builtin error interface
func (e UserCapitalAllInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalAllInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalAllInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalAllInfoValidationError{}

// Validate checks the field values on UserFrozenCapitalItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserFrozenCapitalItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserFrozenCapitalItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserFrozenCapitalItemMultiError, or nil if none found.
func (m *UserFrozenCapitalItem) ValidateAll() error {
	return m.validate(true)
}

func (m *UserFrozenCapitalItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FrozenCapitalType

	// no validation rules for CalledApi

	// no validation rules for CalledNum

	if len(errors) > 0 {
		return UserFrozenCapitalItemMultiError(errors)
	}

	return nil
}

// UserFrozenCapitalItemMultiError is an error wrapping multiple validation
// errors returned by UserFrozenCapitalItem.ValidateAll() if the designated
// constraints aren't met.
type UserFrozenCapitalItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserFrozenCapitalItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserFrozenCapitalItemMultiError) AllErrors() []error { return m }

// UserFrozenCapitalItemValidationError is the validation error returned by
// UserFrozenCapitalItem.Validate if the designated constraints aren't met.
type UserFrozenCapitalItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserFrozenCapitalItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserFrozenCapitalItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserFrozenCapitalItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserFrozenCapitalItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserFrozenCapitalItemValidationError) ErrorName() string {
	return "UserFrozenCapitalItemValidationError"
}

// Error satisfies the builtin error interface
func (e UserFrozenCapitalItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserFrozenCapitalItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserFrozenCapitalItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserFrozenCapitalItemValidationError{}

// Validate checks the field values on UserFrozenCapitalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserFrozenCapitalReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserFrozenCapitalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserFrozenCapitalReqMultiError, or nil if none found.
func (m *UserFrozenCapitalReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserFrozenCapitalReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountId() <= 0 {
		err := UserFrozenCapitalReqValidationError{
			field:  "AccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserFrozenCapitalReqValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserFrozenCapitalReqValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserFrozenCapitalReqValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Checking

	// no validation rules for AppNo

	if len(errors) > 0 {
		return UserFrozenCapitalReqMultiError(errors)
	}

	return nil
}

// UserFrozenCapitalReqMultiError is an error wrapping multiple validation
// errors returned by UserFrozenCapitalReq.ValidateAll() if the designated
// constraints aren't met.
type UserFrozenCapitalReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserFrozenCapitalReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserFrozenCapitalReqMultiError) AllErrors() []error { return m }

// UserFrozenCapitalReqValidationError is the validation error returned by
// UserFrozenCapitalReq.Validate if the designated constraints aren't met.
type UserFrozenCapitalReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserFrozenCapitalReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserFrozenCapitalReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserFrozenCapitalReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserFrozenCapitalReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserFrozenCapitalReqValidationError) ErrorName() string {
	return "UserFrozenCapitalReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserFrozenCapitalReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserFrozenCapitalReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserFrozenCapitalReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserFrozenCapitalReqValidationError{}

// Validate checks the field values on UserFrozenCapitalResultItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserFrozenCapitalResultItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserFrozenCapitalResultItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserFrozenCapitalResultItemMultiError, or nil if none found.
func (m *UserFrozenCapitalResultItem) ValidateAll() error {
	return m.validate(true)
}

func (m *UserFrozenCapitalResultItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for TradeNo

	// no validation rules for FrozenCapitalType

	// no validation rules for CalledApi

	// no validation rules for CalledNum

	if len(errors) > 0 {
		return UserFrozenCapitalResultItemMultiError(errors)
	}

	return nil
}

// UserFrozenCapitalResultItemMultiError is an error wrapping multiple
// validation errors returned by UserFrozenCapitalResultItem.ValidateAll() if
// the designated constraints aren't met.
type UserFrozenCapitalResultItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserFrozenCapitalResultItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserFrozenCapitalResultItemMultiError) AllErrors() []error { return m }

// UserFrozenCapitalResultItemValidationError is the validation error returned
// by UserFrozenCapitalResultItem.Validate if the designated constraints
// aren't met.
type UserFrozenCapitalResultItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserFrozenCapitalResultItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserFrozenCapitalResultItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserFrozenCapitalResultItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserFrozenCapitalResultItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserFrozenCapitalResultItemValidationError) ErrorName() string {
	return "UserFrozenCapitalResultItemValidationError"
}

// Error satisfies the builtin error interface
func (e UserFrozenCapitalResultItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserFrozenCapitalResultItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserFrozenCapitalResultItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserFrozenCapitalResultItemValidationError{}

// Validate checks the field values on UserFrozenCapitalResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserFrozenCapitalResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserFrozenCapitalResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserFrozenCapitalRespMultiError, or nil if none found.
func (m *UserFrozenCapitalResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserFrozenCapitalResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserFrozenCapitalRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserFrozenCapitalRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserFrozenCapitalRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserFrozenCapitalRespMultiError(errors)
	}

	return nil
}

// UserFrozenCapitalRespMultiError is an error wrapping multiple validation
// errors returned by UserFrozenCapitalResp.ValidateAll() if the designated
// constraints aren't met.
type UserFrozenCapitalRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserFrozenCapitalRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserFrozenCapitalRespMultiError) AllErrors() []error { return m }

// UserFrozenCapitalRespValidationError is the validation error returned by
// UserFrozenCapitalResp.Validate if the designated constraints aren't met.
type UserFrozenCapitalRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserFrozenCapitalRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserFrozenCapitalRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserFrozenCapitalRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserFrozenCapitalRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserFrozenCapitalRespValidationError) ErrorName() string {
	return "UserFrozenCapitalRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserFrozenCapitalRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserFrozenCapitalResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserFrozenCapitalRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserFrozenCapitalRespValidationError{}

// Validate checks the field values on UserChainItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserChainItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserChainItemMultiError, or
// nil if none found.
func (m *UserChainItem) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FrozenCapitalType

	// no validation rules for CalledNum

	if len(errors) > 0 {
		return UserChainItemMultiError(errors)
	}

	return nil
}

// UserChainItemMultiError is an error wrapping multiple validation errors
// returned by UserChainItem.ValidateAll() if the designated constraints
// aren't met.
type UserChainItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainItemMultiError) AllErrors() []error { return m }

// UserChainItemValidationError is the validation error returned by
// UserChainItem.Validate if the designated constraints aren't met.
type UserChainItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainItemValidationError) ErrorName() string { return "UserChainItemValidationError" }

// Error satisfies the builtin error interface
func (e UserChainItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainItemValidationError{}

// Validate checks the field values on UserChainCostReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserChainCostReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainCostReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChainCostReqMultiError, or nil if none found.
func (m *UserChainCostReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainCostReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppNo

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserChainCostReqValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserChainCostReqValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserChainCostReqValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserChainCostReqMultiError(errors)
	}

	return nil
}

// UserChainCostReqMultiError is an error wrapping multiple validation errors
// returned by UserChainCostReq.ValidateAll() if the designated constraints
// aren't met.
type UserChainCostReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainCostReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainCostReqMultiError) AllErrors() []error { return m }

// UserChainCostReqValidationError is the validation error returned by
// UserChainCostReq.Validate if the designated constraints aren't met.
type UserChainCostReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainCostReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainCostReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainCostReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainCostReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainCostReqValidationError) ErrorName() string { return "UserChainCostReqValidationError" }

// Error satisfies the builtin error interface
func (e UserChainCostReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainCostReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainCostReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainCostReqValidationError{}

// Validate checks the field values on UserChainCostResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserChainCostResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainCostResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChainCostRespMultiError, or nil if none found.
func (m *UserChainCostResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainCostResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserChainCostRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserChainCostRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserChainCostRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserChainCostRespMultiError(errors)
	}

	return nil
}

// UserChainCostRespMultiError is an error wrapping multiple validation errors
// returned by UserChainCostResp.ValidateAll() if the designated constraints
// aren't met.
type UserChainCostRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainCostRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainCostRespMultiError) AllErrors() []error { return m }

// UserChainCostRespValidationError is the validation error returned by
// UserChainCostResp.Validate if the designated constraints aren't met.
type UserChainCostRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainCostRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainCostRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainCostRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainCostRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainCostRespValidationError) ErrorName() string {
	return "UserChainCostRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainCostRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainCostResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainCostRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainCostRespValidationError{}

// Validate checks the field values on UserChargeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserChargeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChargeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserChargeReqMultiError, or
// nil if none found.
func (m *UserChargeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChargeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountId() <= 0 {
		err := UserChargeReqValidationError{
			field:  "AccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAmount() <= 0 {
		err := UserChargeReqValidationError{
			field:  "Amount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserChargeReqMultiError(errors)
	}

	return nil
}

// UserChargeReqMultiError is an error wrapping multiple validation errors
// returned by UserChargeReq.ValidateAll() if the designated constraints
// aren't met.
type UserChargeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChargeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChargeReqMultiError) AllErrors() []error { return m }

// UserChargeReqValidationError is the validation error returned by
// UserChargeReq.Validate if the designated constraints aren't met.
type UserChargeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChargeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChargeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChargeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChargeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChargeReqValidationError) ErrorName() string { return "UserChargeReqValidationError" }

// Error satisfies the builtin error interface
func (e UserChargeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChargeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChargeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChargeReqValidationError{}

// Validate checks the field values on UserChargeResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserChargeResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChargeResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserChargeRespMultiError,
// or nil if none found.
func (m *UserChargeResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChargeResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserChargeRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserChargeRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserChargeRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserChargeRespMultiError(errors)
	}

	return nil
}

// UserChargeRespMultiError is an error wrapping multiple validation errors
// returned by UserChargeResp.ValidateAll() if the designated constraints
// aren't met.
type UserChargeRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChargeRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChargeRespMultiError) AllErrors() []error { return m }

// UserChargeRespValidationError is the validation error returned by
// UserChargeResp.Validate if the designated constraints aren't met.
type UserChargeRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChargeRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChargeRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChargeRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChargeRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChargeRespValidationError) ErrorName() string { return "UserChargeRespValidationError" }

// Error satisfies the builtin error interface
func (e UserChargeRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChargeResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChargeRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChargeRespValidationError{}

// Validate checks the field values on UserChargeChangeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChargeChangeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChargeChangeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChargeChangeReqMultiError, or nil if none found.
func (m *UserChargeChangeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChargeChangeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeNo

	// no validation rules for Status

	// no validation rules for PresentAmount

	if len(errors) > 0 {
		return UserChargeChangeReqMultiError(errors)
	}

	return nil
}

// UserChargeChangeReqMultiError is an error wrapping multiple validation
// errors returned by UserChargeChangeReq.ValidateAll() if the designated
// constraints aren't met.
type UserChargeChangeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChargeChangeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChargeChangeReqMultiError) AllErrors() []error { return m }

// UserChargeChangeReqValidationError is the validation error returned by
// UserChargeChangeReq.Validate if the designated constraints aren't met.
type UserChargeChangeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChargeChangeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChargeChangeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChargeChangeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChargeChangeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChargeChangeReqValidationError) ErrorName() string {
	return "UserChargeChangeReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserChargeChangeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChargeChangeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChargeChangeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChargeChangeReqValidationError{}

// Validate checks the field values on UserChargeStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChargeStatusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChargeStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChargeStatusReqMultiError, or nil if none found.
func (m *UserChargeStatusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChargeStatusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for TradeNo

	if len(errors) > 0 {
		return UserChargeStatusReqMultiError(errors)
	}

	return nil
}

// UserChargeStatusReqMultiError is an error wrapping multiple validation
// errors returned by UserChargeStatusReq.ValidateAll() if the designated
// constraints aren't met.
type UserChargeStatusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChargeStatusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChargeStatusReqMultiError) AllErrors() []error { return m }

// UserChargeStatusReqValidationError is the validation error returned by
// UserChargeStatusReq.Validate if the designated constraints aren't met.
type UserChargeStatusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChargeStatusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChargeStatusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChargeStatusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChargeStatusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChargeStatusReqValidationError) ErrorName() string {
	return "UserChargeStatusReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserChargeStatusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChargeStatusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChargeStatusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChargeStatusReqValidationError{}

// Validate checks the field values on UserChargeStatusResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChargeStatusResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChargeStatusResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChargeStatusRespMultiError, or nil if none found.
func (m *UserChargeStatusResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChargeStatusResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserChargeStatusRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserChargeStatusRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserChargeStatusRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserChargeStatusRespMultiError(errors)
	}

	return nil
}

// UserChargeStatusRespMultiError is an error wrapping multiple validation
// errors returned by UserChargeStatusResp.ValidateAll() if the designated
// constraints aren't met.
type UserChargeStatusRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChargeStatusRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChargeStatusRespMultiError) AllErrors() []error { return m }

// UserChargeStatusRespValidationError is the validation error returned by
// UserChargeStatusResp.Validate if the designated constraints aren't met.
type UserChargeStatusRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChargeStatusRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChargeStatusRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChargeStatusRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChargeStatusRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChargeStatusRespValidationError) ErrorName() string {
	return "UserChargeStatusRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserChargeStatusRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChargeStatusResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChargeStatusRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChargeStatusRespValidationError{}

// Validate checks the field values on UserUnFrozenCapitalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserUnFrozenCapitalReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserUnFrozenCapitalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserUnFrozenCapitalReqMultiError, or nil if none found.
func (m *UserUnFrozenCapitalReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserUnFrozenCapitalReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := UserUnFrozenCapitalReqValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Status

	if len(errors) > 0 {
		return UserUnFrozenCapitalReqMultiError(errors)
	}

	return nil
}

// UserUnFrozenCapitalReqMultiError is an error wrapping multiple validation
// errors returned by UserUnFrozenCapitalReq.ValidateAll() if the designated
// constraints aren't met.
type UserUnFrozenCapitalReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserUnFrozenCapitalReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserUnFrozenCapitalReqMultiError) AllErrors() []error { return m }

// UserUnFrozenCapitalReqValidationError is the validation error returned by
// UserUnFrozenCapitalReq.Validate if the designated constraints aren't met.
type UserUnFrozenCapitalReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserUnFrozenCapitalReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserUnFrozenCapitalReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserUnFrozenCapitalReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserUnFrozenCapitalReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserUnFrozenCapitalReqValidationError) ErrorName() string {
	return "UserUnFrozenCapitalReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserUnFrozenCapitalReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserUnFrozenCapitalReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserUnFrozenCapitalReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserUnFrozenCapitalReqValidationError{}

// Validate checks the field values on UserAccountChangePriceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAccountChangePriceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAccountChangePriceReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAccountChangePriceReqMultiError, or nil if none found.
func (m *UserAccountChangePriceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAccountChangePriceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountId() <= 0 {
		err := UserAccountChangePriceReqValidationError{
			field:  "AccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CredentialChainPrice

	// no validation rules for CollectionCastingPrice

	// no validation rules for CollectionOnlinePrice

	// no validation rules for CollectionOfflinePrice

	// no validation rules for CollectionTransferPrice

	// no validation rules for ApiCallPrice

	if len(errors) > 0 {
		return UserAccountChangePriceReqMultiError(errors)
	}

	return nil
}

// UserAccountChangePriceReqMultiError is an error wrapping multiple validation
// errors returned by UserAccountChangePriceReq.ValidateAll() if the
// designated constraints aren't met.
type UserAccountChangePriceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAccountChangePriceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAccountChangePriceReqMultiError) AllErrors() []error { return m }

// UserAccountChangePriceReqValidationError is the validation error returned by
// UserAccountChangePriceReq.Validate if the designated constraints aren't met.
type UserAccountChangePriceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAccountChangePriceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAccountChangePriceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAccountChangePriceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAccountChangePriceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAccountChangePriceReqValidationError) ErrorName() string {
	return "UserAccountChangePriceReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAccountChangePriceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAccountChangePriceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAccountChangePriceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAccountChangePriceReqValidationError{}

// Validate checks the field values on UserAccountInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAccountInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAccountInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAccountInfoReqMultiError, or nil if none found.
func (m *UserAccountInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAccountInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mobile

	// no validation rules for Email

	if len(errors) > 0 {
		return UserAccountInfoReqMultiError(errors)
	}

	return nil
}

// UserAccountInfoReqMultiError is an error wrapping multiple validation errors
// returned by UserAccountInfoReq.ValidateAll() if the designated constraints
// aren't met.
type UserAccountInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAccountInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAccountInfoReqMultiError) AllErrors() []error { return m }

// UserAccountInfoReqValidationError is the validation error returned by
// UserAccountInfoReq.Validate if the designated constraints aren't met.
type UserAccountInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAccountInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAccountInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAccountInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAccountInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAccountInfoReqValidationError) ErrorName() string {
	return "UserAccountInfoReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAccountInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAccountInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAccountInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAccountInfoReqValidationError{}

// Validate checks the field values on UserAccountInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserAccountInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAccountInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAccountInfoMultiError, or nil if none found.
func (m *UserAccountInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAccountInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for AppNo

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for PwdQuestion

	// no validation rules for PwdAnswer

	// no validation rules for CertifyAuditStatus

	// no validation rules for CreatorAuditStatus

	// no validation rules for MerchantStatus

	// no validation rules for CapitalBalance

	// no validation rules for PresentBalance

	// no validation rules for FrozenPaidAmount

	// no validation rules for FrozenPresentAmount

	// no validation rules for CredentialChainPrice

	// no validation rules for CollectionCastingPrice

	// no validation rules for CollectionOnlinePrice

	// no validation rules for CollectionOfflinePrice

	// no validation rules for CollectionTransferPrice

	// no validation rules for ApiCallPrice

	// no validation rules for DeletedAt

	// no validation rules for Status

	// no validation rules for ModifyTime

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return UserAccountInfoMultiError(errors)
	}

	return nil
}

// UserAccountInfoMultiError is an error wrapping multiple validation errors
// returned by UserAccountInfo.ValidateAll() if the designated constraints
// aren't met.
type UserAccountInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAccountInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAccountInfoMultiError) AllErrors() []error { return m }

// UserAccountInfoValidationError is the validation error returned by
// UserAccountInfo.Validate if the designated constraints aren't met.
type UserAccountInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAccountInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAccountInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAccountInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAccountInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAccountInfoValidationError) ErrorName() string { return "UserAccountInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserAccountInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAccountInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAccountInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAccountInfoValidationError{}

// Validate checks the field values on UserAccountInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAccountInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAccountInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAccountInfoRespMultiError, or nil if none found.
func (m *UserAccountInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAccountInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAccountInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAccountInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAccountInfoRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserAccountInfoRespMultiError(errors)
	}

	return nil
}

// UserAccountInfoRespMultiError is an error wrapping multiple validation
// errors returned by UserAccountInfoResp.ValidateAll() if the designated
// constraints aren't met.
type UserAccountInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAccountInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAccountInfoRespMultiError) AllErrors() []error { return m }

// UserAccountInfoRespValidationError is the validation error returned by
// UserAccountInfoResp.Validate if the designated constraints aren't met.
type UserAccountInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAccountInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAccountInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAccountInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAccountInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAccountInfoRespValidationError) ErrorName() string {
	return "UserAccountInfoRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAccountInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAccountInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAccountInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAccountInfoRespValidationError{}

// Validate checks the field values on UserAdminDeveloperAuditReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminDeveloperAuditReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminDeveloperAuditReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminDeveloperAuditReqMultiError, or nil if none found.
func (m *UserAdminDeveloperAuditReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminDeveloperAuditReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if _, ok := _UserAdminDeveloperAuditReq_Status_InLookup[m.GetStatus()]; !ok {
		err := UserAdminDeveloperAuditReqValidationError{
			field:  "Status",
			reason: "value must be in list [1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Reason

	if len(errors) > 0 {
		return UserAdminDeveloperAuditReqMultiError(errors)
	}

	return nil
}

// UserAdminDeveloperAuditReqMultiError is an error wrapping multiple
// validation errors returned by UserAdminDeveloperAuditReq.ValidateAll() if
// the designated constraints aren't met.
type UserAdminDeveloperAuditReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminDeveloperAuditReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminDeveloperAuditReqMultiError) AllErrors() []error { return m }

// UserAdminDeveloperAuditReqValidationError is the validation error returned
// by UserAdminDeveloperAuditReq.Validate if the designated constraints aren't met.
type UserAdminDeveloperAuditReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminDeveloperAuditReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminDeveloperAuditReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminDeveloperAuditReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminDeveloperAuditReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminDeveloperAuditReqValidationError) ErrorName() string {
	return "UserAdminDeveloperAuditReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminDeveloperAuditReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminDeveloperAuditReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminDeveloperAuditReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminDeveloperAuditReqValidationError{}

var _UserAdminDeveloperAuditReq_Status_InLookup = map[uint32]struct{}{
	1: {},
	2: {},
}

// Validate checks the field values on ChangePwdNewReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChangePwdNewReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangePwdNewReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangePwdNewReqMultiError, or nil if none found.
func (m *ChangePwdNewReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangePwdNewReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountId() <= 0 {
		err := ChangePwdNewReqValidationError{
			field:  "AccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOldPassword()); l < 6 || l > 16 {
		err := ChangePwdNewReqValidationError{
			field:  "OldPassword",
			reason: "value length must be between 6 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 16 {
		err := ChangePwdNewReqValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 16 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ChangePwdNewReqMultiError(errors)
	}

	return nil
}

// ChangePwdNewReqMultiError is an error wrapping multiple validation errors
// returned by ChangePwdNewReq.ValidateAll() if the designated constraints
// aren't met.
type ChangePwdNewReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangePwdNewReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangePwdNewReqMultiError) AllErrors() []error { return m }

// ChangePwdNewReqValidationError is the validation error returned by
// ChangePwdNewReq.Validate if the designated constraints aren't met.
type ChangePwdNewReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangePwdNewReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangePwdNewReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangePwdNewReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangePwdNewReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangePwdNewReqValidationError) ErrorName() string { return "ChangePwdNewReqValidationError" }

// Error satisfies the builtin error interface
func (e ChangePwdNewReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangePwdNewReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangePwdNewReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangePwdNewReqValidationError{}

// Validate checks the field values on RealNameNewReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RealNameNewReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealNameNewReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RealNameNewReqMultiError,
// or nil if none found.
func (m *RealNameNewReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RealNameNewReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountId() <= 0 {
		err := RealNameNewReqValidationError{
			field:  "AccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetAccountType(); val <= 0 || val >= 3 {
		err := RealNameNewReqValidationError{
			field:  "AccountType",
			reason: "value must be inside range (0, 3)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRealName()) < 2 {
		err := RealNameNewReqValidationError{
			field:  "RealName",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ShortName

	if utf8.RuneCountInString(m.GetIdNo()) < 1 {
		err := RealNameNewReqValidationError{
			field:  "IdNo",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IdPhone

	// no validation rules for IdPhoneCode

	// no validation rules for IdPicFront

	// no validation rules for IdPicBack

	// no validation rules for IdPicHand

	// no validation rules for LicenseNo

	// no validation rules for LicensePic

	// no validation rules for LegalPersonName

	// no validation rules for ContactName

	// no validation rules for ContactPhone

	// no validation rules for ContactAddress

	// no validation rules for Logo

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RealNameNewReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RealNameNewReqValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RealNameNewReqValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DeveloperFlag

	if len(errors) > 0 {
		return RealNameNewReqMultiError(errors)
	}

	return nil
}

// RealNameNewReqMultiError is an error wrapping multiple validation errors
// returned by RealNameNewReq.ValidateAll() if the designated constraints
// aren't met.
type RealNameNewReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealNameNewReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealNameNewReqMultiError) AllErrors() []error { return m }

// RealNameNewReqValidationError is the validation error returned by
// RealNameNewReq.Validate if the designated constraints aren't met.
type RealNameNewReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealNameNewReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealNameNewReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealNameNewReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealNameNewReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealNameNewReqValidationError) ErrorName() string { return "RealNameNewReqValidationError" }

// Error satisfies the builtin error interface
func (e RealNameNewReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealNameNewReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealNameNewReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealNameNewReqValidationError{}

// Validate checks the field values on RealNameNewResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RealNameNewResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealNameNewResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RealNameNewRespMultiError, or nil if none found.
func (m *RealNameNewResp) ValidateAll() error {
	return m.validate(true)
}

func (m *RealNameNewResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RealNameNewRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RealNameNewRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RealNameNewRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RealNameNewRespMultiError(errors)
	}

	return nil
}

// RealNameNewRespMultiError is an error wrapping multiple validation errors
// returned by RealNameNewResp.ValidateAll() if the designated constraints
// aren't met.
type RealNameNewRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealNameNewRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealNameNewRespMultiError) AllErrors() []error { return m }

// RealNameNewRespValidationError is the validation error returned by
// RealNameNewResp.Validate if the designated constraints aren't met.
type RealNameNewRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealNameNewRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealNameNewRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealNameNewRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealNameNewRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealNameNewRespValidationError) ErrorName() string { return "RealNameNewRespValidationError" }

// Error satisfies the builtin error interface
func (e RealNameNewRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealNameNewResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealNameNewRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealNameNewRespValidationError{}

// Validate checks the field values on UserInvoiceListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoiceListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoiceListReqMultiError, or nil if none found.
func (m *UserInvoiceListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() <= 0 {
		err := UserInvoiceListReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() <= 0 {
		err := UserInvoiceListReqValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for StartDate

	// no validation rules for EndDate

	if len(errors) > 0 {
		return UserInvoiceListReqMultiError(errors)
	}

	return nil
}

// UserInvoiceListReqMultiError is an error wrapping multiple validation errors
// returned by UserInvoiceListReq.ValidateAll() if the designated constraints
// aren't met.
type UserInvoiceListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceListReqMultiError) AllErrors() []error { return m }

// UserInvoiceListReqValidationError is the validation error returned by
// UserInvoiceListReq.Validate if the designated constraints aren't met.
type UserInvoiceListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceListReqValidationError) ErrorName() string {
	return "UserInvoiceListReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceListReqValidationError{}

// Validate checks the field values on UserInvoiceListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoiceListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoiceListRespMultiError, or nil if none found.
func (m *UserInvoiceListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInvoiceListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInvoiceListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInvoiceListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserInvoiceListRespMultiError(errors)
	}

	return nil
}

// UserInvoiceListRespMultiError is an error wrapping multiple validation
// errors returned by UserInvoiceListResp.ValidateAll() if the designated
// constraints aren't met.
type UserInvoiceListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceListRespMultiError) AllErrors() []error { return m }

// UserInvoiceListRespValidationError is the validation error returned by
// UserInvoiceListResp.Validate if the designated constraints aren't met.
type UserInvoiceListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceListRespValidationError) ErrorName() string {
	return "UserInvoiceListRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceListRespValidationError{}

// Validate checks the field values on UserInvoiceInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserInvoiceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoiceInfoMultiError, or nil if none found.
func (m *UserInvoiceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Date

	// no validation rules for Amount

	// no validation rules for Progress

	// no validation rules for InvoiceInfoId

	if len(errors) > 0 {
		return UserInvoiceInfoMultiError(errors)
	}

	return nil
}

// UserInvoiceInfoMultiError is an error wrapping multiple validation errors
// returned by UserInvoiceInfo.ValidateAll() if the designated constraints
// aren't met.
type UserInvoiceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceInfoMultiError) AllErrors() []error { return m }

// UserInvoiceInfoValidationError is the validation error returned by
// UserInvoiceInfo.Validate if the designated constraints aren't met.
type UserInvoiceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceInfoValidationError) ErrorName() string { return "UserInvoiceInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInvoiceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceInfoValidationError{}

// Validate checks the field values on UserInvoicedListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoicedListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoicedListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoicedListReqMultiError, or nil if none found.
func (m *UserInvoicedListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoicedListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StartDate

	// no validation rules for EndDate

	if m.GetPage() <= 0 {
		err := UserInvoicedListReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() <= 0 {
		err := UserInvoicedListReqValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserInvoicedListReqMultiError(errors)
	}

	return nil
}

// UserInvoicedListReqMultiError is an error wrapping multiple validation
// errors returned by UserInvoicedListReq.ValidateAll() if the designated
// constraints aren't met.
type UserInvoicedListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoicedListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoicedListReqMultiError) AllErrors() []error { return m }

// UserInvoicedListReqValidationError is the validation error returned by
// UserInvoicedListReq.Validate if the designated constraints aren't met.
type UserInvoicedListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoicedListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoicedListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoicedListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoicedListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoicedListReqValidationError) ErrorName() string {
	return "UserInvoicedListReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoicedListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoicedListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoicedListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoicedListReqValidationError{}

// Validate checks the field values on UserInvoicedListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoicedListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoicedListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoicedListRespMultiError, or nil if none found.
func (m *UserInvoicedListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoicedListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInvoicedListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInvoicedListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInvoicedListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserInvoicedListRespMultiError(errors)
	}

	return nil
}

// UserInvoicedListRespMultiError is an error wrapping multiple validation
// errors returned by UserInvoicedListResp.ValidateAll() if the designated
// constraints aren't met.
type UserInvoicedListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoicedListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoicedListRespMultiError) AllErrors() []error { return m }

// UserInvoicedListRespValidationError is the validation error returned by
// UserInvoicedListResp.Validate if the designated constraints aren't met.
type UserInvoicedListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoicedListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoicedListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoicedListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoicedListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoicedListRespValidationError) ErrorName() string {
	return "UserInvoicedListRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoicedListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoicedListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoicedListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoicedListRespValidationError{}

// Validate checks the field values on UserInvoicedInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserInvoicedInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoicedInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoicedInfoMultiError, or nil if none found.
func (m *UserInvoicedInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoicedInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ApplyInvoiceId

	// no validation rules for Amount

	// no validation rules for InvoiceNumber

	// no validation rules for ApplyDate

	// no validation rules for ActualDate

	// no validation rules for InclusiveMonth

	if len(errors) > 0 {
		return UserInvoicedInfoMultiError(errors)
	}

	return nil
}

// UserInvoicedInfoMultiError is an error wrapping multiple validation errors
// returned by UserInvoicedInfo.ValidateAll() if the designated constraints
// aren't met.
type UserInvoicedInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoicedInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoicedInfoMultiError) AllErrors() []error { return m }

// UserInvoicedInfoValidationError is the validation error returned by
// UserInvoicedInfo.Validate if the designated constraints aren't met.
type UserInvoicedInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoicedInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoicedInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoicedInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoicedInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoicedInfoValidationError) ErrorName() string { return "UserInvoicedInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInvoicedInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoicedInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoicedInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoicedInfoValidationError{}

// Validate checks the field values on UserInvoicedInclusiveMonthReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoicedInclusiveMonthReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoicedInclusiveMonthReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserInvoicedInclusiveMonthReqMultiError, or nil if none found.
func (m *UserInvoicedInclusiveMonthReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoicedInclusiveMonthReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.GetPage() <= 0 {
		err := UserInvoicedInclusiveMonthReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() <= 0 {
		err := UserInvoicedInclusiveMonthReqValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserInvoicedInclusiveMonthReqMultiError(errors)
	}

	return nil
}

// UserInvoicedInclusiveMonthReqMultiError is an error wrapping multiple
// validation errors returned by UserInvoicedInclusiveMonthReq.ValidateAll()
// if the designated constraints aren't met.
type UserInvoicedInclusiveMonthReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoicedInclusiveMonthReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoicedInclusiveMonthReqMultiError) AllErrors() []error { return m }

// UserInvoicedInclusiveMonthReqValidationError is the validation error
// returned by UserInvoicedInclusiveMonthReq.Validate if the designated
// constraints aren't met.
type UserInvoicedInclusiveMonthReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoicedInclusiveMonthReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoicedInclusiveMonthReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoicedInclusiveMonthReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoicedInclusiveMonthReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoicedInclusiveMonthReqValidationError) ErrorName() string {
	return "UserInvoicedInclusiveMonthReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoicedInclusiveMonthReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoicedInclusiveMonthReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoicedInclusiveMonthReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoicedInclusiveMonthReqValidationError{}

// Validate checks the field values on UserInvoicedInclusiveMonthResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoicedInclusiveMonthResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoicedInclusiveMonthResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserInvoicedInclusiveMonthRespMultiError, or nil if none found.
func (m *UserInvoicedInclusiveMonthResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoicedInclusiveMonthResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInvoicedInclusiveMonthRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInvoicedInclusiveMonthRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInvoicedInclusiveMonthRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserInvoicedInclusiveMonthRespMultiError(errors)
	}

	return nil
}

// UserInvoicedInclusiveMonthRespMultiError is an error wrapping multiple
// validation errors returned by UserInvoicedInclusiveMonthResp.ValidateAll()
// if the designated constraints aren't met.
type UserInvoicedInclusiveMonthRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoicedInclusiveMonthRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoicedInclusiveMonthRespMultiError) AllErrors() []error { return m }

// UserInvoicedInclusiveMonthRespValidationError is the validation error
// returned by UserInvoicedInclusiveMonthResp.Validate if the designated
// constraints aren't met.
type UserInvoicedInclusiveMonthRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoicedInclusiveMonthRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoicedInclusiveMonthRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoicedInclusiveMonthRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoicedInclusiveMonthRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoicedInclusiveMonthRespValidationError) ErrorName() string {
	return "UserInvoicedInclusiveMonthRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoicedInclusiveMonthRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoicedInclusiveMonthResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoicedInclusiveMonthRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoicedInclusiveMonthRespValidationError{}

// Validate checks the field values on UserInvoiceInclusiveMonthInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoiceInclusiveMonthInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceInclusiveMonthInfo with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserInvoiceInclusiveMonthInfoMultiError, or nil if none found.
func (m *UserInvoiceInclusiveMonthInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceInclusiveMonthInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Date

	// no validation rules for Amount

	if len(errors) > 0 {
		return UserInvoiceInclusiveMonthInfoMultiError(errors)
	}

	return nil
}

// UserInvoiceInclusiveMonthInfoMultiError is an error wrapping multiple
// validation errors returned by UserInvoiceInclusiveMonthInfo.ValidateAll()
// if the designated constraints aren't met.
type UserInvoiceInclusiveMonthInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceInclusiveMonthInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceInclusiveMonthInfoMultiError) AllErrors() []error { return m }

// UserInvoiceInclusiveMonthInfoValidationError is the validation error
// returned by UserInvoiceInclusiveMonthInfo.Validate if the designated
// constraints aren't met.
type UserInvoiceInclusiveMonthInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceInclusiveMonthInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceInclusiveMonthInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceInclusiveMonthInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceInclusiveMonthInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceInclusiveMonthInfoValidationError) ErrorName() string {
	return "UserInvoiceInclusiveMonthInfoValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceInclusiveMonthInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceInclusiveMonthInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceInclusiveMonthInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceInclusiveMonthInfoValidationError{}

// Validate checks the field values on UserInvoiceGetInfoByIdReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoiceGetInfoByIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceGetInfoByIdReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoiceGetInfoByIdReqMultiError, or nil if none found.
func (m *UserInvoiceGetInfoByIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceGetInfoByIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if len(errors) > 0 {
		return UserInvoiceGetInfoByIdReqMultiError(errors)
	}

	return nil
}

// UserInvoiceGetInfoByIdReqMultiError is an error wrapping multiple validation
// errors returned by UserInvoiceGetInfoByIdReq.ValidateAll() if the
// designated constraints aren't met.
type UserInvoiceGetInfoByIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceGetInfoByIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceGetInfoByIdReqMultiError) AllErrors() []error { return m }

// UserInvoiceGetInfoByIdReqValidationError is the validation error returned by
// UserInvoiceGetInfoByIdReq.Validate if the designated constraints aren't met.
type UserInvoiceGetInfoByIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceGetInfoByIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceGetInfoByIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceGetInfoByIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceGetInfoByIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceGetInfoByIdReqValidationError) ErrorName() string {
	return "UserInvoiceGetInfoByIdReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceGetInfoByIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceGetInfoByIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceGetInfoByIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceGetInfoByIdReqValidationError{}

// Validate checks the field values on UserInvoiceGetInfoByIdResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoiceGetInfoByIdResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceGetInfoByIdResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoiceGetInfoByIdRespMultiError, or nil if none found.
func (m *UserInvoiceGetInfoByIdResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceGetInfoByIdResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInvoiceGetInfoByIdRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInvoiceGetInfoByIdRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInvoiceGetInfoByIdRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserInvoiceGetInfoByIdRespMultiError(errors)
	}

	return nil
}

// UserInvoiceGetInfoByIdRespMultiError is an error wrapping multiple
// validation errors returned by UserInvoiceGetInfoByIdResp.ValidateAll() if
// the designated constraints aren't met.
type UserInvoiceGetInfoByIdRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceGetInfoByIdRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceGetInfoByIdRespMultiError) AllErrors() []error { return m }

// UserInvoiceGetInfoByIdRespValidationError is the validation error returned
// by UserInvoiceGetInfoByIdResp.Validate if the designated constraints aren't met.
type UserInvoiceGetInfoByIdRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceGetInfoByIdRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceGetInfoByIdRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceGetInfoByIdRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceGetInfoByIdRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceGetInfoByIdRespValidationError) ErrorName() string {
	return "UserInvoiceGetInfoByIdRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceGetInfoByIdRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceGetInfoByIdResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceGetInfoByIdRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceGetInfoByIdRespValidationError{}

// Validate checks the field values on UserInvoiceConsumptiveDetailReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoiceConsumptiveDetailReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceConsumptiveDetailReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserInvoiceConsumptiveDetailReqMultiError, or nil if none found.
func (m *UserInvoiceConsumptiveDetailReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceConsumptiveDetailReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.GetPage() <= 0 {
		err := UserInvoiceConsumptiveDetailReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() <= 0 {
		err := UserInvoiceConsumptiveDetailReqValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserInvoiceConsumptiveDetailReqMultiError(errors)
	}

	return nil
}

// UserInvoiceConsumptiveDetailReqMultiError is an error wrapping multiple
// validation errors returned by UserInvoiceConsumptiveDetailReq.ValidateAll()
// if the designated constraints aren't met.
type UserInvoiceConsumptiveDetailReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceConsumptiveDetailReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceConsumptiveDetailReqMultiError) AllErrors() []error { return m }

// UserInvoiceConsumptiveDetailReqValidationError is the validation error
// returned by UserInvoiceConsumptiveDetailReq.Validate if the designated
// constraints aren't met.
type UserInvoiceConsumptiveDetailReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceConsumptiveDetailReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceConsumptiveDetailReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceConsumptiveDetailReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceConsumptiveDetailReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceConsumptiveDetailReqValidationError) ErrorName() string {
	return "UserInvoiceConsumptiveDetailReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceConsumptiveDetailReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceConsumptiveDetailReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceConsumptiveDetailReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceConsumptiveDetailReqValidationError{}

// Validate checks the field values on UserInvoiceConsumptiveDetailResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UserInvoiceConsumptiveDetailResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceConsumptiveDetailResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserInvoiceConsumptiveDetailRespMultiError, or nil if none found.
func (m *UserInvoiceConsumptiveDetailResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceConsumptiveDetailResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInvoiceConsumptiveDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInvoiceConsumptiveDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInvoiceConsumptiveDetailRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserInvoiceConsumptiveDetailRespMultiError(errors)
	}

	return nil
}

// UserInvoiceConsumptiveDetailRespMultiError is an error wrapping multiple
// validation errors returned by
// UserInvoiceConsumptiveDetailResp.ValidateAll() if the designated
// constraints aren't met.
type UserInvoiceConsumptiveDetailRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceConsumptiveDetailRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceConsumptiveDetailRespMultiError) AllErrors() []error { return m }

// UserInvoiceConsumptiveDetailRespValidationError is the validation error
// returned by UserInvoiceConsumptiveDetailResp.Validate if the designated
// constraints aren't met.
type UserInvoiceConsumptiveDetailRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceConsumptiveDetailRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceConsumptiveDetailRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceConsumptiveDetailRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceConsumptiveDetailRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceConsumptiveDetailRespValidationError) ErrorName() string {
	return "UserInvoiceConsumptiveDetailRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceConsumptiveDetailRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceConsumptiveDetailResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceConsumptiveDetailRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceConsumptiveDetailRespValidationError{}

// Validate checks the field values on UserCapitalAllDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalAllDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalAllDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalAllDetailMultiError, or nil if none found.
func (m *UserCapitalAllDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalAllDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionType

	// no validation rules for TradeNo

	// no validation rules for PaidAmount

	// no validation rules for PresentAmount

	// no validation rules for Status

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return UserCapitalAllDetailMultiError(errors)
	}

	return nil
}

// UserCapitalAllDetailMultiError is an error wrapping multiple validation
// errors returned by UserCapitalAllDetail.ValidateAll() if the designated
// constraints aren't met.
type UserCapitalAllDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalAllDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalAllDetailMultiError) AllErrors() []error { return m }

// UserCapitalAllDetailValidationError is the validation error returned by
// UserCapitalAllDetail.Validate if the designated constraints aren't met.
type UserCapitalAllDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalAllDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalAllDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalAllDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalAllDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalAllDetailValidationError) ErrorName() string {
	return "UserCapitalAllDetailValidationError"
}

// Error satisfies the builtin error interface
func (e UserCapitalAllDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalAllDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalAllDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalAllDetailValidationError{}

// Validate checks the field values on ConsumptiveDetailInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsumptiveDetailInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsumptiveDetailInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsumptiveDetailInfoMultiError, or nil if none found.
func (m *ConsumptiveDetailInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsumptiveDetailInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DealType

	// no validation rules for SerialNumber

	// no validation rules for ConsumeAmount

	// no validation rules for GiveGas

	// no validation rules for Status

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return ConsumptiveDetailInfoMultiError(errors)
	}

	return nil
}

// ConsumptiveDetailInfoMultiError is an error wrapping multiple validation
// errors returned by ConsumptiveDetailInfo.ValidateAll() if the designated
// constraints aren't met.
type ConsumptiveDetailInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsumptiveDetailInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsumptiveDetailInfoMultiError) AllErrors() []error { return m }

// ConsumptiveDetailInfoValidationError is the validation error returned by
// ConsumptiveDetailInfo.Validate if the designated constraints aren't met.
type ConsumptiveDetailInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsumptiveDetailInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsumptiveDetailInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsumptiveDetailInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsumptiveDetailInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsumptiveDetailInfoValidationError) ErrorName() string {
	return "ConsumptiveDetailInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ConsumptiveDetailInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsumptiveDetailInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsumptiveDetailInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsumptiveDetailInfoValidationError{}

// Validate checks the field values on UserInvoiceApplyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoiceApplyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceApplyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoiceApplyReqMultiError, or nil if none found.
func (m *UserInvoiceApplyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceApplyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Amount

	// no validation rules for PersonalName

	// no validation rules for CompanyName

	// no validation rules for BusinessLicenseNumber

	// no validation rules for RegisteredAddress

	// no validation rules for Telephone

	// no validation rules for BankAccount

	// no validation rules for CreditCardNumbers

	// no validation rules for Name

	// no validation rules for Mobile

	// no validation rules for Area

	// no validation rules for Address

	// no validation rules for Account

	if len(errors) > 0 {
		return UserInvoiceApplyReqMultiError(errors)
	}

	return nil
}

// UserInvoiceApplyReqMultiError is an error wrapping multiple validation
// errors returned by UserInvoiceApplyReq.ValidateAll() if the designated
// constraints aren't met.
type UserInvoiceApplyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceApplyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceApplyReqMultiError) AllErrors() []error { return m }

// UserInvoiceApplyReqValidationError is the validation error returned by
// UserInvoiceApplyReq.Validate if the designated constraints aren't met.
type UserInvoiceApplyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceApplyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceApplyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceApplyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceApplyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceApplyReqValidationError) ErrorName() string {
	return "UserInvoiceApplyReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceApplyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceApplyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceApplyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceApplyReqValidationError{}

// Validate checks the field values on UserInvoiceApplyResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoiceApplyResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceApplyResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoiceApplyRespMultiError, or nil if none found.
func (m *UserInvoiceApplyResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceApplyResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if len(errors) > 0 {
		return UserInvoiceApplyRespMultiError(errors)
	}

	return nil
}

// UserInvoiceApplyRespMultiError is an error wrapping multiple validation
// errors returned by UserInvoiceApplyResp.ValidateAll() if the designated
// constraints aren't met.
type UserInvoiceApplyRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceApplyRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceApplyRespMultiError) AllErrors() []error { return m }

// UserInvoiceApplyRespValidationError is the validation error returned by
// UserInvoiceApplyResp.Validate if the designated constraints aren't met.
type UserInvoiceApplyRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceApplyRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceApplyRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceApplyRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceApplyRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceApplyRespValidationError) ErrorName() string {
	return "UserInvoiceApplyRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceApplyRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceApplyResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceApplyRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceApplyRespValidationError{}

// Validate checks the field values on UserAdminInvoiceSetInfoReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminInvoiceSetInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceSetInfoReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceSetInfoReqMultiError, or nil if none found.
func (m *UserAdminInvoiceSetInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceSetInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for InvoiceNumber

	// no validation rules for TrackingNumber

	if len(errors) > 0 {
		return UserAdminInvoiceSetInfoReqMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceSetInfoReqMultiError is an error wrapping multiple
// validation errors returned by UserAdminInvoiceSetInfoReq.ValidateAll() if
// the designated constraints aren't met.
type UserAdminInvoiceSetInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceSetInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceSetInfoReqMultiError) AllErrors() []error { return m }

// UserAdminInvoiceSetInfoReqValidationError is the validation error returned
// by UserAdminInvoiceSetInfoReq.Validate if the designated constraints aren't met.
type UserAdminInvoiceSetInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceSetInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceSetInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceSetInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceSetInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceSetInfoReqValidationError) ErrorName() string {
	return "UserAdminInvoiceSetInfoReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceSetInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceSetInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceSetInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceSetInfoReqValidationError{}

// Validate checks the field values on UserAdminInvoiceSetInfoResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminInvoiceSetInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceSetInfoResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceSetInfoRespMultiError, or nil if none found.
func (m *UserAdminInvoiceSetInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceSetInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if len(errors) > 0 {
		return UserAdminInvoiceSetInfoRespMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceSetInfoRespMultiError is an error wrapping multiple
// validation errors returned by UserAdminInvoiceSetInfoResp.ValidateAll() if
// the designated constraints aren't met.
type UserAdminInvoiceSetInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceSetInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceSetInfoRespMultiError) AllErrors() []error { return m }

// UserAdminInvoiceSetInfoRespValidationError is the validation error returned
// by UserAdminInvoiceSetInfoResp.Validate if the designated constraints
// aren't met.
type UserAdminInvoiceSetInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceSetInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceSetInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceSetInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceSetInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceSetInfoRespValidationError) ErrorName() string {
	return "UserAdminInvoiceSetInfoRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceSetInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceSetInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceSetInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceSetInfoRespValidationError{}

// Validate checks the field values on UserAdminInvoiceListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminInvoiceListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceListReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceListReqMultiError, or nil if none found.
func (m *UserAdminInvoiceListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Account

	// no validation rules for StartDate

	// no validation rules for EndDate

	// no validation rules for Progress

	// no validation rules for ApplyDate

	if m.GetPage() <= 0 {
		err := UserAdminInvoiceListReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() <= 0 {
		err := UserAdminInvoiceListReqValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserAdminInvoiceListReqMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceListReqMultiError is an error wrapping multiple validation
// errors returned by UserAdminInvoiceListReq.ValidateAll() if the designated
// constraints aren't met.
type UserAdminInvoiceListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceListReqMultiError) AllErrors() []error { return m }

// UserAdminInvoiceListReqValidationError is the validation error returned by
// UserAdminInvoiceListReq.Validate if the designated constraints aren't met.
type UserAdminInvoiceListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceListReqValidationError) ErrorName() string {
	return "UserAdminInvoiceListReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceListReqValidationError{}

// Validate checks the field values on UserAdminInvoiceListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminInvoiceListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceListResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceListRespMultiError, or nil if none found.
func (m *UserAdminInvoiceListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAdminInvoiceListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAdminInvoiceListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAdminInvoiceListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserAdminInvoiceListRespMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceListRespMultiError is an error wrapping multiple validation
// errors returned by UserAdminInvoiceListResp.ValidateAll() if the designated
// constraints aren't met.
type UserAdminInvoiceListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceListRespMultiError) AllErrors() []error { return m }

// UserAdminInvoiceListRespValidationError is the validation error returned by
// UserAdminInvoiceListResp.Validate if the designated constraints aren't met.
type UserAdminInvoiceListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceListRespValidationError) ErrorName() string {
	return "UserAdminInvoiceListRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceListRespValidationError{}

// Validate checks the field values on UserAdminInvoiceInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminInvoiceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceInfoMultiError, or nil if none found.
func (m *UserAdminInvoiceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Account

	// no validation rules for Amount

	// no validation rules for ApplyDate

	// no validation rules for Progress

	if len(errors) > 0 {
		return UserAdminInvoiceInfoMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceInfoMultiError is an error wrapping multiple validation
// errors returned by UserAdminInvoiceInfo.ValidateAll() if the designated
// constraints aren't met.
type UserAdminInvoiceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceInfoMultiError) AllErrors() []error { return m }

// UserAdminInvoiceInfoValidationError is the validation error returned by
// UserAdminInvoiceInfo.Validate if the designated constraints aren't met.
type UserAdminInvoiceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceInfoValidationError) ErrorName() string {
	return "UserAdminInvoiceInfoValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceInfoValidationError{}

// Validate checks the field values on UserAdminInvoiceGetInfoReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminInvoiceGetInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceGetInfoReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceGetInfoReqMultiError, or nil if none found.
func (m *UserAdminInvoiceGetInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceGetInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return UserAdminInvoiceGetInfoReqMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceGetInfoReqMultiError is an error wrapping multiple
// validation errors returned by UserAdminInvoiceGetInfoReq.ValidateAll() if
// the designated constraints aren't met.
type UserAdminInvoiceGetInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceGetInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceGetInfoReqMultiError) AllErrors() []error { return m }

// UserAdminInvoiceGetInfoReqValidationError is the validation error returned
// by UserAdminInvoiceGetInfoReq.Validate if the designated constraints aren't met.
type UserAdminInvoiceGetInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceGetInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceGetInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceGetInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceGetInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceGetInfoReqValidationError) ErrorName() string {
	return "UserAdminInvoiceGetInfoReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceGetInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceGetInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceGetInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceGetInfoReqValidationError{}

// Validate checks the field values on UserAdminInvoiceGetInfoResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminInvoiceGetInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceGetInfoResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceGetInfoRespMultiError, or nil if none found.
func (m *UserAdminInvoiceGetInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceGetInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAdminInvoiceGetInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAdminInvoiceGetInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAdminInvoiceGetInfoRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserAdminInvoiceGetInfoRespMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceGetInfoRespMultiError is an error wrapping multiple
// validation errors returned by UserAdminInvoiceGetInfoResp.ValidateAll() if
// the designated constraints aren't met.
type UserAdminInvoiceGetInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceGetInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceGetInfoRespMultiError) AllErrors() []error { return m }

// UserAdminInvoiceGetInfoRespValidationError is the validation error returned
// by UserAdminInvoiceGetInfoResp.Validate if the designated constraints
// aren't met.
type UserAdminInvoiceGetInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceGetInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceGetInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceGetInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceGetInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceGetInfoRespValidationError) ErrorName() string {
	return "UserAdminInvoiceGetInfoRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceGetInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceGetInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceGetInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceGetInfoRespValidationError{}

// Validate checks the field values on UserAdminInvoiceGetInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminInvoiceGetInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceGetInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceGetInfoMultiError, or nil if none found.
func (m *UserAdminInvoiceGetInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceGetInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Amount

	// no validation rules for Progress

	// no validation rules for Type

	// no validation rules for PersonalName

	// no validation rules for CompanyName

	// no validation rules for BusinessLicenseNumber

	// no validation rules for RegisteredAddress

	// no validation rules for Telephone

	// no validation rules for BankAccount

	// no validation rules for CreditCardNumbers

	// no validation rules for Name

	// no validation rules for Mobile

	// no validation rules for Area

	// no validation rules for Address

	// no validation rules for Account

	// no validation rules for InvoiceNumber

	// no validation rules for TrackingNumber

	if len(errors) > 0 {
		return UserAdminInvoiceGetInfoMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceGetInfoMultiError is an error wrapping multiple validation
// errors returned by UserAdminInvoiceGetInfo.ValidateAll() if the designated
// constraints aren't met.
type UserAdminInvoiceGetInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceGetInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceGetInfoMultiError) AllErrors() []error { return m }

// UserAdminInvoiceGetInfoValidationError is the validation error returned by
// UserAdminInvoiceGetInfo.Validate if the designated constraints aren't met.
type UserAdminInvoiceGetInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceGetInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceGetInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceGetInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceGetInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceGetInfoValidationError) ErrorName() string {
	return "UserAdminInvoiceGetInfoValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceGetInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceGetInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceGetInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceGetInfoValidationError{}

// Validate checks the field values on UserAdminInvoiceGetMonthsInfoReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UserAdminInvoiceGetMonthsInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceGetMonthsInfoReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceGetMonthsInfoReqMultiError, or nil if none found.
func (m *UserAdminInvoiceGetMonthsInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceGetMonthsInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.GetPage() <= 0 {
		err := UserAdminInvoiceGetMonthsInfoReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() <= 0 {
		err := UserAdminInvoiceGetMonthsInfoReqValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserAdminInvoiceGetMonthsInfoReqMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceGetMonthsInfoReqMultiError is an error wrapping multiple
// validation errors returned by
// UserAdminInvoiceGetMonthsInfoReq.ValidateAll() if the designated
// constraints aren't met.
type UserAdminInvoiceGetMonthsInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceGetMonthsInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceGetMonthsInfoReqMultiError) AllErrors() []error { return m }

// UserAdminInvoiceGetMonthsInfoReqValidationError is the validation error
// returned by UserAdminInvoiceGetMonthsInfoReq.Validate if the designated
// constraints aren't met.
type UserAdminInvoiceGetMonthsInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceGetMonthsInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceGetMonthsInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceGetMonthsInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceGetMonthsInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceGetMonthsInfoReqValidationError) ErrorName() string {
	return "UserAdminInvoiceGetMonthsInfoReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceGetMonthsInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceGetMonthsInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceGetMonthsInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceGetMonthsInfoReqValidationError{}

// Validate checks the field values on UserAdminInvoiceGetMonthsInfoResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UserAdminInvoiceGetMonthsInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceGetMonthsInfoResp
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceGetMonthsInfoRespMultiError, or nil if none found.
func (m *UserAdminInvoiceGetMonthsInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceGetMonthsInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAdminInvoiceGetMonthsInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAdminInvoiceGetMonthsInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAdminInvoiceGetMonthsInfoRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserAdminInvoiceGetMonthsInfoRespMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceGetMonthsInfoRespMultiError is an error wrapping multiple
// validation errors returned by
// UserAdminInvoiceGetMonthsInfoResp.ValidateAll() if the designated
// constraints aren't met.
type UserAdminInvoiceGetMonthsInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceGetMonthsInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceGetMonthsInfoRespMultiError) AllErrors() []error { return m }

// UserAdminInvoiceGetMonthsInfoRespValidationError is the validation error
// returned by UserAdminInvoiceGetMonthsInfoResp.Validate if the designated
// constraints aren't met.
type UserAdminInvoiceGetMonthsInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceGetMonthsInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceGetMonthsInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceGetMonthsInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceGetMonthsInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceGetMonthsInfoRespValidationError) ErrorName() string {
	return "UserAdminInvoiceGetMonthsInfoRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceGetMonthsInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceGetMonthsInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceGetMonthsInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceGetMonthsInfoRespValidationError{}

// Validate checks the field values on UserAdminInvoiceGetMonthsInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminInvoiceGetMonthsInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceGetMonthsInfo with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceGetMonthsInfoMultiError, or nil if none found.
func (m *UserAdminInvoiceGetMonthsInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceGetMonthsInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Date

	// no validation rules for Amount

	if len(errors) > 0 {
		return UserAdminInvoiceGetMonthsInfoMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceGetMonthsInfoMultiError is an error wrapping multiple
// validation errors returned by UserAdminInvoiceGetMonthsInfo.ValidateAll()
// if the designated constraints aren't met.
type UserAdminInvoiceGetMonthsInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceGetMonthsInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceGetMonthsInfoMultiError) AllErrors() []error { return m }

// UserAdminInvoiceGetMonthsInfoValidationError is the validation error
// returned by UserAdminInvoiceGetMonthsInfo.Validate if the designated
// constraints aren't met.
type UserAdminInvoiceGetMonthsInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceGetMonthsInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceGetMonthsInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceGetMonthsInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceGetMonthsInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceGetMonthsInfoValidationError) ErrorName() string {
	return "UserAdminInvoiceGetMonthsInfoValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceGetMonthsInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceGetMonthsInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceGetMonthsInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceGetMonthsInfoValidationError{}

// Validate checks the field values on UserAdminGetConsumptiveDetailReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UserAdminGetConsumptiveDetailReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminGetConsumptiveDetailReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserAdminGetConsumptiveDetailReqMultiError, or nil if none found.
func (m *UserAdminGetConsumptiveDetailReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminGetConsumptiveDetailReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.GetPage() <= 0 {
		err := UserAdminGetConsumptiveDetailReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() <= 0 {
		err := UserAdminGetConsumptiveDetailReqValidationError{
			field:  "Limit",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserAdminGetConsumptiveDetailReqMultiError(errors)
	}

	return nil
}

// UserAdminGetConsumptiveDetailReqMultiError is an error wrapping multiple
// validation errors returned by
// UserAdminGetConsumptiveDetailReq.ValidateAll() if the designated
// constraints aren't met.
type UserAdminGetConsumptiveDetailReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminGetConsumptiveDetailReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminGetConsumptiveDetailReqMultiError) AllErrors() []error { return m }

// UserAdminGetConsumptiveDetailReqValidationError is the validation error
// returned by UserAdminGetConsumptiveDetailReq.Validate if the designated
// constraints aren't met.
type UserAdminGetConsumptiveDetailReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminGetConsumptiveDetailReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminGetConsumptiveDetailReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminGetConsumptiveDetailReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminGetConsumptiveDetailReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminGetConsumptiveDetailReqValidationError) ErrorName() string {
	return "UserAdminGetConsumptiveDetailReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminGetConsumptiveDetailReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminGetConsumptiveDetailReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminGetConsumptiveDetailReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminGetConsumptiveDetailReqValidationError{}

// Validate checks the field values on UserAdminGetConsumptiveDetailResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UserAdminGetConsumptiveDetailResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminGetConsumptiveDetailResp
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UserAdminGetConsumptiveDetailRespMultiError, or nil if none found.
func (m *UserAdminGetConsumptiveDetailResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminGetConsumptiveDetailResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAdminGetConsumptiveDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAdminGetConsumptiveDetailRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAdminGetConsumptiveDetailRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserAdminGetConsumptiveDetailRespMultiError(errors)
	}

	return nil
}

// UserAdminGetConsumptiveDetailRespMultiError is an error wrapping multiple
// validation errors returned by
// UserAdminGetConsumptiveDetailResp.ValidateAll() if the designated
// constraints aren't met.
type UserAdminGetConsumptiveDetailRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminGetConsumptiveDetailRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminGetConsumptiveDetailRespMultiError) AllErrors() []error { return m }

// UserAdminGetConsumptiveDetailRespValidationError is the validation error
// returned by UserAdminGetConsumptiveDetailResp.Validate if the designated
// constraints aren't met.
type UserAdminGetConsumptiveDetailRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminGetConsumptiveDetailRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminGetConsumptiveDetailRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminGetConsumptiveDetailRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminGetConsumptiveDetailRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminGetConsumptiveDetailRespValidationError) ErrorName() string {
	return "UserAdminGetConsumptiveDetailRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminGetConsumptiveDetailRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminGetConsumptiveDetailResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminGetConsumptiveDetailRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminGetConsumptiveDetailRespValidationError{}

// Validate checks the field values on UserAdminGetConsumptiveDetail with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminGetConsumptiveDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminGetConsumptiveDetail with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserAdminGetConsumptiveDetailMultiError, or nil if none found.
func (m *UserAdminGetConsumptiveDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminGetConsumptiveDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionType

	// no validation rules for TradeNo

	// no validation rules for PaidAmount

	// no validation rules for PresentAmount

	// no validation rules for Status

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return UserAdminGetConsumptiveDetailMultiError(errors)
	}

	return nil
}

// UserAdminGetConsumptiveDetailMultiError is an error wrapping multiple
// validation errors returned by UserAdminGetConsumptiveDetail.ValidateAll()
// if the designated constraints aren't met.
type UserAdminGetConsumptiveDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminGetConsumptiveDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminGetConsumptiveDetailMultiError) AllErrors() []error { return m }

// UserAdminGetConsumptiveDetailValidationError is the validation error
// returned by UserAdminGetConsumptiveDetail.Validate if the designated
// constraints aren't met.
type UserAdminGetConsumptiveDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminGetConsumptiveDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminGetConsumptiveDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminGetConsumptiveDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminGetConsumptiveDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminGetConsumptiveDetailValidationError) ErrorName() string {
	return "UserAdminGetConsumptiveDetailValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminGetConsumptiveDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminGetConsumptiveDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminGetConsumptiveDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminGetConsumptiveDetailValidationError{}

// Validate checks the field values on UserAdminPresentByAccountReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminPresentByAccountReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminPresentByAccountReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminPresentByAccountReqMultiError, or nil if none found.
func (m *UserAdminPresentByAccountReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminPresentByAccountReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Account

	if m.GetAmount() <= 0 {
		err := UserAdminPresentByAccountReqValidationError{
			field:  "Amount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Remark

	if len(errors) > 0 {
		return UserAdminPresentByAccountReqMultiError(errors)
	}

	return nil
}

// UserAdminPresentByAccountReqMultiError is an error wrapping multiple
// validation errors returned by UserAdminPresentByAccountReq.ValidateAll() if
// the designated constraints aren't met.
type UserAdminPresentByAccountReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminPresentByAccountReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminPresentByAccountReqMultiError) AllErrors() []error { return m }

// UserAdminPresentByAccountReqValidationError is the validation error returned
// by UserAdminPresentByAccountReq.Validate if the designated constraints
// aren't met.
type UserAdminPresentByAccountReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminPresentByAccountReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminPresentByAccountReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminPresentByAccountReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminPresentByAccountReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminPresentByAccountReqValidationError) ErrorName() string {
	return "UserAdminPresentByAccountReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminPresentByAccountReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminPresentByAccountReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminPresentByAccountReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminPresentByAccountReqValidationError{}

// Validate checks the field values on UserAdminPresentByAccountResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminPresentByAccountResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminPresentByAccountResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserAdminPresentByAccountRespMultiError, or nil if none found.
func (m *UserAdminPresentByAccountResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminPresentByAccountResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if len(errors) > 0 {
		return UserAdminPresentByAccountRespMultiError(errors)
	}

	return nil
}

// UserAdminPresentByAccountRespMultiError is an error wrapping multiple
// validation errors returned by UserAdminPresentByAccountResp.ValidateAll()
// if the designated constraints aren't met.
type UserAdminPresentByAccountRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminPresentByAccountRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminPresentByAccountRespMultiError) AllErrors() []error { return m }

// UserAdminPresentByAccountRespValidationError is the validation error
// returned by UserAdminPresentByAccountResp.Validate if the designated
// constraints aren't met.
type UserAdminPresentByAccountRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminPresentByAccountRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminPresentByAccountRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminPresentByAccountRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminPresentByAccountRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminPresentByAccountRespValidationError) ErrorName() string {
	return "UserAdminPresentByAccountRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminPresentByAccountRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminPresentByAccountResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminPresentByAccountRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminPresentByAccountRespValidationError{}

// Validate checks the field values on LoginResp_Data with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginResp_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginResp_DataMultiError,
// or nil if none found.
func (m *LoginResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUserInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginResp_DataValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginResp_DataValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginResp_DataValidationError{
				field:  "UserInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Token

	// no validation rules for ExpiresIn

	// no validation rules for PwdExpired

	if len(errors) > 0 {
		return LoginResp_DataMultiError(errors)
	}

	return nil
}

// LoginResp_DataMultiError is an error wrapping multiple validation errors
// returned by LoginResp_Data.ValidateAll() if the designated constraints
// aren't met.
type LoginResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginResp_DataMultiError) AllErrors() []error { return m }

// LoginResp_DataValidationError is the validation error returned by
// LoginResp_Data.Validate if the designated constraints aren't met.
type LoginResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginResp_DataValidationError) ErrorName() string { return "LoginResp_DataValidationError" }

// Error satisfies the builtin error interface
func (e LoginResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginResp_DataValidationError{}

// Validate checks the field values on RealNameResp_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RealNameResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealNameResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RealNameResp_DataMultiError, or nil if none found.
func (m *RealNameResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *RealNameResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CredentialId

	// no validation rules for Credential

	// no validation rules for CertifyAuditStatus

	if len(errors) > 0 {
		return RealNameResp_DataMultiError(errors)
	}

	return nil
}

// RealNameResp_DataMultiError is an error wrapping multiple validation errors
// returned by RealNameResp_Data.ValidateAll() if the designated constraints
// aren't met.
type RealNameResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealNameResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealNameResp_DataMultiError) AllErrors() []error { return m }

// RealNameResp_DataValidationError is the validation error returned by
// RealNameResp_Data.Validate if the designated constraints aren't met.
type RealNameResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealNameResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealNameResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealNameResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealNameResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealNameResp_DataValidationError) ErrorName() string {
	return "RealNameResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e RealNameResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealNameResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealNameResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealNameResp_DataValidationError{}

// Validate checks the field values on UserServiceBaseListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserServiceBaseListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserServiceBaseListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserServiceBaseListResp_DataMultiError, or nil if none found.
func (m *UserServiceBaseListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserServiceBaseListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserServiceBaseListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserServiceBaseListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserServiceBaseListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserServiceBaseListResp_DataMultiError(errors)
	}

	return nil
}

// UserServiceBaseListResp_DataMultiError is an error wrapping multiple
// validation errors returned by UserServiceBaseListResp_Data.ValidateAll() if
// the designated constraints aren't met.
type UserServiceBaseListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserServiceBaseListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserServiceBaseListResp_DataMultiError) AllErrors() []error { return m }

// UserServiceBaseListResp_DataValidationError is the validation error returned
// by UserServiceBaseListResp_Data.Validate if the designated constraints
// aren't met.
type UserServiceBaseListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserServiceBaseListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserServiceBaseListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserServiceBaseListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserServiceBaseListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserServiceBaseListResp_DataValidationError) ErrorName() string {
	return "UserServiceBaseListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserServiceBaseListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserServiceBaseListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserServiceBaseListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserServiceBaseListResp_DataValidationError{}

// Validate checks the field values on UserListResp_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserListResp_DataMultiError, or nil if none found.
func (m *UserListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserListResp_DataMultiError(errors)
	}

	return nil
}

// UserListResp_DataMultiError is an error wrapping multiple validation errors
// returned by UserListResp_Data.ValidateAll() if the designated constraints
// aren't met.
type UserListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserListResp_DataMultiError) AllErrors() []error { return m }

// UserListResp_DataValidationError is the validation error returned by
// UserListResp_Data.Validate if the designated constraints aren't met.
type UserListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserListResp_DataValidationError) ErrorName() string {
	return "UserListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserListResp_DataValidationError{}

// Validate checks the field values on CreatorApplyResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatorApplyResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatorApplyResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatorApplyResp_DataMultiError, or nil if none found.
func (m *CreatorApplyResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatorApplyResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if len(errors) > 0 {
		return CreatorApplyResp_DataMultiError(errors)
	}

	return nil
}

// CreatorApplyResp_DataMultiError is an error wrapping multiple validation
// errors returned by CreatorApplyResp_Data.ValidateAll() if the designated
// constraints aren't met.
type CreatorApplyResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatorApplyResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatorApplyResp_DataMultiError) AllErrors() []error { return m }

// CreatorApplyResp_DataValidationError is the validation error returned by
// CreatorApplyResp_Data.Validate if the designated constraints aren't met.
type CreatorApplyResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatorApplyResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatorApplyResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatorApplyResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatorApplyResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatorApplyResp_DataValidationError) ErrorName() string {
	return "CreatorApplyResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CreatorApplyResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatorApplyResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatorApplyResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatorApplyResp_DataValidationError{}

// Validate checks the field values on CreatorListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatorListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatorListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatorListResp_DataMultiError, or nil if none found.
func (m *CreatorListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatorListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreatorListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreatorListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreatorListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreatorListResp_DataMultiError(errors)
	}

	return nil
}

// CreatorListResp_DataMultiError is an error wrapping multiple validation
// errors returned by CreatorListResp_Data.ValidateAll() if the designated
// constraints aren't met.
type CreatorListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatorListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatorListResp_DataMultiError) AllErrors() []error { return m }

// CreatorListResp_DataValidationError is the validation error returned by
// CreatorListResp_Data.Validate if the designated constraints aren't met.
type CreatorListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatorListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatorListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatorListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatorListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatorListResp_DataValidationError) ErrorName() string {
	return "CreatorListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CreatorListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatorListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatorListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatorListResp_DataValidationError{}

// Validate checks the field values on UserAdminListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAdminListResp_DataMultiError, or nil if none found.
func (m *UserAdminListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserAdminListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserAdminListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserAdminListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserAdminListResp_DataMultiError(errors)
	}

	return nil
}

// UserAdminListResp_DataMultiError is an error wrapping multiple validation
// errors returned by UserAdminListResp_Data.ValidateAll() if the designated
// constraints aren't met.
type UserAdminListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminListResp_DataMultiError) AllErrors() []error { return m }

// UserAdminListResp_DataValidationError is the validation error returned by
// UserAdminListResp_Data.Validate if the designated constraints aren't met.
type UserAdminListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminListResp_DataValidationError) ErrorName() string {
	return "UserAdminListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminListResp_DataValidationError{}

// Validate checks the field values on UserAccountAdminListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAccountAdminListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAccountAdminListResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserAccountAdminListResp_DataMultiError, or nil if none found.
func (m *UserAccountAdminListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAccountAdminListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserAccountAdminListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserAccountAdminListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserAccountAdminListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserAccountAdminListResp_DataMultiError(errors)
	}

	return nil
}

// UserAccountAdminListResp_DataMultiError is an error wrapping multiple
// validation errors returned by UserAccountAdminListResp_Data.ValidateAll()
// if the designated constraints aren't met.
type UserAccountAdminListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAccountAdminListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAccountAdminListResp_DataMultiError) AllErrors() []error { return m }

// UserAccountAdminListResp_DataValidationError is the validation error
// returned by UserAccountAdminListResp_Data.Validate if the designated
// constraints aren't met.
type UserAccountAdminListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAccountAdminListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAccountAdminListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAccountAdminListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAccountAdminListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAccountAdminListResp_DataValidationError) ErrorName() string {
	return "UserAccountAdminListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserAccountAdminListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAccountAdminListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAccountAdminListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAccountAdminListResp_DataValidationError{}

// Validate checks the field values on UserIndexStatisticsResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserIndexStatisticsResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserIndexStatisticsResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserIndexStatisticsResp_DataMultiError, or nil if none found.
func (m *UserIndexStatisticsResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserIndexStatisticsResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompositionNum

	// no validation rules for CopyrightNum

	// no validation rules for CollectionNum

	// no validation rules for HoldCollectionNum

	// no validation rules for CapitalBalance

	// no validation rules for PresentBalance

	// no validation rules for FrozenPaidAmount

	// no validation rules for FrozenPresentAmount

	// no validation rules for ChargeNum

	// no validation rules for PresentChargeNum

	// no validation rules for ExpendNum

	// no validation rules for PresentExpendNum

	// no validation rules for DealAmount

	// no validation rules for DealNum

	// no validation rules for RefundAmount

	// no validation rules for RefundNum

	if len(errors) > 0 {
		return UserIndexStatisticsResp_DataMultiError(errors)
	}

	return nil
}

// UserIndexStatisticsResp_DataMultiError is an error wrapping multiple
// validation errors returned by UserIndexStatisticsResp_Data.ValidateAll() if
// the designated constraints aren't met.
type UserIndexStatisticsResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserIndexStatisticsResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserIndexStatisticsResp_DataMultiError) AllErrors() []error { return m }

// UserIndexStatisticsResp_DataValidationError is the validation error returned
// by UserIndexStatisticsResp_Data.Validate if the designated constraints
// aren't met.
type UserIndexStatisticsResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserIndexStatisticsResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserIndexStatisticsResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserIndexStatisticsResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserIndexStatisticsResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserIndexStatisticsResp_DataValidationError) ErrorName() string {
	return "UserIndexStatisticsResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserIndexStatisticsResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserIndexStatisticsResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserIndexStatisticsResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserIndexStatisticsResp_DataValidationError{}

// Validate checks the field values on UserCapitalResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalResp_DataMultiError, or nil if none found.
func (m *UserCapitalResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CapitalBalance

	// no validation rules for PresentBalance

	// no validation rules for FrozenPaidAmount

	// no validation rules for FrozenPresentAmount

	if len(errors) > 0 {
		return UserCapitalResp_DataMultiError(errors)
	}

	return nil
}

// UserCapitalResp_DataMultiError is an error wrapping multiple validation
// errors returned by UserCapitalResp_Data.ValidateAll() if the designated
// constraints aren't met.
type UserCapitalResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalResp_DataMultiError) AllErrors() []error { return m }

// UserCapitalResp_DataValidationError is the validation error returned by
// UserCapitalResp_Data.Validate if the designated constraints aren't met.
type UserCapitalResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalResp_DataValidationError) ErrorName() string {
	return "UserCapitalResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserCapitalResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalResp_DataValidationError{}

// Validate checks the field values on UserCapitalListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalListResp_DataMultiError, or nil if none found.
func (m *UserCapitalListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserCapitalListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserCapitalListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserCapitalListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserCapitalListResp_DataMultiError(errors)
	}

	return nil
}

// UserCapitalListResp_DataMultiError is an error wrapping multiple validation
// errors returned by UserCapitalListResp_Data.ValidateAll() if the designated
// constraints aren't met.
type UserCapitalListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalListResp_DataMultiError) AllErrors() []error { return m }

// UserCapitalListResp_DataValidationError is the validation error returned by
// UserCapitalListResp_Data.Validate if the designated constraints aren't met.
type UserCapitalListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalListResp_DataValidationError) ErrorName() string {
	return "UserCapitalListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserCapitalListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalListResp_DataValidationError{}

// Validate checks the field values on UserCapitalAllListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCapitalAllListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCapitalAllListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCapitalAllListResp_DataMultiError, or nil if none found.
func (m *UserCapitalAllListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCapitalAllListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserCapitalAllListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserCapitalAllListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserCapitalAllListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserCapitalAllListResp_DataMultiError(errors)
	}

	return nil
}

// UserCapitalAllListResp_DataMultiError is an error wrapping multiple
// validation errors returned by UserCapitalAllListResp_Data.ValidateAll() if
// the designated constraints aren't met.
type UserCapitalAllListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCapitalAllListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCapitalAllListResp_DataMultiError) AllErrors() []error { return m }

// UserCapitalAllListResp_DataValidationError is the validation error returned
// by UserCapitalAllListResp_Data.Validate if the designated constraints
// aren't met.
type UserCapitalAllListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCapitalAllListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCapitalAllListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCapitalAllListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCapitalAllListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCapitalAllListResp_DataValidationError) ErrorName() string {
	return "UserCapitalAllListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserCapitalAllListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCapitalAllListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCapitalAllListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCapitalAllListResp_DataValidationError{}

// Validate checks the field values on UserFrozenCapitalResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserFrozenCapitalResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserFrozenCapitalResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserFrozenCapitalResp_DataMultiError, or nil if none found.
func (m *UserFrozenCapitalResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserFrozenCapitalResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserFrozenCapitalResp_DataValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserFrozenCapitalResp_DataValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserFrozenCapitalResp_DataValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserFrozenCapitalResp_DataMultiError(errors)
	}

	return nil
}

// UserFrozenCapitalResp_DataMultiError is an error wrapping multiple
// validation errors returned by UserFrozenCapitalResp_Data.ValidateAll() if
// the designated constraints aren't met.
type UserFrozenCapitalResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserFrozenCapitalResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserFrozenCapitalResp_DataMultiError) AllErrors() []error { return m }

// UserFrozenCapitalResp_DataValidationError is the validation error returned
// by UserFrozenCapitalResp_Data.Validate if the designated constraints aren't met.
type UserFrozenCapitalResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserFrozenCapitalResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserFrozenCapitalResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserFrozenCapitalResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserFrozenCapitalResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserFrozenCapitalResp_DataValidationError) ErrorName() string {
	return "UserFrozenCapitalResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserFrozenCapitalResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserFrozenCapitalResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserFrozenCapitalResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserFrozenCapitalResp_DataValidationError{}

// Validate checks the field values on UserChainCostResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChainCostResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChainCostResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChainCostResp_DataMultiError, or nil if none found.
func (m *UserChainCostResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChainCostResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cost

	// no validation rules for Can

	if len(errors) > 0 {
		return UserChainCostResp_DataMultiError(errors)
	}

	return nil
}

// UserChainCostResp_DataMultiError is an error wrapping multiple validation
// errors returned by UserChainCostResp_Data.ValidateAll() if the designated
// constraints aren't met.
type UserChainCostResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChainCostResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChainCostResp_DataMultiError) AllErrors() []error { return m }

// UserChainCostResp_DataValidationError is the validation error returned by
// UserChainCostResp_Data.Validate if the designated constraints aren't met.
type UserChainCostResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChainCostResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChainCostResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChainCostResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChainCostResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChainCostResp_DataValidationError) ErrorName() string {
	return "UserChainCostResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserChainCostResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChainCostResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChainCostResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChainCostResp_DataValidationError{}

// Validate checks the field values on UserChargeResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChargeResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChargeResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChargeResp_DataMultiError, or nil if none found.
func (m *UserChargeResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChargeResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for TradeNo

	if len(errors) > 0 {
		return UserChargeResp_DataMultiError(errors)
	}

	return nil
}

// UserChargeResp_DataMultiError is an error wrapping multiple validation
// errors returned by UserChargeResp_Data.ValidateAll() if the designated
// constraints aren't met.
type UserChargeResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChargeResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChargeResp_DataMultiError) AllErrors() []error { return m }

// UserChargeResp_DataValidationError is the validation error returned by
// UserChargeResp_Data.Validate if the designated constraints aren't met.
type UserChargeResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChargeResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChargeResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChargeResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChargeResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChargeResp_DataValidationError) ErrorName() string {
	return "UserChargeResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserChargeResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChargeResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChargeResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChargeResp_DataValidationError{}

// Validate checks the field values on UserChargeStatusResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserChargeStatusResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserChargeStatusResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserChargeStatusResp_DataMultiError, or nil if none found.
func (m *UserChargeStatusResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserChargeStatusResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if len(errors) > 0 {
		return UserChargeStatusResp_DataMultiError(errors)
	}

	return nil
}

// UserChargeStatusResp_DataMultiError is an error wrapping multiple validation
// errors returned by UserChargeStatusResp_Data.ValidateAll() if the
// designated constraints aren't met.
type UserChargeStatusResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserChargeStatusResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserChargeStatusResp_DataMultiError) AllErrors() []error { return m }

// UserChargeStatusResp_DataValidationError is the validation error returned by
// UserChargeStatusResp_Data.Validate if the designated constraints aren't met.
type UserChargeStatusResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserChargeStatusResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserChargeStatusResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserChargeStatusResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserChargeStatusResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserChargeStatusResp_DataValidationError) ErrorName() string {
	return "UserChargeStatusResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserChargeStatusResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserChargeStatusResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserChargeStatusResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserChargeStatusResp_DataValidationError{}

// Validate checks the field values on RealNameNewResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RealNameNewResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealNameNewResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RealNameNewResp_DataMultiError, or nil if none found.
func (m *RealNameNewResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *RealNameNewResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CredentialId

	// no validation rules for Credential

	// no validation rules for CertifyAuditStatus

	if len(errors) > 0 {
		return RealNameNewResp_DataMultiError(errors)
	}

	return nil
}

// RealNameNewResp_DataMultiError is an error wrapping multiple validation
// errors returned by RealNameNewResp_Data.ValidateAll() if the designated
// constraints aren't met.
type RealNameNewResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealNameNewResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealNameNewResp_DataMultiError) AllErrors() []error { return m }

// RealNameNewResp_DataValidationError is the validation error returned by
// RealNameNewResp_Data.Validate if the designated constraints aren't met.
type RealNameNewResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealNameNewResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealNameNewResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealNameNewResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealNameNewResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealNameNewResp_DataValidationError) ErrorName() string {
	return "RealNameNewResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e RealNameNewResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealNameNewResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealNameNewResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealNameNewResp_DataValidationError{}

// Validate checks the field values on UserInvoiceListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoiceListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoiceListResp_DataMultiError, or nil if none found.
func (m *UserInvoiceListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserInvoiceListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserInvoiceListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserInvoiceListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserInvoiceListResp_DataMultiError(errors)
	}

	return nil
}

// UserInvoiceListResp_DataMultiError is an error wrapping multiple validation
// errors returned by UserInvoiceListResp_Data.ValidateAll() if the designated
// constraints aren't met.
type UserInvoiceListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceListResp_DataMultiError) AllErrors() []error { return m }

// UserInvoiceListResp_DataValidationError is the validation error returned by
// UserInvoiceListResp_Data.Validate if the designated constraints aren't met.
type UserInvoiceListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceListResp_DataValidationError) ErrorName() string {
	return "UserInvoiceListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceListResp_DataValidationError{}

// Validate checks the field values on UserInvoicedListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInvoicedListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoicedListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInvoicedListResp_DataMultiError, or nil if none found.
func (m *UserInvoicedListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoicedListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserInvoicedListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserInvoicedListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserInvoicedListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserInvoicedListResp_DataMultiError(errors)
	}

	return nil
}

// UserInvoicedListResp_DataMultiError is an error wrapping multiple validation
// errors returned by UserInvoicedListResp_Data.ValidateAll() if the
// designated constraints aren't met.
type UserInvoicedListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoicedListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoicedListResp_DataMultiError) AllErrors() []error { return m }

// UserInvoicedListResp_DataValidationError is the validation error returned by
// UserInvoicedListResp_Data.Validate if the designated constraints aren't met.
type UserInvoicedListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoicedListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoicedListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoicedListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoicedListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoicedListResp_DataValidationError) ErrorName() string {
	return "UserInvoicedListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoicedListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoicedListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoicedListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoicedListResp_DataValidationError{}

// Validate checks the field values on UserInvoicedInclusiveMonthResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UserInvoicedInclusiveMonthResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoicedInclusiveMonthResp_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UserInvoicedInclusiveMonthResp_DataMultiError, or nil if none found.
func (m *UserInvoicedInclusiveMonthResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoicedInclusiveMonthResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserInvoicedInclusiveMonthResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserInvoicedInclusiveMonthResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserInvoicedInclusiveMonthResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserInvoicedInclusiveMonthResp_DataMultiError(errors)
	}

	return nil
}

// UserInvoicedInclusiveMonthResp_DataMultiError is an error wrapping multiple
// validation errors returned by
// UserInvoicedInclusiveMonthResp_Data.ValidateAll() if the designated
// constraints aren't met.
type UserInvoicedInclusiveMonthResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoicedInclusiveMonthResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoicedInclusiveMonthResp_DataMultiError) AllErrors() []error { return m }

// UserInvoicedInclusiveMonthResp_DataValidationError is the validation error
// returned by UserInvoicedInclusiveMonthResp_Data.Validate if the designated
// constraints aren't met.
type UserInvoicedInclusiveMonthResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoicedInclusiveMonthResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoicedInclusiveMonthResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoicedInclusiveMonthResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoicedInclusiveMonthResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoicedInclusiveMonthResp_DataValidationError) ErrorName() string {
	return "UserInvoicedInclusiveMonthResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoicedInclusiveMonthResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoicedInclusiveMonthResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoicedInclusiveMonthResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoicedInclusiveMonthResp_DataValidationError{}

// Validate checks the field values on UserInvoiceConsumptiveDetailResp_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UserInvoiceConsumptiveDetailResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInvoiceConsumptiveDetailResp_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UserInvoiceConsumptiveDetailResp_DataMultiError, or nil if none found.
func (m *UserInvoiceConsumptiveDetailResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInvoiceConsumptiveDetailResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserInvoiceConsumptiveDetailResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserInvoiceConsumptiveDetailResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserInvoiceConsumptiveDetailResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserInvoiceConsumptiveDetailResp_DataMultiError(errors)
	}

	return nil
}

// UserInvoiceConsumptiveDetailResp_DataMultiError is an error wrapping
// multiple validation errors returned by
// UserInvoiceConsumptiveDetailResp_Data.ValidateAll() if the designated
// constraints aren't met.
type UserInvoiceConsumptiveDetailResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInvoiceConsumptiveDetailResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInvoiceConsumptiveDetailResp_DataMultiError) AllErrors() []error { return m }

// UserInvoiceConsumptiveDetailResp_DataValidationError is the validation error
// returned by UserInvoiceConsumptiveDetailResp_Data.Validate if the
// designated constraints aren't met.
type UserInvoiceConsumptiveDetailResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInvoiceConsumptiveDetailResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInvoiceConsumptiveDetailResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInvoiceConsumptiveDetailResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInvoiceConsumptiveDetailResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInvoiceConsumptiveDetailResp_DataValidationError) ErrorName() string {
	return "UserInvoiceConsumptiveDetailResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserInvoiceConsumptiveDetailResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInvoiceConsumptiveDetailResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInvoiceConsumptiveDetailResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInvoiceConsumptiveDetailResp_DataValidationError{}

// Validate checks the field values on UserAdminInvoiceListResp_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserAdminInvoiceListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAdminInvoiceListResp_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserAdminInvoiceListResp_DataMultiError, or nil if none found.
func (m *UserAdminInvoiceListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserAdminInvoiceListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserAdminInvoiceListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserAdminInvoiceListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserAdminInvoiceListResp_DataMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceListResp_DataMultiError is an error wrapping multiple
// validation errors returned by UserAdminInvoiceListResp_Data.ValidateAll()
// if the designated constraints aren't met.
type UserAdminInvoiceListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceListResp_DataMultiError) AllErrors() []error { return m }

// UserAdminInvoiceListResp_DataValidationError is the validation error
// returned by UserAdminInvoiceListResp_Data.Validate if the designated
// constraints aren't met.
type UserAdminInvoiceListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceListResp_DataValidationError) ErrorName() string {
	return "UserAdminInvoiceListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceListResp_DataValidationError{}

// Validate checks the field values on UserAdminInvoiceGetMonthsInfoResp_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UserAdminInvoiceGetMonthsInfoResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UserAdminInvoiceGetMonthsInfoResp_Data with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// UserAdminInvoiceGetMonthsInfoResp_DataMultiError, or nil if none found.
func (m *UserAdminInvoiceGetMonthsInfoResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminInvoiceGetMonthsInfoResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserAdminInvoiceGetMonthsInfoResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserAdminInvoiceGetMonthsInfoResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserAdminInvoiceGetMonthsInfoResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserAdminInvoiceGetMonthsInfoResp_DataMultiError(errors)
	}

	return nil
}

// UserAdminInvoiceGetMonthsInfoResp_DataMultiError is an error wrapping
// multiple validation errors returned by
// UserAdminInvoiceGetMonthsInfoResp_Data.ValidateAll() if the designated
// constraints aren't met.
type UserAdminInvoiceGetMonthsInfoResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminInvoiceGetMonthsInfoResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminInvoiceGetMonthsInfoResp_DataMultiError) AllErrors() []error { return m }

// UserAdminInvoiceGetMonthsInfoResp_DataValidationError is the validation
// error returned by UserAdminInvoiceGetMonthsInfoResp_Data.Validate if the
// designated constraints aren't met.
type UserAdminInvoiceGetMonthsInfoResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminInvoiceGetMonthsInfoResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminInvoiceGetMonthsInfoResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminInvoiceGetMonthsInfoResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminInvoiceGetMonthsInfoResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminInvoiceGetMonthsInfoResp_DataValidationError) ErrorName() string {
	return "UserAdminInvoiceGetMonthsInfoResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminInvoiceGetMonthsInfoResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminInvoiceGetMonthsInfoResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminInvoiceGetMonthsInfoResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminInvoiceGetMonthsInfoResp_DataValidationError{}

// Validate checks the field values on UserAdminGetConsumptiveDetailResp_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UserAdminGetConsumptiveDetailResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UserAdminGetConsumptiveDetailResp_Data with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// UserAdminGetConsumptiveDetailResp_DataMultiError, or nil if none found.
func (m *UserAdminGetConsumptiveDetailResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAdminGetConsumptiveDetailResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserAdminGetConsumptiveDetailResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserAdminGetConsumptiveDetailResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserAdminGetConsumptiveDetailResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserAdminGetConsumptiveDetailResp_DataMultiError(errors)
	}

	return nil
}

// UserAdminGetConsumptiveDetailResp_DataMultiError is an error wrapping
// multiple validation errors returned by
// UserAdminGetConsumptiveDetailResp_Data.ValidateAll() if the designated
// constraints aren't met.
type UserAdminGetConsumptiveDetailResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAdminGetConsumptiveDetailResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAdminGetConsumptiveDetailResp_DataMultiError) AllErrors() []error { return m }

// UserAdminGetConsumptiveDetailResp_DataValidationError is the validation
// error returned by UserAdminGetConsumptiveDetailResp_Data.Validate if the
// designated constraints aren't met.
type UserAdminGetConsumptiveDetailResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAdminGetConsumptiveDetailResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAdminGetConsumptiveDetailResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAdminGetConsumptiveDetailResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAdminGetConsumptiveDetailResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAdminGetConsumptiveDetailResp_DataValidationError) ErrorName() string {
	return "UserAdminGetConsumptiveDetailResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UserAdminGetConsumptiveDetailResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAdminGetConsumptiveDetailResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAdminGetConsumptiveDetailResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAdminGetConsumptiveDetailResp_DataValidationError{}
