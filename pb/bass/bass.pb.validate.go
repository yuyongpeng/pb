// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pb/bass/bass.proto

package bass

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on NewTxIdReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NewTxIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NewTxIdReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NewTxIdReqMultiError, or
// nil if none found.
func (m *NewTxIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *NewTxIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	if len(errors) > 0 {
		return NewTxIdReqMultiError(errors)
	}

	return nil
}

// NewTxIdReqMultiError is an error wrapping multiple validation errors
// returned by NewTxIdReq.ValidateAll() if the designated constraints aren't met.
type NewTxIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NewTxIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NewTxIdReqMultiError) AllErrors() []error { return m }

// NewTxIdReqValidationError is the validation error returned by
// NewTxIdReq.Validate if the designated constraints aren't met.
type NewTxIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NewTxIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NewTxIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NewTxIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NewTxIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NewTxIdReqValidationError) ErrorName() string { return "NewTxIdReqValidationError" }

// Error satisfies the builtin error interface
func (e NewTxIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNewTxIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NewTxIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NewTxIdReqValidationError{}

// Validate checks the field values on NewTxIdResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NewTxIdResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NewTxIdResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NewTxIdRespMultiError, or
// nil if none found.
func (m *NewTxIdResp) ValidateAll() error {
	return m.validate(true)
}

func (m *NewTxIdResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NewTxIdRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NewTxIdRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NewTxIdRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NewTxIdRespMultiError(errors)
	}

	return nil
}

// NewTxIdRespMultiError is an error wrapping multiple validation errors
// returned by NewTxIdResp.ValidateAll() if the designated constraints aren't met.
type NewTxIdRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NewTxIdRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NewTxIdRespMultiError) AllErrors() []error { return m }

// NewTxIdRespValidationError is the validation error returned by
// NewTxIdResp.Validate if the designated constraints aren't met.
type NewTxIdRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NewTxIdRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NewTxIdRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NewTxIdRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NewTxIdRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NewTxIdRespValidationError) ErrorName() string { return "NewTxIdRespValidationError" }

// Error satisfies the builtin error interface
func (e NewTxIdRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNewTxIdResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NewTxIdRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NewTxIdRespValidationError{}

// Validate checks the field values on NewTxIdInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NewTxIdInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NewTxIdInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NewTxIdInfoMultiError, or
// nil if none found.
func (m *NewTxIdInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NewTxIdInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OperatorAddress

	// no validation rules for ContractAddress

	// no validation rules for TxId

	// no validation rules for BlockNumber

	if len(errors) > 0 {
		return NewTxIdInfoMultiError(errors)
	}

	return nil
}

// NewTxIdInfoMultiError is an error wrapping multiple validation errors
// returned by NewTxIdInfo.ValidateAll() if the designated constraints aren't met.
type NewTxIdInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NewTxIdInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NewTxIdInfoMultiError) AllErrors() []error { return m }

// NewTxIdInfoValidationError is the validation error returned by
// NewTxIdInfo.Validate if the designated constraints aren't met.
type NewTxIdInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NewTxIdInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NewTxIdInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NewTxIdInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NewTxIdInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NewTxIdInfoValidationError) ErrorName() string { return "NewTxIdInfoValidationError" }

// Error satisfies the builtin error interface
func (e NewTxIdInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNewTxIdInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NewTxIdInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NewTxIdInfoValidationError{}

// Validate checks the field values on SubmitProofInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SubmitProofInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitProofInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitProofInfoMultiError, or nil if none found.
func (m *SubmitProofInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitProofInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAppNo()) < 1 {
		err := SubmitProofInfoValidationError{
			field:  "AppNo",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProofContractAddress()) < 1 {
		err := SubmitProofInfoValidationError{
			field:  "ProofContractAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CredentialId

	if utf8.RuneCountInString(m.GetManageContractAddress()) < 1 {
		err := SubmitProofInfoValidationError{
			field:  "ManageContractAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOwnerAddress()) < 1 {
		err := SubmitProofInfoValidationError{
			field:  "OwnerAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Chain

	if len(errors) > 0 {
		return SubmitProofInfoMultiError(errors)
	}

	return nil
}

// SubmitProofInfoMultiError is an error wrapping multiple validation errors
// returned by SubmitProofInfo.ValidateAll() if the designated constraints
// aren't met.
type SubmitProofInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitProofInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitProofInfoMultiError) AllErrors() []error { return m }

// SubmitProofInfoValidationError is the validation error returned by
// SubmitProofInfo.Validate if the designated constraints aren't met.
type SubmitProofInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitProofInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitProofInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitProofInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitProofInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitProofInfoValidationError) ErrorName() string { return "SubmitProofInfoValidationError" }

// Error satisfies the builtin error interface
func (e SubmitProofInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitProofInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitProofInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitProofInfoValidationError{}

// Validate checks the field values on ProofOfDIDDeclareReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProofOfDIDDeclareReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProofOfDIDDeclareReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProofOfDIDDeclareReqMultiError, or nil if none found.
func (m *ProofOfDIDDeclareReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ProofOfDIDDeclareReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubmitProof()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProofOfDIDDeclareReqValidationError{
					field:  "SubmitProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProofOfDIDDeclareReqValidationError{
					field:  "SubmitProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmitProof()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProofOfDIDDeclareReqValidationError{
				field:  "SubmitProof",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProofOfDIDDeclareReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProofOfDIDDeclareReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProofOfDIDDeclareReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProofOfDIDDeclareReqMultiError(errors)
	}

	return nil
}

// ProofOfDIDDeclareReqMultiError is an error wrapping multiple validation
// errors returned by ProofOfDIDDeclareReq.ValidateAll() if the designated
// constraints aren't met.
type ProofOfDIDDeclareReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProofOfDIDDeclareReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProofOfDIDDeclareReqMultiError) AllErrors() []error { return m }

// ProofOfDIDDeclareReqValidationError is the validation error returned by
// ProofOfDIDDeclareReq.Validate if the designated constraints aren't met.
type ProofOfDIDDeclareReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProofOfDIDDeclareReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProofOfDIDDeclareReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProofOfDIDDeclareReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProofOfDIDDeclareReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProofOfDIDDeclareReqValidationError) ErrorName() string {
	return "ProofOfDIDDeclareReqValidationError"
}

// Error satisfies the builtin error interface
func (e ProofOfDIDDeclareReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProofOfDIDDeclareReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProofOfDIDDeclareReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProofOfDIDDeclareReqValidationError{}

// Validate checks the field values on ProofOfDIDDeclareData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProofOfDIDDeclareData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProofOfDIDDeclareData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProofOfDIDDeclareDataMultiError, or nil if none found.
func (m *ProofOfDIDDeclareData) ValidateAll() error {
	return m.validate(true)
}

func (m *ProofOfDIDDeclareData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetContext()) < 1 {
		err := ProofOfDIDDeclareDataValidationError{
			field:  "Context",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := ProofOfDIDDeclareDataValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetIssuer()) < 1 {
		err := ProofOfDIDDeclareDataValidationError{
			field:  "Issuer",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProof()) < 1 {
		err := ProofOfDIDDeclareDataValidationError{
			field:  "Proof",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProofOfDIDDeclareDataValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProofOfDIDDeclareDataValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProofOfDIDDeclareDataValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProofOfDIDDeclareDataMultiError(errors)
	}

	return nil
}

// ProofOfDIDDeclareDataMultiError is an error wrapping multiple validation
// errors returned by ProofOfDIDDeclareData.ValidateAll() if the designated
// constraints aren't met.
type ProofOfDIDDeclareDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProofOfDIDDeclareDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProofOfDIDDeclareDataMultiError) AllErrors() []error { return m }

// ProofOfDIDDeclareDataValidationError is the validation error returned by
// ProofOfDIDDeclareData.Validate if the designated constraints aren't met.
type ProofOfDIDDeclareDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProofOfDIDDeclareDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProofOfDIDDeclareDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProofOfDIDDeclareDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProofOfDIDDeclareDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProofOfDIDDeclareDataValidationError) ErrorName() string {
	return "ProofOfDIDDeclareDataValidationError"
}

// Error satisfies the builtin error interface
func (e ProofOfDIDDeclareDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProofOfDIDDeclareData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProofOfDIDDeclareDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProofOfDIDDeclareDataValidationError{}

// Validate checks the field values on ProofOfDIDDeclareClaim with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProofOfDIDDeclareClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProofOfDIDDeclareClaim with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProofOfDIDDeclareClaimMultiError, or nil if none found.
func (m *ProofOfDIDDeclareClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *ProofOfDIDDeclareClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDidType()) < 1 {
		err := ProofOfDIDDeclareClaimValidationError{
			field:  "DidType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := ProofOfDIDDeclareClaimValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Profile

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := ProofOfDIDDeclareClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Address

	// no validation rules for Extension

	if len(errors) > 0 {
		return ProofOfDIDDeclareClaimMultiError(errors)
	}

	return nil
}

// ProofOfDIDDeclareClaimMultiError is an error wrapping multiple validation
// errors returned by ProofOfDIDDeclareClaim.ValidateAll() if the designated
// constraints aren't met.
type ProofOfDIDDeclareClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProofOfDIDDeclareClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProofOfDIDDeclareClaimMultiError) AllErrors() []error { return m }

// ProofOfDIDDeclareClaimValidationError is the validation error returned by
// ProofOfDIDDeclareClaim.Validate if the designated constraints aren't met.
type ProofOfDIDDeclareClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProofOfDIDDeclareClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProofOfDIDDeclareClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProofOfDIDDeclareClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProofOfDIDDeclareClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProofOfDIDDeclareClaimValidationError) ErrorName() string {
	return "ProofOfDIDDeclareClaimValidationError"
}

// Error satisfies the builtin error interface
func (e ProofOfDIDDeclareClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProofOfDIDDeclareClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProofOfDIDDeclareClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProofOfDIDDeclareClaimValidationError{}

// Validate checks the field values on CopyrightClaimReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimReqMultiError, or nil if none found.
func (m *CopyrightClaimReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubmitProof()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimReqValidationError{
					field:  "SubmitProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimReqValidationError{
					field:  "SubmitProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmitProof()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimReqValidationError{
				field:  "SubmitProof",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightClaimReqMultiError(errors)
	}

	return nil
}

// CopyrightClaimReqMultiError is an error wrapping multiple validation errors
// returned by CopyrightClaimReq.ValidateAll() if the designated constraints
// aren't met.
type CopyrightClaimReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimReqMultiError) AllErrors() []error { return m }

// CopyrightClaimReqValidationError is the validation error returned by
// CopyrightClaimReq.Validate if the designated constraints aren't met.
type CopyrightClaimReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimReqValidationError) ErrorName() string {
	return "CopyrightClaimReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimReqValidationError{}

// Validate checks the field values on CopyrightClaimData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaimData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaimData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightClaimDataMultiError, or nil if none found.
func (m *CopyrightClaimData) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaimData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetContext()) < 1 {
		err := CopyrightClaimDataValidationError{
			field:  "Context",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := CopyrightClaimDataValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetIssuer()) < 1 {
		err := CopyrightClaimDataValidationError{
			field:  "Issuer",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProof()) < 1 {
		err := CopyrightClaimDataValidationError{
			field:  "Proof",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightClaimDataValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightClaimDataValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightClaimDataValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightClaimDataMultiError(errors)
	}

	return nil
}

// CopyrightClaimDataMultiError is an error wrapping multiple validation errors
// returned by CopyrightClaimData.ValidateAll() if the designated constraints
// aren't met.
type CopyrightClaimDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimDataMultiError) AllErrors() []error { return m }

// CopyrightClaimDataValidationError is the validation error returned by
// CopyrightClaimData.Validate if the designated constraints aren't met.
type CopyrightClaimDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimDataValidationError) ErrorName() string {
	return "CopyrightClaimDataValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightClaimDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaimData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimDataValidationError{}

// Validate checks the field values on CopyrightClaim with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CopyrightClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightClaim with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CopyrightClaimMultiError,
// or nil if none found.
func (m *CopyrightClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDidCredential()) < 1 {
		err := CopyrightClaimValidationError{
			field:  "DidCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Hash

	if utf8.RuneCountInString(m.GetClaimTitle()) < 1 {
		err := CopyrightClaimValidationError{
			field:  "ClaimTitle",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AttachUrl

	// no validation rules for Creator

	// no validation rules for CreativeTime

	// no validation rules for IsOriginal

	// no validation rules for CopyrightCategory

	// no validation rules for AuthorizedNumber

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := CopyrightClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return CopyrightClaimMultiError(errors)
	}

	return nil
}

// CopyrightClaimMultiError is an error wrapping multiple validation errors
// returned by CopyrightClaim.ValidateAll() if the designated constraints
// aren't met.
type CopyrightClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightClaimMultiError) AllErrors() []error { return m }

// CopyrightClaimValidationError is the validation error returned by
// CopyrightClaim.Validate if the designated constraints aren't met.
type CopyrightClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightClaimValidationError) ErrorName() string { return "CopyrightClaimValidationError" }

// Error satisfies the builtin error interface
func (e CopyrightClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightClaimValidationError{}

// Validate checks the field values on CopyrightAuthorizationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightAuthorizationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightAuthorizationReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightAuthorizationReqMultiError, or nil if none found.
func (m *CopyrightAuthorizationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightAuthorizationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubmitProof()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightAuthorizationReqValidationError{
					field:  "SubmitProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightAuthorizationReqValidationError{
					field:  "SubmitProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmitProof()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightAuthorizationReqValidationError{
				field:  "SubmitProof",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightAuthorizationReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightAuthorizationReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightAuthorizationReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightAuthorizationReqMultiError(errors)
	}

	return nil
}

// CopyrightAuthorizationReqMultiError is an error wrapping multiple validation
// errors returned by CopyrightAuthorizationReq.ValidateAll() if the
// designated constraints aren't met.
type CopyrightAuthorizationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightAuthorizationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightAuthorizationReqMultiError) AllErrors() []error { return m }

// CopyrightAuthorizationReqValidationError is the validation error returned by
// CopyrightAuthorizationReq.Validate if the designated constraints aren't met.
type CopyrightAuthorizationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightAuthorizationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightAuthorizationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightAuthorizationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightAuthorizationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightAuthorizationReqValidationError) ErrorName() string {
	return "CopyrightAuthorizationReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightAuthorizationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightAuthorizationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightAuthorizationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightAuthorizationReqValidationError{}

// Validate checks the field values on CopyrightAuthorizationData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightAuthorizationData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightAuthorizationData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightAuthorizationDataMultiError, or nil if none found.
func (m *CopyrightAuthorizationData) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightAuthorizationData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetContext()) < 1 {
		err := CopyrightAuthorizationDataValidationError{
			field:  "Context",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := CopyrightAuthorizationDataValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetIssuer()) < 1 {
		err := CopyrightAuthorizationDataValidationError{
			field:  "Issuer",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProof()) < 1 {
		err := CopyrightAuthorizationDataValidationError{
			field:  "Proof",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyrightAuthorizationDataValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyrightAuthorizationDataValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyrightAuthorizationDataValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CopyrightAuthorizationDataMultiError(errors)
	}

	return nil
}

// CopyrightAuthorizationDataMultiError is an error wrapping multiple
// validation errors returned by CopyrightAuthorizationData.ValidateAll() if
// the designated constraints aren't met.
type CopyrightAuthorizationDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightAuthorizationDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightAuthorizationDataMultiError) AllErrors() []error { return m }

// CopyrightAuthorizationDataValidationError is the validation error returned
// by CopyrightAuthorizationData.Validate if the designated constraints aren't met.
type CopyrightAuthorizationDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightAuthorizationDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightAuthorizationDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightAuthorizationDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightAuthorizationDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightAuthorizationDataValidationError) ErrorName() string {
	return "CopyrightAuthorizationDataValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightAuthorizationDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightAuthorizationData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightAuthorizationDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightAuthorizationDataValidationError{}

// Validate checks the field values on CopyrightAuthorizationClaim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CopyrightAuthorizationClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyrightAuthorizationClaim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopyrightAuthorizationClaimMultiError, or nil if none found.
func (m *CopyrightAuthorizationClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyrightAuthorizationClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDidCredential()) < 1 {
		err := CopyrightAuthorizationClaimValidationError{
			field:  "DidCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCopyrightCredential()) < 1 {
		err := CopyrightAuthorizationClaimValidationError{
			field:  "CopyrightCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizationCategory()) < 1 {
		err := CopyrightAuthorizationClaimValidationError{
			field:  "AuthorizationCategory",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AuthorizedNumber

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := CopyrightAuthorizationClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return CopyrightAuthorizationClaimMultiError(errors)
	}

	return nil
}

// CopyrightAuthorizationClaimMultiError is an error wrapping multiple
// validation errors returned by CopyrightAuthorizationClaim.ValidateAll() if
// the designated constraints aren't met.
type CopyrightAuthorizationClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyrightAuthorizationClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyrightAuthorizationClaimMultiError) AllErrors() []error { return m }

// CopyrightAuthorizationClaimValidationError is the validation error returned
// by CopyrightAuthorizationClaim.Validate if the designated constraints
// aren't met.
type CopyrightAuthorizationClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyrightAuthorizationClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyrightAuthorizationClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyrightAuthorizationClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyrightAuthorizationClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyrightAuthorizationClaimValidationError) ErrorName() string {
	return "CopyrightAuthorizationClaimValidationError"
}

// Error satisfies the builtin error interface
func (e CopyrightAuthorizationClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyrightAuthorizationClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyrightAuthorizationClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyrightAuthorizationClaimValidationError{}

// Validate checks the field values on CollectionCredentialReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCredentialReqMultiError, or nil if none found.
func (m *CollectionCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubmitProof()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCredentialReqValidationError{
					field:  "SubmitProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCredentialReqValidationError{
					field:  "SubmitProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmitProof()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCredentialReqValidationError{
				field:  "SubmitProof",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCredentialReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCredentialReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCredentialReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionCredentialReqMultiError(errors)
	}

	return nil
}

// CollectionCredentialReqMultiError is an error wrapping multiple validation
// errors returned by CollectionCredentialReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCredentialReqMultiError) AllErrors() []error { return m }

// CollectionCredentialReqValidationError is the validation error returned by
// CollectionCredentialReq.Validate if the designated constraints aren't met.
type CollectionCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCredentialReqValidationError) ErrorName() string {
	return "CollectionCredentialReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCredentialReqValidationError{}

// Validate checks the field values on CollectionCredentialData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCredentialData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCredentialData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCredentialDataMultiError, or nil if none found.
func (m *CollectionCredentialData) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCredentialData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetContext()) < 1 {
		err := CollectionCredentialDataValidationError{
			field:  "Context",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := CollectionCredentialDataValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetIssuer()) < 1 {
		err := CollectionCredentialDataValidationError{
			field:  "Issuer",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProof()) < 1 {
		err := CollectionCredentialDataValidationError{
			field:  "Proof",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCredentialDataValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCredentialDataValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCredentialDataValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionCredentialDataMultiError(errors)
	}

	return nil
}

// CollectionCredentialDataMultiError is an error wrapping multiple validation
// errors returned by CollectionCredentialData.ValidateAll() if the designated
// constraints aren't met.
type CollectionCredentialDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCredentialDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCredentialDataMultiError) AllErrors() []error { return m }

// CollectionCredentialDataValidationError is the validation error returned by
// CollectionCredentialData.Validate if the designated constraints aren't met.
type CollectionCredentialDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCredentialDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCredentialDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCredentialDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCredentialDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCredentialDataValidationError) ErrorName() string {
	return "CollectionCredentialDataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCredentialDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCredentialData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCredentialDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCredentialDataValidationError{}

// Validate checks the field values on CollectionCredentialClaim with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCredentialClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCredentialClaim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCredentialClaimMultiError, or nil if none found.
func (m *CollectionCredentialClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCredentialClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCollectionName()) < 1 {
		err := CollectionCredentialClaimValidationError{
			field:  "CollectionName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClaimSignAddress()) < 1 {
		err := CollectionCredentialClaimValidationError{
			field:  "ClaimSignAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDidCredential()) < 1 {
		err := CollectionCredentialClaimValidationError{
			field:  "DidCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCopyrightCredential()) < 1 {
		err := CollectionCredentialClaimValidationError{
			field:  "CopyrightCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizationCredential()) < 1 {
		err := CollectionCredentialClaimValidationError{
			field:  "AuthorizationCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CollectionHash

	// no validation rules for TokenId

	if utf8.RuneCountInString(m.GetFrom()) < 1 {
		err := CollectionCredentialClaimValidationError{
			field:  "From",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := CollectionCredentialClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return CollectionCredentialClaimMultiError(errors)
	}

	return nil
}

// CollectionCredentialClaimMultiError is an error wrapping multiple validation
// errors returned by CollectionCredentialClaim.ValidateAll() if the
// designated constraints aren't met.
type CollectionCredentialClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCredentialClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCredentialClaimMultiError) AllErrors() []error { return m }

// CollectionCredentialClaimValidationError is the validation error returned by
// CollectionCredentialClaim.Validate if the designated constraints aren't met.
type CollectionCredentialClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCredentialClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCredentialClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCredentialClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCredentialClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCredentialClaimValidationError) ErrorName() string {
	return "CollectionCredentialClaimValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCredentialClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCredentialClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCredentialClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCredentialClaimValidationError{}

// Validate checks the field values on CollectionTransferCredentialReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionTransferCredentialReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTransferCredentialReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionTransferCredentialReqMultiError, or nil if none found.
func (m *CollectionTransferCredentialReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTransferCredentialReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubmitProof()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionTransferCredentialReqValidationError{
					field:  "SubmitProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionTransferCredentialReqValidationError{
					field:  "SubmitProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmitProof()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionTransferCredentialReqValidationError{
				field:  "SubmitProof",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionTransferCredentialReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionTransferCredentialReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionTransferCredentialReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionTransferCredentialReqMultiError(errors)
	}

	return nil
}

// CollectionTransferCredentialReqMultiError is an error wrapping multiple
// validation errors returned by CollectionTransferCredentialReq.ValidateAll()
// if the designated constraints aren't met.
type CollectionTransferCredentialReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTransferCredentialReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTransferCredentialReqMultiError) AllErrors() []error { return m }

// CollectionTransferCredentialReqValidationError is the validation error
// returned by CollectionTransferCredentialReq.Validate if the designated
// constraints aren't met.
type CollectionTransferCredentialReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTransferCredentialReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTransferCredentialReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTransferCredentialReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTransferCredentialReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTransferCredentialReqValidationError) ErrorName() string {
	return "CollectionTransferCredentialReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTransferCredentialReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTransferCredentialReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTransferCredentialReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTransferCredentialReqValidationError{}

// Validate checks the field values on CollectionTransferCredentialData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CollectionTransferCredentialData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTransferCredentialData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CollectionTransferCredentialDataMultiError, or nil if none found.
func (m *CollectionTransferCredentialData) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTransferCredentialData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetContext()) < 1 {
		err := CollectionTransferCredentialDataValidationError{
			field:  "Context",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := CollectionTransferCredentialDataValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetIssuer()) < 1 {
		err := CollectionTransferCredentialDataValidationError{
			field:  "Issuer",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProof()) < 1 {
		err := CollectionTransferCredentialDataValidationError{
			field:  "Proof",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionTransferCredentialDataValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionTransferCredentialDataValidationError{
					field:  "Claim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionTransferCredentialDataValidationError{
				field:  "Claim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionTransferCredentialDataMultiError(errors)
	}

	return nil
}

// CollectionTransferCredentialDataMultiError is an error wrapping multiple
// validation errors returned by
// CollectionTransferCredentialData.ValidateAll() if the designated
// constraints aren't met.
type CollectionTransferCredentialDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTransferCredentialDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTransferCredentialDataMultiError) AllErrors() []error { return m }

// CollectionTransferCredentialDataValidationError is the validation error
// returned by CollectionTransferCredentialData.Validate if the designated
// constraints aren't met.
type CollectionTransferCredentialDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTransferCredentialDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTransferCredentialDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTransferCredentialDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTransferCredentialDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTransferCredentialDataValidationError) ErrorName() string {
	return "CollectionTransferCredentialDataValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTransferCredentialDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTransferCredentialData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTransferCredentialDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTransferCredentialDataValidationError{}

// Validate checks the field values on CollectionTransferCredentialClaim with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CollectionTransferCredentialClaim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionTransferCredentialClaim
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CollectionTransferCredentialClaimMultiError, or nil if none found.
func (m *CollectionTransferCredentialClaim) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionTransferCredentialClaim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCollectionName()) < 1 {
		err := CollectionTransferCredentialClaimValidationError{
			field:  "CollectionName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClaimSignAddress()) < 1 {
		err := CollectionTransferCredentialClaimValidationError{
			field:  "ClaimSignAddress",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDidCredential()) < 1 {
		err := CollectionTransferCredentialClaimValidationError{
			field:  "DidCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCopyrightCredential()) < 1 {
		err := CollectionTransferCredentialClaimValidationError{
			field:  "CopyrightCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthorizationCredential()) < 1 {
		err := CollectionTransferCredentialClaimValidationError{
			field:  "AuthorizationCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCollectionCredential()) < 1 {
		err := CollectionTransferCredentialClaimValidationError{
			field:  "CollectionCredential",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PreviousTransactionCredential

	// no validation rules for CollectionHash

	// no validation rules for TokenId

	if utf8.RuneCountInString(m.GetFrom()) < 1 {
		err := CollectionTransferCredentialClaimValidationError{
			field:  "From",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTo()) < 1 {
		err := CollectionTransferCredentialClaimValidationError{
			field:  "To",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDeclareTime()) < 1 {
		err := CollectionTransferCredentialClaimValidationError{
			field:  "DeclareTime",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Extension

	if len(errors) > 0 {
		return CollectionTransferCredentialClaimMultiError(errors)
	}

	return nil
}

// CollectionTransferCredentialClaimMultiError is an error wrapping multiple
// validation errors returned by
// CollectionTransferCredentialClaim.ValidateAll() if the designated
// constraints aren't met.
type CollectionTransferCredentialClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionTransferCredentialClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionTransferCredentialClaimMultiError) AllErrors() []error { return m }

// CollectionTransferCredentialClaimValidationError is the validation error
// returned by CollectionTransferCredentialClaim.Validate if the designated
// constraints aren't met.
type CollectionTransferCredentialClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionTransferCredentialClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionTransferCredentialClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionTransferCredentialClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionTransferCredentialClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionTransferCredentialClaimValidationError) ErrorName() string {
	return "CollectionTransferCredentialClaimValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionTransferCredentialClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionTransferCredentialClaim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionTransferCredentialClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionTransferCredentialClaimValidationError{}

// Validate checks the field values on BatchPostInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BatchPostInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchPostInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BatchPostInfoMultiError, or
// nil if none found.
func (m *BatchPostInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchPostInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceType

	// no validation rules for Address

	// no validation rules for Chain

	if len(errors) > 0 {
		return BatchPostInfoMultiError(errors)
	}

	return nil
}

// BatchPostInfoMultiError is an error wrapping multiple validation errors
// returned by BatchPostInfo.ValidateAll() if the designated constraints
// aren't met.
type BatchPostInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchPostInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchPostInfoMultiError) AllErrors() []error { return m }

// BatchPostInfoValidationError is the validation error returned by
// BatchPostInfo.Validate if the designated constraints aren't met.
type BatchPostInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchPostInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchPostInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchPostInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchPostInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchPostInfoValidationError) ErrorName() string { return "BatchPostInfoValidationError" }

// Error satisfies the builtin error interface
func (e BatchPostInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchPostInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchPostInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchPostInfoValidationError{}

// Validate checks the field values on BatchPostMintReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BatchPostMintReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchPostMintReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchPostMintReqMultiError, or nil if none found.
func (m *BatchPostMintReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchPostMintReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBatchPost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchPostMintReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchPostMintReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBatchPost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchPostMintReqValidationError{
				field:  "BatchPost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetArgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchPostMintReqValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchPostMintReqValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchPostMintReqValidationError{
					field:  fmt.Sprintf("Args[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchPostMintReqMultiError(errors)
	}

	return nil
}

// BatchPostMintReqMultiError is an error wrapping multiple validation errors
// returned by BatchPostMintReq.ValidateAll() if the designated constraints
// aren't met.
type BatchPostMintReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchPostMintReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchPostMintReqMultiError) AllErrors() []error { return m }

// BatchPostMintReqValidationError is the validation error returned by
// BatchPostMintReq.Validate if the designated constraints aren't met.
type BatchPostMintReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchPostMintReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchPostMintReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchPostMintReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchPostMintReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchPostMintReqValidationError) ErrorName() string { return "BatchPostMintReqValidationError" }

// Error satisfies the builtin error interface
func (e BatchPostMintReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchPostMintReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchPostMintReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchPostMintReqValidationError{}

// Validate checks the field values on CollectionNotifyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionNotifyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionNotifyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionNotifyReqMultiError, or nil if none found.
func (m *CollectionNotifyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionNotifyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceId

	// no validation rules for SourceType

	// no validation rules for AppNo

	// no validation rules for NotifyUrl

	// no validation rules for NotifyOpts

	if len(errors) > 0 {
		return CollectionNotifyReqMultiError(errors)
	}

	return nil
}

// CollectionNotifyReqMultiError is an error wrapping multiple validation
// errors returned by CollectionNotifyReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionNotifyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionNotifyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionNotifyReqMultiError) AllErrors() []error { return m }

// CollectionNotifyReqValidationError is the validation error returned by
// CollectionNotifyReq.Validate if the designated constraints aren't met.
type CollectionNotifyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionNotifyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionNotifyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionNotifyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionNotifyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionNotifyReqValidationError) ErrorName() string {
	return "CollectionNotifyReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionNotifyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionNotifyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionNotifyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionNotifyReqValidationError{}

// Validate checks the field values on TxMintBatchArgs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TxMintBatchArgs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxMintBatchArgs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TxMintBatchArgsMultiError, or nil if none found.
func (m *TxMintBatchArgs) ValidateAll() error {
	return m.validate(true)
}

func (m *TxMintBatchArgs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Owner

	// no validation rules for TokenId

	// no validation rules for Uri

	// no validation rules for IdType

	if len(errors) > 0 {
		return TxMintBatchArgsMultiError(errors)
	}

	return nil
}

// TxMintBatchArgsMultiError is an error wrapping multiple validation errors
// returned by TxMintBatchArgs.ValidateAll() if the designated constraints
// aren't met.
type TxMintBatchArgsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxMintBatchArgsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxMintBatchArgsMultiError) AllErrors() []error { return m }

// TxMintBatchArgsValidationError is the validation error returned by
// TxMintBatchArgs.Validate if the designated constraints aren't met.
type TxMintBatchArgsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxMintBatchArgsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxMintBatchArgsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxMintBatchArgsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxMintBatchArgsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxMintBatchArgsValidationError) ErrorName() string { return "TxMintBatchArgsValidationError" }

// Error satisfies the builtin error interface
func (e TxMintBatchArgsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxMintBatchArgs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxMintBatchArgsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxMintBatchArgsValidationError{}

// Validate checks the field values on BatchPostTransferReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchPostTransferReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchPostTransferReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchPostTransferReqMultiError, or nil if none found.
func (m *BatchPostTransferReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchPostTransferReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBatchPost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchPostTransferReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchPostTransferReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBatchPost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchPostTransferReqValidationError{
				field:  "BatchPost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetArgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchPostTransferReqValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchPostTransferReqValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchPostTransferReqValidationError{
					field:  fmt.Sprintf("Args[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchPostTransferReqMultiError(errors)
	}

	return nil
}

// BatchPostTransferReqMultiError is an error wrapping multiple validation
// errors returned by BatchPostTransferReq.ValidateAll() if the designated
// constraints aren't met.
type BatchPostTransferReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchPostTransferReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchPostTransferReqMultiError) AllErrors() []error { return m }

// BatchPostTransferReqValidationError is the validation error returned by
// BatchPostTransferReq.Validate if the designated constraints aren't met.
type BatchPostTransferReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchPostTransferReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchPostTransferReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchPostTransferReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchPostTransferReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchPostTransferReqValidationError) ErrorName() string {
	return "BatchPostTransferReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchPostTransferReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchPostTransferReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchPostTransferReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchPostTransferReqValidationError{}

// Validate checks the field values on TxTransferBatchArgs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TxTransferBatchArgs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxTransferBatchArgs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TxTransferBatchArgsMultiError, or nil if none found.
func (m *TxTransferBatchArgs) ValidateAll() error {
	return m.validate(true)
}

func (m *TxTransferBatchArgs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for To

	// no validation rules for TokenId

	// no validation rules for Data

	if len(errors) > 0 {
		return TxTransferBatchArgsMultiError(errors)
	}

	return nil
}

// TxTransferBatchArgsMultiError is an error wrapping multiple validation
// errors returned by TxTransferBatchArgs.ValidateAll() if the designated
// constraints aren't met.
type TxTransferBatchArgsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxTransferBatchArgsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxTransferBatchArgsMultiError) AllErrors() []error { return m }

// TxTransferBatchArgsValidationError is the validation error returned by
// TxTransferBatchArgs.Validate if the designated constraints aren't met.
type TxTransferBatchArgsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxTransferBatchArgsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxTransferBatchArgsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxTransferBatchArgsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxTransferBatchArgsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxTransferBatchArgsValidationError) ErrorName() string {
	return "TxTransferBatchArgsValidationError"
}

// Error satisfies the builtin error interface
func (e TxTransferBatchArgsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxTransferBatchArgs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxTransferBatchArgsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxTransferBatchArgsValidationError{}

// Validate checks the field values on BatchPostUseReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BatchPostUseReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchPostUseReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchPostUseReqMultiError, or nil if none found.
func (m *BatchPostUseReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchPostUseReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBatchPost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchPostUseReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchPostUseReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBatchPost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchPostUseReqValidationError{
				field:  "BatchPost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchPostUseReqMultiError(errors)
	}

	return nil
}

// BatchPostUseReqMultiError is an error wrapping multiple validation errors
// returned by BatchPostUseReq.ValidateAll() if the designated constraints
// aren't met.
type BatchPostUseReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchPostUseReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchPostUseReqMultiError) AllErrors() []error { return m }

// BatchPostUseReqValidationError is the validation error returned by
// BatchPostUseReq.Validate if the designated constraints aren't met.
type BatchPostUseReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchPostUseReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchPostUseReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchPostUseReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchPostUseReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchPostUseReqValidationError) ErrorName() string { return "BatchPostUseReqValidationError" }

// Error satisfies the builtin error interface
func (e BatchPostUseReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchPostUseReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchPostUseReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchPostUseReqValidationError{}

// Validate checks the field values on BatchNotifyReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BatchNotifyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchNotifyReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BatchNotifyReqMultiError,
// or nil if none found.
func (m *BatchNotifyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchNotifyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetTx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchNotifyReqValidationError{
					field:  "Tx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchNotifyReqValidationError{
					field:  "Tx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchNotifyReqValidationError{
				field:  "Tx",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReceipt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchNotifyReqValidationError{
					field:  "Receipt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchNotifyReqValidationError{
					field:  "Receipt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceipt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchNotifyReqValidationError{
				field:  "Receipt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchNotifyReqValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchNotifyReqValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchNotifyReqValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchNotifyReqMultiError(errors)
	}

	return nil
}

// BatchNotifyReqMultiError is an error wrapping multiple validation errors
// returned by BatchNotifyReq.ValidateAll() if the designated constraints
// aren't met.
type BatchNotifyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchNotifyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchNotifyReqMultiError) AllErrors() []error { return m }

// BatchNotifyReqValidationError is the validation error returned by
// BatchNotifyReq.Validate if the designated constraints aren't met.
type BatchNotifyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchNotifyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchNotifyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchNotifyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchNotifyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchNotifyReqValidationError) ErrorName() string { return "BatchNotifyReqValidationError" }

// Error satisfies the builtin error interface
func (e BatchNotifyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchNotifyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchNotifyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchNotifyReqValidationError{}

// Validate checks the field values on ChainNotifyReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChainNotifyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChainNotifyReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChainNotifyReqMultiError,
// or nil if none found.
func (m *ChainNotifyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ChainNotifyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainId

	// no validation rules for OperatorAddress

	// no validation rules for ContractAddress

	// no validation rules for TxId

	// no validation rules for BlockNumber

	// no validation rules for ChainStatus

	// no validation rules for ChainMsg

	// no validation rules for Opt

	if len(errors) > 0 {
		return ChainNotifyReqMultiError(errors)
	}

	return nil
}

// ChainNotifyReqMultiError is an error wrapping multiple validation errors
// returned by ChainNotifyReq.ValidateAll() if the designated constraints
// aren't met.
type ChainNotifyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChainNotifyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChainNotifyReqMultiError) AllErrors() []error { return m }

// ChainNotifyReqValidationError is the validation error returned by
// ChainNotifyReq.Validate if the designated constraints aren't met.
type ChainNotifyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChainNotifyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChainNotifyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChainNotifyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChainNotifyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChainNotifyReqValidationError) ErrorName() string { return "ChainNotifyReqValidationError" }

// Error satisfies the builtin error interface
func (e ChainNotifyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChainNotifyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChainNotifyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChainNotifyReqValidationError{}

// Validate checks the field values on BassResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BassResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BassResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BassRespMultiError, or nil
// if none found.
func (m *BassResp) ValidateAll() error {
	return m.validate(true)
}

func (m *BassResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if len(errors) > 0 {
		return BassRespMultiError(errors)
	}

	return nil
}

// BassRespMultiError is an error wrapping multiple validation errors returned
// by BassResp.ValidateAll() if the designated constraints aren't met.
type BassRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BassRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BassRespMultiError) AllErrors() []error { return m }

// BassRespValidationError is the validation error returned by
// BassResp.Validate if the designated constraints aren't met.
type BassRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BassRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BassRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BassRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BassRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BassRespValidationError) ErrorName() string { return "BassRespValidationError" }

// Error satisfies the builtin error interface
func (e BassRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBassResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BassRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BassRespValidationError{}

// Validate checks the field values on ChainListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChainListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChainListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChainListReqMultiError, or
// nil if none found.
func (m *ChainListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ChainListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainStatus

	// no validation rules for ChainTimeStart

	// no validation rules for ChainTimeEnd

	// no validation rules for CreateTimeStart

	// no validation rules for CreateTimeEnd

	// no validation rules for Page

	// no validation rules for Limit

	if len(errors) > 0 {
		return ChainListReqMultiError(errors)
	}

	return nil
}

// ChainListReqMultiError is an error wrapping multiple validation errors
// returned by ChainListReq.ValidateAll() if the designated constraints aren't met.
type ChainListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChainListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChainListReqMultiError) AllErrors() []error { return m }

// ChainListReqValidationError is the validation error returned by
// ChainListReq.Validate if the designated constraints aren't met.
type ChainListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChainListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChainListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChainListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChainListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChainListReqValidationError) ErrorName() string { return "ChainListReqValidationError" }

// Error satisfies the builtin error interface
func (e ChainListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChainListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChainListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChainListReqValidationError{}

// Validate checks the field values on ChainListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChainListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChainListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChainListRespMultiError, or
// nil if none found.
func (m *ChainListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ChainListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChainListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChainListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChainListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChainListRespMultiError(errors)
	}

	return nil
}

// ChainListRespMultiError is an error wrapping multiple validation errors
// returned by ChainListResp.ValidateAll() if the designated constraints
// aren't met.
type ChainListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChainListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChainListRespMultiError) AllErrors() []error { return m }

// ChainListRespValidationError is the validation error returned by
// ChainListResp.Validate if the designated constraints aren't met.
type ChainListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChainListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChainListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChainListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChainListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChainListRespValidationError) ErrorName() string { return "ChainListRespValidationError" }

// Error satisfies the builtin error interface
func (e ChainListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChainListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChainListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChainListRespValidationError{}

// Validate checks the field values on ChainInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChainInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChainInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChainInfoMultiError, or nil
// if none found.
func (m *ChainInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ChainInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainId

	// no validation rules for SourceIds

	// no validation rules for SourceType

	// no validation rules for Address

	// no validation rules for TokenIds

	// no validation rules for TxId

	// no validation rules for TxIdTmp

	// no validation rules for BlockNumber

	// no validation rules for ChainStatus

	// no validation rules for TxKafka

	// no validation rules for TxPostreq

	// no validation rules for TxPostres

	// no validation rules for TxNotifyReq

	// no validation rules for ChainFailMsg

	// no validation rules for RetryNum

	// no validation rules for ChainStartTime

	// no validation rules for ChainEndTime

	// no validation rules for ChainPort

	// no validation rules for ReqTopic

	// no validation rules for ResTopic

	// no validation rules for CreateTime

	// no validation rules for ModifyTime

	if len(errors) > 0 {
		return ChainInfoMultiError(errors)
	}

	return nil
}

// ChainInfoMultiError is an error wrapping multiple validation errors returned
// by ChainInfo.ValidateAll() if the designated constraints aren't met.
type ChainInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChainInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChainInfoMultiError) AllErrors() []error { return m }

// ChainInfoValidationError is the validation error returned by
// ChainInfo.Validate if the designated constraints aren't met.
type ChainInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChainInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChainInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChainInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChainInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChainInfoValidationError) ErrorName() string { return "ChainInfoValidationError" }

// Error satisfies the builtin error interface
func (e ChainInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChainInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChainInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChainInfoValidationError{}

// Validate checks the field values on ChainAgainReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChainAgainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChainAgainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChainAgainReqMultiError, or
// nil if none found.
func (m *ChainAgainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ChainAgainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChainIds()) < 1 {
		err := ChainAgainReqValidationError{
			field:  "ChainIds",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ChainAgainReqMultiError(errors)
	}

	return nil
}

// ChainAgainReqMultiError is an error wrapping multiple validation errors
// returned by ChainAgainReq.ValidateAll() if the designated constraints
// aren't met.
type ChainAgainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChainAgainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChainAgainReqMultiError) AllErrors() []error { return m }

// ChainAgainReqValidationError is the validation error returned by
// ChainAgainReq.Validate if the designated constraints aren't met.
type ChainAgainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChainAgainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChainAgainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChainAgainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChainAgainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChainAgainReqValidationError) ErrorName() string { return "ChainAgainReqValidationError" }

// Error satisfies the builtin error interface
func (e ChainAgainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChainAgainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChainAgainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChainAgainReqValidationError{}

// Validate checks the field values on TxCombinationBatchArgs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TxCombinationBatchArgs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxCombinationBatchArgs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TxCombinationBatchArgsMultiError, or nil if none found.
func (m *TxCombinationBatchArgs) ValidateAll() error {
	return m.validate(true)
}

func (m *TxCombinationBatchArgs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for To

	// no validation rules for TokenId

	// no validation rules for CheckStatus

	// no validation rules for Uri

	// no validation rules for IdType

	if len(errors) > 0 {
		return TxCombinationBatchArgsMultiError(errors)
	}

	return nil
}

// TxCombinationBatchArgsMultiError is an error wrapping multiple validation
// errors returned by TxCombinationBatchArgs.ValidateAll() if the designated
// constraints aren't met.
type TxCombinationBatchArgsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxCombinationBatchArgsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxCombinationBatchArgsMultiError) AllErrors() []error { return m }

// TxCombinationBatchArgsValidationError is the validation error returned by
// TxCombinationBatchArgs.Validate if the designated constraints aren't met.
type TxCombinationBatchArgsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxCombinationBatchArgsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxCombinationBatchArgsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxCombinationBatchArgsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxCombinationBatchArgsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxCombinationBatchArgsValidationError) ErrorName() string {
	return "TxCombinationBatchArgsValidationError"
}

// Error satisfies the builtin error interface
func (e TxCombinationBatchArgsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxCombinationBatchArgs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxCombinationBatchArgsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxCombinationBatchArgsValidationError{}

// Validate checks the field values on CombinationReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CombinationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CombinationReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CombinationReqMultiError,
// or nil if none found.
func (m *CombinationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CombinationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBatchPost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CombinationReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CombinationReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBatchPost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CombinationReqValidationError{
				field:  "BatchPost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetArgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CombinationReqValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CombinationReqValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CombinationReqValidationError{
					field:  fmt.Sprintf("Args[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CombinationReqMultiError(errors)
	}

	return nil
}

// CombinationReqMultiError is an error wrapping multiple validation errors
// returned by CombinationReq.ValidateAll() if the designated constraints
// aren't met.
type CombinationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CombinationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CombinationReqMultiError) AllErrors() []error { return m }

// CombinationReqValidationError is the validation error returned by
// CombinationReq.Validate if the designated constraints aren't met.
type CombinationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CombinationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CombinationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CombinationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CombinationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CombinationReqValidationError) ErrorName() string { return "CombinationReqValidationError" }

// Error satisfies the builtin error interface
func (e CombinationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCombinationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CombinationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CombinationReqValidationError{}

// Validate checks the field values on LockReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LockReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LockReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LockReqMultiError, or nil if none found.
func (m *LockReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LockReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBatchPost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LockReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LockReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBatchPost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LockReqValidationError{
				field:  "BatchPost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LockReqMultiError(errors)
	}

	return nil
}

// LockReqMultiError is an error wrapping multiple validation errors returned
// by LockReq.ValidateAll() if the designated constraints aren't met.
type LockReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LockReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LockReqMultiError) AllErrors() []error { return m }

// LockReqValidationError is the validation error returned by LockReq.Validate
// if the designated constraints aren't met.
type LockReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LockReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LockReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LockReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LockReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LockReqValidationError) ErrorName() string { return "LockReqValidationError" }

// Error satisfies the builtin error interface
func (e LockReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLockReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LockReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LockReqValidationError{}

// Validate checks the field values on UnlockReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UnlockReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnlockReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UnlockReqMultiError, or nil
// if none found.
func (m *UnlockReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UnlockReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBatchPost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnlockReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnlockReqValidationError{
					field:  "BatchPost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBatchPost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnlockReqValidationError{
				field:  "BatchPost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnlockReqMultiError(errors)
	}

	return nil
}

// UnlockReqMultiError is an error wrapping multiple validation errors returned
// by UnlockReq.ValidateAll() if the designated constraints aren't met.
type UnlockReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnlockReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnlockReqMultiError) AllErrors() []error { return m }

// UnlockReqValidationError is the validation error returned by
// UnlockReq.Validate if the designated constraints aren't met.
type UnlockReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnlockReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnlockReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnlockReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnlockReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnlockReqValidationError) ErrorName() string { return "UnlockReqValidationError" }

// Error satisfies the builtin error interface
func (e UnlockReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnlockReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnlockReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnlockReqValidationError{}

// Validate checks the field values on BatchNotifyReq_ChainNotifyTx with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchNotifyReq_ChainNotifyTx) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchNotifyReq_ChainNotifyTx with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchNotifyReq_ChainNotifyTxMultiError, or nil if none found.
func (m *BatchNotifyReq_ChainNotifyTx) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchNotifyReq_ChainNotifyTx) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Chain

	// no validation rules for Address

	// no validation rules for Method

	// no validation rules for Args

	// no validation rules for Account

	// no validation rules for Contract

	// no validation rules for Opts

	if len(errors) > 0 {
		return BatchNotifyReq_ChainNotifyTxMultiError(errors)
	}

	return nil
}

// BatchNotifyReq_ChainNotifyTxMultiError is an error wrapping multiple
// validation errors returned by BatchNotifyReq_ChainNotifyTx.ValidateAll() if
// the designated constraints aren't met.
type BatchNotifyReq_ChainNotifyTxMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchNotifyReq_ChainNotifyTxMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchNotifyReq_ChainNotifyTxMultiError) AllErrors() []error { return m }

// BatchNotifyReq_ChainNotifyTxValidationError is the validation error returned
// by BatchNotifyReq_ChainNotifyTx.Validate if the designated constraints
// aren't met.
type BatchNotifyReq_ChainNotifyTxValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchNotifyReq_ChainNotifyTxValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchNotifyReq_ChainNotifyTxValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchNotifyReq_ChainNotifyTxValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchNotifyReq_ChainNotifyTxValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchNotifyReq_ChainNotifyTxValidationError) ErrorName() string {
	return "BatchNotifyReq_ChainNotifyTxValidationError"
}

// Error satisfies the builtin error interface
func (e BatchNotifyReq_ChainNotifyTxValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchNotifyReq_ChainNotifyTx.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchNotifyReq_ChainNotifyTxValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchNotifyReq_ChainNotifyTxValidationError{}

// Validate checks the field values on BatchNotifyReq_ReceiptInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchNotifyReq_ReceiptInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchNotifyReq_ReceiptInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchNotifyReq_ReceiptInfoMultiError, or nil if none found.
func (m *BatchNotifyReq_ReceiptInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchNotifyReq_ReceiptInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BlockNumber

	// no validation rules for TransactionHash

	if len(errors) > 0 {
		return BatchNotifyReq_ReceiptInfoMultiError(errors)
	}

	return nil
}

// BatchNotifyReq_ReceiptInfoMultiError is an error wrapping multiple
// validation errors returned by BatchNotifyReq_ReceiptInfo.ValidateAll() if
// the designated constraints aren't met.
type BatchNotifyReq_ReceiptInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchNotifyReq_ReceiptInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchNotifyReq_ReceiptInfoMultiError) AllErrors() []error { return m }

// BatchNotifyReq_ReceiptInfoValidationError is the validation error returned
// by BatchNotifyReq_ReceiptInfo.Validate if the designated constraints aren't met.
type BatchNotifyReq_ReceiptInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchNotifyReq_ReceiptInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchNotifyReq_ReceiptInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchNotifyReq_ReceiptInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchNotifyReq_ReceiptInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchNotifyReq_ReceiptInfoValidationError) ErrorName() string {
	return "BatchNotifyReq_ReceiptInfoValidationError"
}

// Error satisfies the builtin error interface
func (e BatchNotifyReq_ReceiptInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchNotifyReq_ReceiptInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchNotifyReq_ReceiptInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchNotifyReq_ReceiptInfoValidationError{}

// Validate checks the field values on BatchNotifyReq_ErrorInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchNotifyReq_ErrorInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchNotifyReq_ErrorInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchNotifyReq_ErrorInfoMultiError, or nil if none found.
func (m *BatchNotifyReq_ErrorInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchNotifyReq_ErrorInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Errno

	// no validation rules for Description

	// no validation rules for Name

	// no validation rules for Message

	// no validation rules for Code

	if len(errors) > 0 {
		return BatchNotifyReq_ErrorInfoMultiError(errors)
	}

	return nil
}

// BatchNotifyReq_ErrorInfoMultiError is an error wrapping multiple validation
// errors returned by BatchNotifyReq_ErrorInfo.ValidateAll() if the designated
// constraints aren't met.
type BatchNotifyReq_ErrorInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchNotifyReq_ErrorInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchNotifyReq_ErrorInfoMultiError) AllErrors() []error { return m }

// BatchNotifyReq_ErrorInfoValidationError is the validation error returned by
// BatchNotifyReq_ErrorInfo.Validate if the designated constraints aren't met.
type BatchNotifyReq_ErrorInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchNotifyReq_ErrorInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchNotifyReq_ErrorInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchNotifyReq_ErrorInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchNotifyReq_ErrorInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchNotifyReq_ErrorInfoValidationError) ErrorName() string {
	return "BatchNotifyReq_ErrorInfoValidationError"
}

// Error satisfies the builtin error interface
func (e BatchNotifyReq_ErrorInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchNotifyReq_ErrorInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchNotifyReq_ErrorInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchNotifyReq_ErrorInfoValidationError{}

// Validate checks the field values on ChainListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChainListResp_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChainListResp_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChainListResp_DataMultiError, or nil if none found.
func (m *ChainListResp_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *ChainListResp_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChainListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChainListResp_DataValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChainListResp_DataValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChainListResp_DataMultiError(errors)
	}

	return nil
}

// ChainListResp_DataMultiError is an error wrapping multiple validation errors
// returned by ChainListResp_Data.ValidateAll() if the designated constraints
// aren't met.
type ChainListResp_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChainListResp_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChainListResp_DataMultiError) AllErrors() []error { return m }

// ChainListResp_DataValidationError is the validation error returned by
// ChainListResp_Data.Validate if the designated constraints aren't met.
type ChainListResp_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChainListResp_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChainListResp_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChainListResp_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChainListResp_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChainListResp_DataValidationError) ErrorName() string {
	return "ChainListResp_DataValidationError"
}

// Error satisfies the builtin error interface
func (e ChainListResp_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChainListResp_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChainListResp_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChainListResp_DataValidationError{}
