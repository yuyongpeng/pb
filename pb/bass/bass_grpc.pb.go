// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: pb/bass/bass.proto

package bass

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	BassService_GetNewTxId_FullMethodName                   = "/daop.bass.v1.BassService/GetNewTxId"
	BassService_CollectionCredential_FullMethodName         = "/daop.bass.v1.BassService/CollectionCredential"
	BassService_CollectionTransferCredential_FullMethodName = "/daop.bass.v1.BassService/CollectionTransferCredential"
	BassService_CopyrightAuthorization_FullMethodName       = "/daop.bass.v1.BassService/CopyrightAuthorization"
	BassService_CopyrightRegister_FullMethodName            = "/daop.bass.v1.BassService/CopyrightRegister"
	BassService_ProofOfDIDDeclare_FullMethodName            = "/daop.bass.v1.BassService/ProofOfDIDDeclare"
	BassService_BatchMint_FullMethodName                    = "/daop.bass.v1.BassService/BatchMint"
	BassService_BatchTransfer_FullMethodName                = "/daop.bass.v1.BassService/BatchTransfer"
	BassService_BatchUse_FullMethodName                     = "/daop.bass.v1.BassService/BatchUse"
	BassService_CollectionNotify_FullMethodName             = "/daop.bass.v1.BassService/CollectionNotify"
	BassService_BatchNotify_FullMethodName                  = "/daop.bass.v1.BassService/BatchNotify"
	BassService_ChainNotify_FullMethodName                  = "/daop.bass.v1.BassService/ChainNotify"
	BassService_ChainList_FullMethodName                    = "/daop.bass.v1.BassService/ChainList"
	BassService_ChainAgain_FullMethodName                   = "/daop.bass.v1.BassService/ChainAgain"
	BassService_Combination_FullMethodName                  = "/daop.bass.v1.BassService/Combination"
	BassService_Lock_FullMethodName                         = "/daop.bass.v1.BassService/Lock"
	BassService_Unlock_FullMethodName                       = "/daop.bass.v1.BassService/Unlock"
)

// BassServiceClient is the client API for BassService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BassServiceClient interface {
	GetNewTxId(ctx context.Context, in *NewTxIdReq, opts ...grpc.CallOption) (*NewTxIdResp, error)
	CollectionCredential(ctx context.Context, in *CollectionCredentialReq, opts ...grpc.CallOption) (*BassResp, error)
	CollectionTransferCredential(ctx context.Context, in *CollectionTransferCredentialReq, opts ...grpc.CallOption) (*BassResp, error)
	CopyrightAuthorization(ctx context.Context, in *CopyrightAuthorizationReq, opts ...grpc.CallOption) (*BassResp, error)
	CopyrightRegister(ctx context.Context, in *CopyrightClaimReq, opts ...grpc.CallOption) (*BassResp, error)
	ProofOfDIDDeclare(ctx context.Context, in *ProofOfDIDDeclareReq, opts ...grpc.CallOption) (*BassResp, error)
	BatchMint(ctx context.Context, in *BatchPostMintReq, opts ...grpc.CallOption) (*BassResp, error)
	BatchTransfer(ctx context.Context, in *BatchPostTransferReq, opts ...grpc.CallOption) (*BassResp, error)
	BatchUse(ctx context.Context, in *BatchPostUseReq, opts ...grpc.CallOption) (*BassResp, error)
	CollectionNotify(ctx context.Context, in *CollectionNotifyReq, opts ...grpc.CallOption) (*BassResp, error)
	BatchNotify(ctx context.Context, in *BatchNotifyReq, opts ...grpc.CallOption) (*BassResp, error)
	ChainNotify(ctx context.Context, in *ChainNotifyReq, opts ...grpc.CallOption) (*BassResp, error)
	ChainList(ctx context.Context, in *ChainListReq, opts ...grpc.CallOption) (*ChainListResp, error)
	ChainAgain(ctx context.Context, in *ChainAgainReq, opts ...grpc.CallOption) (*BassResp, error)
	Combination(ctx context.Context, in *CombinationReq, opts ...grpc.CallOption) (*BassResp, error)
	Lock(ctx context.Context, in *LockReq, opts ...grpc.CallOption) (*BassResp, error)
	Unlock(ctx context.Context, in *UnlockReq, opts ...grpc.CallOption) (*BassResp, error)
}

type bassServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBassServiceClient(cc grpc.ClientConnInterface) BassServiceClient {
	return &bassServiceClient{cc}
}

func (c *bassServiceClient) GetNewTxId(ctx context.Context, in *NewTxIdReq, opts ...grpc.CallOption) (*NewTxIdResp, error) {
	out := new(NewTxIdResp)
	err := c.cc.Invoke(ctx, BassService_GetNewTxId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) CollectionCredential(ctx context.Context, in *CollectionCredentialReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_CollectionCredential_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) CollectionTransferCredential(ctx context.Context, in *CollectionTransferCredentialReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_CollectionTransferCredential_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) CopyrightAuthorization(ctx context.Context, in *CopyrightAuthorizationReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_CopyrightAuthorization_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) CopyrightRegister(ctx context.Context, in *CopyrightClaimReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_CopyrightRegister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) ProofOfDIDDeclare(ctx context.Context, in *ProofOfDIDDeclareReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_ProofOfDIDDeclare_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) BatchMint(ctx context.Context, in *BatchPostMintReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_BatchMint_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) BatchTransfer(ctx context.Context, in *BatchPostTransferReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_BatchTransfer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) BatchUse(ctx context.Context, in *BatchPostUseReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_BatchUse_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) CollectionNotify(ctx context.Context, in *CollectionNotifyReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_CollectionNotify_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) BatchNotify(ctx context.Context, in *BatchNotifyReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_BatchNotify_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) ChainNotify(ctx context.Context, in *ChainNotifyReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_ChainNotify_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) ChainList(ctx context.Context, in *ChainListReq, opts ...grpc.CallOption) (*ChainListResp, error) {
	out := new(ChainListResp)
	err := c.cc.Invoke(ctx, BassService_ChainList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) ChainAgain(ctx context.Context, in *ChainAgainReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_ChainAgain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) Combination(ctx context.Context, in *CombinationReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_Combination_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) Lock(ctx context.Context, in *LockReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_Lock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bassServiceClient) Unlock(ctx context.Context, in *UnlockReq, opts ...grpc.CallOption) (*BassResp, error) {
	out := new(BassResp)
	err := c.cc.Invoke(ctx, BassService_Unlock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BassServiceServer is the server API for BassService service.
// All implementations should embed UnimplementedBassServiceServer
// for forward compatibility
type BassServiceServer interface {
	GetNewTxId(context.Context, *NewTxIdReq) (*NewTxIdResp, error)
	CollectionCredential(context.Context, *CollectionCredentialReq) (*BassResp, error)
	CollectionTransferCredential(context.Context, *CollectionTransferCredentialReq) (*BassResp, error)
	CopyrightAuthorization(context.Context, *CopyrightAuthorizationReq) (*BassResp, error)
	CopyrightRegister(context.Context, *CopyrightClaimReq) (*BassResp, error)
	ProofOfDIDDeclare(context.Context, *ProofOfDIDDeclareReq) (*BassResp, error)
	BatchMint(context.Context, *BatchPostMintReq) (*BassResp, error)
	BatchTransfer(context.Context, *BatchPostTransferReq) (*BassResp, error)
	BatchUse(context.Context, *BatchPostUseReq) (*BassResp, error)
	CollectionNotify(context.Context, *CollectionNotifyReq) (*BassResp, error)
	BatchNotify(context.Context, *BatchNotifyReq) (*BassResp, error)
	ChainNotify(context.Context, *ChainNotifyReq) (*BassResp, error)
	ChainList(context.Context, *ChainListReq) (*ChainListResp, error)
	ChainAgain(context.Context, *ChainAgainReq) (*BassResp, error)
	Combination(context.Context, *CombinationReq) (*BassResp, error)
	Lock(context.Context, *LockReq) (*BassResp, error)
	Unlock(context.Context, *UnlockReq) (*BassResp, error)
}

// UnimplementedBassServiceServer should be embedded to have forward compatible implementations.
type UnimplementedBassServiceServer struct {
}

func (UnimplementedBassServiceServer) GetNewTxId(context.Context, *NewTxIdReq) (*NewTxIdResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNewTxId not implemented")
}
func (UnimplementedBassServiceServer) CollectionCredential(context.Context, *CollectionCredentialReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectionCredential not implemented")
}
func (UnimplementedBassServiceServer) CollectionTransferCredential(context.Context, *CollectionTransferCredentialReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectionTransferCredential not implemented")
}
func (UnimplementedBassServiceServer) CopyrightAuthorization(context.Context, *CopyrightAuthorizationReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyrightAuthorization not implemented")
}
func (UnimplementedBassServiceServer) CopyrightRegister(context.Context, *CopyrightClaimReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyrightRegister not implemented")
}
func (UnimplementedBassServiceServer) ProofOfDIDDeclare(context.Context, *ProofOfDIDDeclareReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProofOfDIDDeclare not implemented")
}
func (UnimplementedBassServiceServer) BatchMint(context.Context, *BatchPostMintReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchMint not implemented")
}
func (UnimplementedBassServiceServer) BatchTransfer(context.Context, *BatchPostTransferReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchTransfer not implemented")
}
func (UnimplementedBassServiceServer) BatchUse(context.Context, *BatchPostUseReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUse not implemented")
}
func (UnimplementedBassServiceServer) CollectionNotify(context.Context, *CollectionNotifyReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectionNotify not implemented")
}
func (UnimplementedBassServiceServer) BatchNotify(context.Context, *BatchNotifyReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchNotify not implemented")
}
func (UnimplementedBassServiceServer) ChainNotify(context.Context, *ChainNotifyReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChainNotify not implemented")
}
func (UnimplementedBassServiceServer) ChainList(context.Context, *ChainListReq) (*ChainListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChainList not implemented")
}
func (UnimplementedBassServiceServer) ChainAgain(context.Context, *ChainAgainReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChainAgain not implemented")
}
func (UnimplementedBassServiceServer) Combination(context.Context, *CombinationReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Combination not implemented")
}
func (UnimplementedBassServiceServer) Lock(context.Context, *LockReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedBassServiceServer) Unlock(context.Context, *UnlockReq) (*BassResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}

// UnsafeBassServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BassServiceServer will
// result in compilation errors.
type UnsafeBassServiceServer interface {
	mustEmbedUnimplementedBassServiceServer()
}

func RegisterBassServiceServer(s grpc.ServiceRegistrar, srv BassServiceServer) {
	s.RegisterService(&BassService_ServiceDesc, srv)
}

func _BassService_GetNewTxId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewTxIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).GetNewTxId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_GetNewTxId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).GetNewTxId(ctx, req.(*NewTxIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_CollectionCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectionCredentialReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).CollectionCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_CollectionCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).CollectionCredential(ctx, req.(*CollectionCredentialReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_CollectionTransferCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectionTransferCredentialReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).CollectionTransferCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_CollectionTransferCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).CollectionTransferCredential(ctx, req.(*CollectionTransferCredentialReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_CopyrightAuthorization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyrightAuthorizationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).CopyrightAuthorization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_CopyrightAuthorization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).CopyrightAuthorization(ctx, req.(*CopyrightAuthorizationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_CopyrightRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyrightClaimReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).CopyrightRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_CopyrightRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).CopyrightRegister(ctx, req.(*CopyrightClaimReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_ProofOfDIDDeclare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProofOfDIDDeclareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).ProofOfDIDDeclare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_ProofOfDIDDeclare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).ProofOfDIDDeclare(ctx, req.(*ProofOfDIDDeclareReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_BatchMint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchPostMintReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).BatchMint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_BatchMint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).BatchMint(ctx, req.(*BatchPostMintReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_BatchTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchPostTransferReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).BatchTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_BatchTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).BatchTransfer(ctx, req.(*BatchPostTransferReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_BatchUse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchPostUseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).BatchUse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_BatchUse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).BatchUse(ctx, req.(*BatchPostUseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_CollectionNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectionNotifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).CollectionNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_CollectionNotify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).CollectionNotify(ctx, req.(*CollectionNotifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_BatchNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchNotifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).BatchNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_BatchNotify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).BatchNotify(ctx, req.(*BatchNotifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_ChainNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainNotifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).ChainNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_ChainNotify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).ChainNotify(ctx, req.(*ChainNotifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_ChainList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).ChainList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_ChainList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).ChainList(ctx, req.(*ChainListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_ChainAgain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainAgainReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).ChainAgain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_ChainAgain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).ChainAgain(ctx, req.(*ChainAgainReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_Combination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CombinationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).Combination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_Combination_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).Combination(ctx, req.(*CombinationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_Lock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).Lock(ctx, req.(*LockReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BassService_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BassServiceServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BassService_Unlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BassServiceServer).Unlock(ctx, req.(*UnlockReq))
	}
	return interceptor(ctx, in, info, handler)
}

// BassService_ServiceDesc is the grpc.ServiceDesc for BassService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BassService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "daop.bass.v1.BassService",
	HandlerType: (*BassServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNewTxId",
			Handler:    _BassService_GetNewTxId_Handler,
		},
		{
			MethodName: "CollectionCredential",
			Handler:    _BassService_CollectionCredential_Handler,
		},
		{
			MethodName: "CollectionTransferCredential",
			Handler:    _BassService_CollectionTransferCredential_Handler,
		},
		{
			MethodName: "CopyrightAuthorization",
			Handler:    _BassService_CopyrightAuthorization_Handler,
		},
		{
			MethodName: "CopyrightRegister",
			Handler:    _BassService_CopyrightRegister_Handler,
		},
		{
			MethodName: "ProofOfDIDDeclare",
			Handler:    _BassService_ProofOfDIDDeclare_Handler,
		},
		{
			MethodName: "BatchMint",
			Handler:    _BassService_BatchMint_Handler,
		},
		{
			MethodName: "BatchTransfer",
			Handler:    _BassService_BatchTransfer_Handler,
		},
		{
			MethodName: "BatchUse",
			Handler:    _BassService_BatchUse_Handler,
		},
		{
			MethodName: "CollectionNotify",
			Handler:    _BassService_CollectionNotify_Handler,
		},
		{
			MethodName: "BatchNotify",
			Handler:    _BassService_BatchNotify_Handler,
		},
		{
			MethodName: "ChainNotify",
			Handler:    _BassService_ChainNotify_Handler,
		},
		{
			MethodName: "ChainList",
			Handler:    _BassService_ChainList_Handler,
		},
		{
			MethodName: "ChainAgain",
			Handler:    _BassService_ChainAgain_Handler,
		},
		{
			MethodName: "Combination",
			Handler:    _BassService_Combination_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _BassService_Lock_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _BassService_Unlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/bass/bass.proto",
}
